<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2023" />
<meta name="DC.rights.owner" content="(C) Copyright 2023" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="&#34;sxops&#34; interface for RSA and GF(p) cryptographic computations" />
<meta name="DC.relation" scheme="URI" content="GUID-82627570-09DA-49A7-95EC-D502E201BEA3.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="sxops-interface-for-rsa-and-gfp-cryptographic-computations" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<title>"sxops" interface for RSA and GF(p) cryptographic computations</title>
<meta name="Microsoft.Help.Id" content="GUID-2085FE66-A762-4CC0-B054-7F98E8AF999A" />
<meta name="Microsoft.Help.TocParent" content="GUID-2085FE66-A762-4CC0-B054-7F98E8AF999A-GUID-82627570-09DA-49A7-95EC-D502E201BEA3" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLAB Harmony PIC32CX-BZ System Services Reference 4 10/2023" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
         
         function copyContent(content, button) {
         
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                     button.textContent = "Copy";
                     button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
               console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
         }
         
         function cpy(id, button) {
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            
            copyContent(content, button);
         }
         
         document.addEventListener("DOMContentLoaded", function(event) {
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.style.position = "relative";
               var copy = document.createElement("button");
               copy.textContent = "Copy";
               copy.setAttribute("class", "copy-code");
               
               var content = elem.textContent;
               
               copy.addEventListener("click", function(){
                  copyContent(content, copy);
               });
               
               elem.addEventListener("mouseenter", function(evt){
                  elem.prepend(copy);
               });
            });
            
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.addEventListener("mouseleave", function(evt){
                  document.querySelector(".copy-code").remove();
               });
            });
         });
         
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /></head>
<body>
<div class="nested0" aria-labelledby="ariaid-title1" id="sxops-interface-for-rsa-and-gfp-cryptographic-computations"><h1 class="title topictitle1" id="ariaid-title1" style="">"sxops" interface for RSA and GF(p) cryptographic computations</h1><div class="body"><p class="p">Simpler functions to perform public key crypto operations. Included directly
in some interfaces (like sxbuf or OpenSSL engine). The functions
take input operands (large integers) and output operands
which will get the computed results.</p>
<p class="p">Operands have the "sx_op" type. The specific interfaces (like sxbuf) define
the "sx_op" type.</p>
<p class="p">@file</p>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-82627570-09DA-49A7-95EC-D502E201BEA3.html" title="Enter a short description of your topic here (optional).">Silex_PK_API</a></div>
</div>
</div></div>
<div class="topic nested0" aria-labelledby="ariaid-title2" id="rsa-header-file-macro"><h1 class="title topictitle1" id="ariaid-title2" style="">RSA_HEADER_FILE Macro</h1><div class="body"></div>
<div class="topic nested1" aria-labelledby="ariaid-title3" id="c"><h2 class="title topictitle2" id="ariaid-title3" style="">C</h2><div class="body"><pre class="pre codeblock c"><span class="hl-directive">#define</span> <span class="hl-defines">RSA_HEADER_FILE</span>
</pre><p class="p">/
Copyright (c) 2018-2020 Silex Insight sa
Copyright (c) 2018-2020 Beerten Engineering scs
SPDX-License-Identifier: BSD-3-Clause</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title4" id="make-sure-the-application-is-compatible-with-silexpk-api-version-"><h1 class="title topictitle1" id="ariaid-title4" style="">Make sure the application is compatible with SilexPK API version **/</h1><div class="body"><p class="p">SX_PK_API_ASSERT_COMPATIBLE(1, 0);</p>
<p class="p">struct sx_pk_cmd_def;</p>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title5" id="inline"><h1 class="title topictitle1" id="ariaid-title5" style="">inline</h1><div class="body"><p class="p">Function</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title6" id="c-1"><h2 class="title topictitle2" id="ariaid-title6" style="">C</h2><div class="body"><pre class="pre codeblock c"><strong class="hl-keyword">static</strong> <strong class="hl-keyword">inline</strong></pre><p class="p">@addtogroup SX_PK_SXOPS_MOD</p>
<p class="p">@{</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title7" id="asynchronous-non-blocking-primitive-modular-operation-with-1-operand"><h1 class="title topictitle1" id="ariaid-title7" style="">Asynchronous (non-blocking) Primitive modular operation with 1 operand</h1><div class="body"><p class="p">Start a primitive modular operation with 1 operand on the accelerator
and return immediately.</p>
<p class="p">@remark When the operation finishes on the accelerator,
call sx_async_finish_single()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title8" id="parameters"><h2 class="title topictitle2" id="ariaid-title8" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title9" id="parameters-1"><h2 class="title topictitle2" id="ariaid-title9" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cmd Command definition. Should be a primitive modular  operation with 1 operands. For example:  ::SX_PK_CMD_ODD_MOD_INV, ::SX_PK_CMD_ODD_MOD_REDUCE,  ::SX_PK_CMD_EVEN_MOD_INV, ::SX_PK_CMD_EVEN_MOD_REDUCE</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title10" id="parameters-2"><h2 class="title topictitle2" id="ariaid-title10" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> modulo Modulus operand. Must be odd if using ::SX_PK_CMD_ODD_MOD_INV  or ::SX_PK_CMD_ODD_MOD_REDUCE command and even when using ::SX_PK_CMD_EVEN_MOD_INV  or ::SX_PK_CMD_EVEN_MOD_REDUCE command</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title11" id="parameters-3"><h2 class="title topictitle2" id="ariaid-title11" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Operand of modular operation   @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_mod_single_op_cmd_go( struct sx_pk_cnx cnx, const struct sx_pk_cmd_def cmd, const sx_op modulo, const sx_op b) { struct sx_pk_dreq pkreq; struct sx_pk_inops_mod_single_op_cmd inputs;  pkreq = SX_PK_ACQUIRE_REQ(cnx, cmd); if (pkreq.status) return pkreq;  // convert and transfer operands int sizes<span class="xref"></span> = { SX_OP_SIZE(modulo), SX_OP_SIZE(b), }; pkreq.status = SX_PK_LIST_GFP_INSLOTS(pkreq.req, sizes, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq; SX_PK_OP2VMEM(modulo, inputs.n.addr); SX_PK_OP2VMEM(b, inputs.b.addr);  SX_PK_RUN(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title12" id="compute-single-operand-modular-operation"><h1 class="title topictitle1" id="ariaid-title12" style="">Compute single operand modular operation</h1><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e116"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e118"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e116 "><span> </span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e118 "><span>result = b mod modulo for ::SX_PK_CMD_ODD_MOD_REDUCE, ::SX_PK_CMD_EVEN_MOD_REDUCE</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e116 "><span> </span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e118 "><span>result = 1 / b mod modulo for ::SX_PK_CMD_ODD_MOD_INV, ::SX_PK_CMD_EVEN_MOD_INV</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title13" id="parameters-4"><h2 class="title topictitle2" id="ariaid-title13" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title14" id="parameters-5"><h2 class="title topictitle2" id="ariaid-title14" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cmd Command definition. Should be a primitive modular  operation with 1 operand. For example:  ::SX_PK_CMD_ODD_MOD_REDUCE, ::SX_PK_CMD_ODD_MOD_INV,  ::SX_PK_CMD_EVEN_MOD_REDUCE, ::SX_PK_CMD_EVEN_MOD_INV</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title15" id="parameters-6"><h2 class="title topictitle2" id="ariaid-title15" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> modulo Modulus operand. Must be odd if using ::SX_PK_CMD_ODD_MOD_INV  or ::SX_PK_CMD_ODD_MOD_REDUCE command and even when using ::SX_PK_CMD_EVEN_MOD_INV  or ::SX_PK_CMD_EVEN_MOD_REDUCE command</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title16" id="parameters-7"><h2 class="title topictitle2" id="ariaid-title16" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title17" id="parameters-8"><h2 class="title topictitle2" id="ariaid-title17" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> result Result operand   @return ::SX_OK  @return ::SX_ERR_INVALID_PARAM  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @remark It is up to the user to use the corresponding command w.r.t.  the parity of the modulus   @see sx_async_mod_single_op_cmd_go() and sx_async_finish_single()  for an asynchronous version static inline int sx_mod_single_op_cmd( struct sx_pk_cnx cnx, const struct sx_pk_cmd_def cmd, const sx_op modulo, const sx_op b, sx_op result) { struct sx_pk_dreq pkreq; int status;  pkreq = sx_async_mod_single_op_cmd_go(cnx, cmd, modulo, b); if (pkreq.status) return pkreq.status;  status = SX_PK_WAIT(pkreq.req); sx_async_finish_single(pkreq.req, result);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title18" id="asynchronous-non-blocking-primitive-modular-operation-with-2-operands"><h1 class="title topictitle1" id="ariaid-title18" style="">Asynchronous (non-blocking) Primitive modular operation with 2 operands</h1><div class="body"><p class="p">Start a primitive modular operation with 2 operands on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_async_finish_single()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title19" id="parameters-9"><h2 class="title topictitle2" id="ariaid-title19" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title20" id="parameters-10"><h2 class="title topictitle2" id="ariaid-title20" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cmd Command definition. Should be a primitive modular  operation with 2 operands. For example:  ::SX_PK_CMD_MOD_ADD, ::SX_PK_CMD_MOD_SUB,  ::SX_PK_CMD_ODD_MOD_MULT, ::SX_PK_CMD_ODD_MOD_DIV</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title21" id="parameters-11"><h2 class="title topictitle2" id="ariaid-title21" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> modulo Modulus operand for the modular operantion</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title22" id="parameters-12"><h2 class="title topictitle2" id="ariaid-title22" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> a First operand of modular operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title23" id="parameters-13"><h2 class="title topictitle2" id="ariaid-title23" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Second operand of modular operation   @return Acquired acceleration request for this operation   @see sx_mod_primitive_cmd() for a synchronous version static inline struct sx_pk_dreq sx_async_mod_cmd_go( struct sx_pk_cnx cnx, const struct sx_pk_cmd_def cmd, const sx_op modulo, const sx_op a, const sx_op b) { struct sx_pk_dreq pkreq; struct sx_pk_inops_mod_cmd inputs;  pkreq = SX_PK_ACQUIRE_REQ(cnx, cmd); if (pkreq.status) return pkreq;  // convert and transfer operands int sizes<span class="xref"></span> = { SX_OP_SIZE(modulo), SX_OP_SIZE(a), SX_OP_SIZE(b), }; pkreq.status = SX_PK_LIST_GFP_INSLOTS(pkreq.req, sizes, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq; SX_PK_OP2VMEM(modulo, inputs.n.addr); SX_PK_OP2VMEM(a, inputs.a.addr); SX_PK_OP2VMEM(b, inputs.b.addr);  SX_PK_RUN(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title24" id="primitive-modular-operation-with-2-operands"><h1 class="title topictitle1" id="ariaid-title24" style="">Primitive modular operation with 2 operands</h1><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e230"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e232"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e230 "><span> </span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e232 "><span>result = a + b mod modulo for ::SX_PK_CMD_MOD_ADD</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e230 "><span> </span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e232 "><span>result = a</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e230 "><span> </span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e232 "><span>result = a b mod modulo for ::SX_PK_CMD_ODD_MOD_MULT with odd modulus</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e230 "><span> </span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e232 "><span>result = a / b mod modulo for ::SX_PK_CMD_ODD_MOD_DIV with odd modulus   Perform a modular addition or subtraction or  odd modular multiplication or odd modular division.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title25" id="parameters-14"><h2 class="title topictitle2" id="ariaid-title25" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title26" id="parameters-15"><h2 class="title topictitle2" id="ariaid-title26" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cmd Command definition. Should be a primitive modular  operation with 2 operands. See description</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title27" id="parameters-16"><h2 class="title topictitle2" id="ariaid-title27" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> modulo Modulus operand for the modular operantion</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title28" id="parameters-17"><h2 class="title topictitle2" id="ariaid-title28" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> a First operand of modular operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title29" id="parameters-18"><h2 class="title topictitle2" id="ariaid-title29" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Second operand of modular operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title30" id="parameters-19"><h2 class="title topictitle2" id="ariaid-title30" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> result Result operand of the modular operation   @return ::SX_OK  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_INVALID_PARAM  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_mod_cmd_go() and sx_async_finish_single()  for an asynchronous version static inline int sx_mod_primitive_cmd( struct sx_pk_cnx cnx, const struct sx_pk_cmd_def cmd, const sx_op modulo, const sx_op a, const sx_op b, sx_op result) { struct sx_pk_dreq pkreq; int status;  pkreq = sx_async_mod_cmd_go(cnx, cmd, modulo, a, b); if (pkreq.status) return pkreq.status;  status = SX_PK_WAIT(pkreq.req); sx_async_finish_single(pkreq.req, result);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title31" id="asynchronous-non-blocking-mod-inversion"><h1 class="title topictitle1" id="ariaid-title31" style="">Asynchronous (non-blocking) mod inversion.</h1><div class="body"><p class="p">Start a modular inversion on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_async_finish_single()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title32" id="parameters-20"><h2 class="title topictitle2" id="ariaid-title32" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title33" id="parameters-21"><h2 class="title topictitle2" id="ariaid-title33" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> modulo Modulus operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title34" id="parameters-22"><h2 class="title topictitle2" id="ariaid-title34" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Operand to inverse   @return Acquired acceleration request for this operation   @see sx_async_finish_single(), sx_mod_inv() static inline struct sx_pk_dreq sx_async_mod_inv_go( struct sx_pk_cnx cnx, const sx_op modulo, const sx_op b) { return sx_async_mod_single_op_cmd_go(cnx, SX_PK_CMD_ODD_MOD_INV, modulo, b); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title35" id="compute-modular-inversion"><h1 class="title topictitle1" id="ariaid-title35" style="">Compute modular inversion</h1><div class="body"><p class="p">result = 1/b mod modulo</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title36" id="parameters-23"><h2 class="title topictitle2" id="ariaid-title36" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title37" id="parameters-24"><h2 class="title topictitle2" id="ariaid-title37" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> modulo Modulus operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title38" id="parameters-25"><h2 class="title topictitle2" id="ariaid-title38" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Operand to inverse</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title39" id="parameters-26"><h2 class="title topictitle2" id="ariaid-title39" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> result Result operand of the modular inversion   @return ::SX_OK  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_INVALID_PARAM  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_mod_inv_go() for an asynchronous verion static inline int sx_mod_inv( struct sx_pk_cnx cnx, const sx_op modulo, const sx_op b, sx_op result) { struct sx_pk_dreq pkreq; int status;  pkreq = sx_async_mod_inv_go(cnx, modulo, b); if (pkreq.status) return pkreq.status;  status = SX_PK_WAIT(pkreq.req);  sx_async_finish_single(pkreq.req, result);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title40" id="asynchronous-non-blocking-modular-exponentiation"><h1 class="title topictitle1" id="ariaid-title40" style="">Asynchronous (non-blocking) modular exponentiation.</h1><div class="body"><p class="p">Start a modular exponentiation on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_async_mod_exp_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title41" id="parameters-27"><h2 class="title topictitle2" id="ariaid-title41" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title42" id="parameters-28"><h2 class="title topictitle2" id="ariaid-title42" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> input Base operand for modular exponentiation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title43" id="parameters-29"><h2 class="title topictitle2" id="ariaid-title43" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> exp Exponent operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title44" id="parameters-30"><h2 class="title topictitle2" id="ariaid-title44" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> m Modulus operand   @return Acquired acceleration request for this operation   @see sx_mod_exp() for the synchronous version static inline struct sx_pk_dreq sx_async_mod_exp_go( struct sx_pk_cnx cnx, const sx_op input, const sx_op exp, const sx_op m) { return sx_async_mod_cmd_go(cnx, SX_PK_CMD_MOD_EXP, m, input, exp); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title45" id="finish-asynchronous-non-blocking-modular-exponentiation"><h1 class="title topictitle1" id="ariaid-title45" style="">Finish asynchronous (non-blocking) modular exponentiation.</h1><div class="body"><p class="p">Get the output operand of the modular exponentiation and release  the accelerator.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title46" id="parameters-31"><h2 class="title topictitle2" id="ariaid-title46" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title47" id="parameters-32"><h2 class="title topictitle2" id="ariaid-title47" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> result Result operand   @see sx_async_mod_exp_go() and sx_mod_exp() static inline void sx_async_mod_exp_end( sx_pk_accel req, sx_op result) { sx_async_finish_single(req, result); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title48" id="compute-modular-exponentiation"><h1 class="title topictitle1" id="ariaid-title48" style="">Compute modular exponentiation.</h1><div class="body"><p class="p">result = input ^ exp mod m</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title49" id="parameters-33"><h2 class="title topictitle2" id="ariaid-title49" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title50" id="parameters-34"><h2 class="title topictitle2" id="ariaid-title50" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> input Base operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title51" id="parameters-35"><h2 class="title topictitle2" id="ariaid-title51" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> exp Exponent operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title52" id="parameters-36"><h2 class="title topictitle2" id="ariaid-title52" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> m Modulus operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title53" id="parameters-37"><h2 class="title topictitle2" id="ariaid-title53" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> result Result operand   @return ::SX_OK  @return ::SX_ERR_INVALID_PARAM  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_mod_exp_go(), sx_async_mod_exp_end()  for an asynchronous version static inline int sx_mod_exp( struct sx_pk_cnx cnx, const sx_op input, const sx_op exp, const sx_op m, sx_op result) { struct sx_pk_dreq pkreq; int status;  pkreq = sx_async_mod_exp_go(cnx, input, exp, m); if (pkreq.status) return pkreq.status;  status = SX_PK_WAIT(pkreq.req); sx_async_mod_exp_end(pkreq.req, result); return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title54" id="-"><h1 class="title topictitle1" id="ariaid-title54" style="">@} */</h1><div class="body"></div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title55" id="inline-1"><h1 class="title topictitle1" id="ariaid-title55" style="">inline</h1><div class="body"><p class="p">Function</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title56" id="c-2"><h2 class="title topictitle2" id="ariaid-title56" style="">C</h2><div class="body"><pre class="pre codeblock c"><strong class="hl-keyword">static</strong> <strong class="hl-keyword">inline</strong></pre><p class="p">@addtogroup SX_PK_SXOPS_RSA   @{</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title57" id="asynchronous-non-blocking-modular-exponentiation-with-crt"><h1 class="title topictitle1" id="ariaid-title57" style="">Asynchronous (non-blocking) modular exponentiation with CRT.</h1><div class="body"><p class="p">Start a modular exponentiation with CRT on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_async_crt_mod_exp_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title58" id="parameters-38"><h2 class="title topictitle2" id="ariaid-title58" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title59" id="parameters-39"><h2 class="title topictitle2" id="ariaid-title59" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> in Input</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title60" id="parameters-40"><h2 class="title topictitle2" id="ariaid-title60" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> p Prime number p</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title61" id="parameters-41"><h2 class="title topictitle2" id="ariaid-title61" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> q Prime number q</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title62" id="parameters-42"><h2 class="title topictitle2" id="ariaid-title62" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> dp d mod (p-1), with d the private key</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title63" id="parameters-43"><h2 class="title topictitle2" id="ariaid-title63" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> dq d mod (q-1), with d the private key</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title64" id="parameters-44"><h2 class="title topictitle2" id="ariaid-title64" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> qinv q^(-1) mod p   @return Acquired acceleration request for this operation   @see sx_async_crt_mod_exp_end() static inline struct sx_pk_dreq sx_async_crt_mod_exp_go( struct sx_pk_cnx cnx, const sx_op in, const sx_op p, const sx_op q, const sx_op dp, const sx_op dq, const sx_op qinv) {  struct sx_pk_dreq pkreq; struct sx_pk_inops_crt_mod_exp inputs;  pkreq = SX_PK_ACQUIRE_REQ(cnx, SX_PK_CMD_MOD_EXP_CRT); if (pkreq.status) return pkreq;  // convert and transfer operands int sizes<span class="xref"></span> = { SX_OP_SIZE(p), SX_OP_SIZE(q), SX_OP_SIZE(in), SX_OP_SIZE(dp), SX_OP_SIZE(dq), SX_OP_SIZE(qinv) }; pkreq.status = SX_PK_LIST_GFP_INSLOTS(pkreq.req, sizes, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq; SX_PK_OP2VMEM(in, inputs.in.addr); SX_PK_OP2VMEM(p, inputs.p.addr); SX_PK_OP2VMEM(q, inputs.q.addr); SX_PK_OP2VMEM(dp, inputs.dp.addr); SX_PK_OP2VMEM(dq, inputs.dq.addr); SX_PK_OP2VMEM(qinv, inputs.qinv.addr);  SX_PK_RUN(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title65" id="finish-asynchronous-non-blocking-modular-exponentiation-with-crt"><h1 class="title topictitle1" id="ariaid-title65" style="">Finish asynchronous (non-blocking) modular exponentiation with CRT.</h1><div class="body"><p class="p">Get the output operand of the modular exponentiation with CRT  and release the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title66" id="parameters-45"><h2 class="title topictitle2" id="ariaid-title66" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title67" id="parameters-46"><h2 class="title topictitle2" id="ariaid-title67" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> result   @see sx_async_crt_mod_exp_go() static inline void sx_async_crt_mod_exp_end( sx_pk_accel req, sx_op result) { sx_async_finish_single(req, result); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title68" id="compute-modular-exponentiation-with-crt"><h1 class="title topictitle1" id="ariaid-title68" style="">Compute modular exponentiation with CRT</h1><div class="body"><p class="p">Compute (result = in <sup class="ph sup"> db mod m) with those steps:   vp = in </sup> dp mod p  vq = in ^ dq mod q  u = (vp -vq) qinv mod p  result = vq + u q</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title69" id="parameters-47"><h2 class="title topictitle2" id="ariaid-title69" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title70" id="parameters-48"><h2 class="title topictitle2" id="ariaid-title70" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> in Input</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title71" id="parameters-49"><h2 class="title topictitle2" id="ariaid-title71" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> p Prime number p</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title72" id="parameters-50"><h2 class="title topictitle2" id="ariaid-title72" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> q Prime number q</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title73" id="parameters-51"><h2 class="title topictitle2" id="ariaid-title73" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> dp d mod (p-1), with d the private key</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title74" id="parameters-52"><h2 class="title topictitle2" id="ariaid-title74" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> dq d mod (q-1), with d the private key</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title75" id="parameters-53"><h2 class="title topictitle2" id="ariaid-title75" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> qinv q^(-1) mod p</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title76" id="parameters-54"><h2 class="title topictitle2" id="ariaid-title76" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> result Result of modular exponentiation with CRT   @return ::SX_OK  @return ::SX_ERR_INVALID_PARAM  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_crt_mod_exp_go(), sx_async_crt_mod_exp_end()  for an asynchronous version static inline int sx_crt_mod_exp( struct sx_pk_cnx cnx, const sx_op in, const sx_op p, const sx_op q, const sx_op dp, const sx_op dq, const sx_op qinv, sx_op result) { struct sx_pk_dreq pkreq; int status;  pkreq = sx_async_crt_mod_exp_go(cnx, in, p, q, dp, dq, qinv); if (pkreq.status) return pkreq.status; status = SX_PK_WAIT(pkreq.req); sx_async_crt_mod_exp_end(pkreq.req, result);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title77" id="asynchronous-non-blocking-rsa-private-key-generation"><h1 class="title topictitle1" id="ariaid-title77" style="">Asynchronous (non-blocking) RSA private key generation.</h1><div class="body"><p class="p">Start an RSA private key generation on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_async_rsa_keygen_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title78" id="parameters-55"><h2 class="title topictitle2" id="ariaid-title78" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title79" id="parameters-56"><h2 class="title topictitle2" id="ariaid-title79" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> p Prime value p</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title80" id="parameters-57"><h2 class="title topictitle2" id="ariaid-title80" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> q Prime value q</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title81" id="parameters-58"><h2 class="title topictitle2" id="ariaid-title81" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> public_expo Public exponent operand   @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_rsa_keygen_go(struct sx_pk_cnx cnx, const sx_op p, const sx_op q, const sx_op public_expo) { struct sx_pk_dreq pkreq; struct sx_pk_inops_rsa_keygen inputs;  pkreq = SX_PK_ACQUIRE_REQ(cnx, SX_PK_CMD_RSA_KEYGEN); if (pkreq.status) return pkreq;  // convert and transfer operands int sizes<span class="xref"></span> = { SX_OP_SIZE(p), SX_OP_SIZE(q), SX_OP_SIZE(public_expo) }; pkreq.status = SX_PK_LIST_GFP_INSLOTS(pkreq.req, sizes, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq; SX_PK_OP2VMEM(p, inputs.p.addr); SX_PK_OP2VMEM(q, inputs.q.addr); SX_PK_OP2VMEM(public_expo, inputs.e.addr);  SX_PK_RUN(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title82" id="finish-asynchronous-non-blocking-rsa-private-key-generation"><h1 class="title topictitle1" id="ariaid-title82" style="">Finish asynchronous (non-blocking) RSA private key generation.</h1><div class="body"><p class="p">Get the output operands of the RSA private key generation  and release the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title83" id="parameters-59"><h2 class="title topictitle2" id="ariaid-title83" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title84" id="parameters-60"><h2 class="title topictitle2" id="ariaid-title84" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> n Multiple of 2 primes p and q</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title85" id="parameters-61"><h2 class="title topictitle2" id="ariaid-title85" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> lambda_n Least common multiple of p-1 and q-1</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title86" id="parameters-62"><h2 class="title topictitle2" id="ariaid-title86" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> privkey Private key static inline void sx_async_rsa_keygen_end(sx_pk_accel req, sx_op n, sx_op lambda_n, sx_op privkey) { const char outputs = SX_PK_GET_OUTPUT_OPS(req); const int opsz = SX_PK_GET_OPSIZE(req);  SX_PK_MEM2OP(outputs<span class="xref"></span>, opsz, n); SX_PK_MEM2OP(outputs<span class="xref"></span>, opsz, lambda_n); SX_PK_MEM2OP(outputs<span class="xref"></span>, opsz, privkey);  SX_PK_RELEASE_REQ(req); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title87" id="compute-rsa-private-key-and-lambda-n-from-primes-p-and-q"><h1 class="title topictitle1" id="ariaid-title87" style="">Compute RSA private key and lambda_n from primes p and q.</h1><div class="body"><p class="p">The private key is generated with the following steps:  1. n = p q  2. lambda_n = lcm(p-1,q-1)  3. d = e^-1 % lambda_n   Where d is the private key (privkey).</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title88" id="parameters-63"><h2 class="title topictitle2" id="ariaid-title88" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title89" id="parameters-64"><h2 class="title topictitle2" id="ariaid-title89" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> p Prime value p</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title90" id="parameters-65"><h2 class="title topictitle2" id="ariaid-title90" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> q Prime value q</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title91" id="parameters-66"><h2 class="title topictitle2" id="ariaid-title91" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> public_expo Public exponent operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title92" id="parameters-67"><h2 class="title topictitle2" id="ariaid-title92" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> n Resulting n operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title93" id="parameters-68"><h2 class="title topictitle2" id="ariaid-title93" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> lambda_n Resulting lambda_n operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title94" id="parameters-69"><h2 class="title topictitle2" id="ariaid-title94" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> privkey Resulting rivate key operand   @return ::SX_OK  @return ::SX_ERR_INVALID_PARAM  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_rsa_keygen_go(), sx_async_rsa_keygen_end()  for an asynchronous version static inline  int sx_rsa_keygen(struct sx_pk_cnx cnx, const sx_op p, const sx_op q, const sx_op public_expo, sx_op n, sx_op lambda_n, sx_op privkey) { struct sx_pk_dreq pkreq; int status;  pkreq = sx_async_rsa_keygen_go(cnx, p, q, public_expo); if (pkreq.status) return pkreq.status;  status = SX_PK_WAIT(pkreq.req);  sx_async_rsa_keygen_end(pkreq.req, n, lambda_n, privkey);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title95" id="asynchronous-non-blocking-rsa-crt-private-key-parameters"><h1 class="title topictitle1" id="ariaid-title95" style="">Asynchronous (non-blocking) RSA CRT private key parameters.</h1><div class="body"><p class="p">Start a RSA CRT private key generation on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_async_rsa_crt_keyparams_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title96" id="parameters-70"><h2 class="title topictitle2" id="ariaid-title96" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title97" id="parameters-71"><h2 class="title topictitle2" id="ariaid-title97" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> p Prime operand p</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title98" id="parameters-72"><h2 class="title topictitle2" id="ariaid-title98" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> q Prime operand q</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title99" id="parameters-73"><h2 class="title topictitle2" id="ariaid-title99" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> privkey Private key   @return Acquired acceleration request for this operation   @see sx_async_rsa_crt_keyparams_end() and sx_async_rsa_crt_keyparams() static inline struct sx_pk_dreq sx_async_rsa_crt_keyparams_go( struct sx_pk_cnx cnx, const sx_op p, const sx_op q, const sx_op privkey) { struct sx_pk_dreq pkreq; struct sx_pk_inops_rsa_crt_keyparams inputs;  pkreq = SX_PK_ACQUIRE_REQ(cnx, SX_PK_CMD_RSA_CRT_KEYPARAMS); if (pkreq.status) return pkreq;  // convert and transfer operands int sizes<span class="xref"></span> = { SX_OP_SIZE(p), SX_OP_SIZE(q), SX_OP_SIZE(privkey) }; pkreq.status = SX_PK_LIST_GFP_INSLOTS(pkreq.req, sizes, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq; SX_PK_OP2VMEM(p, inputs.p.addr); SX_PK_OP2VMEM(q, inputs.q.addr); SX_PK_OP2VMEM(privkey, inputs.privkey.addr);  SX_PK_RUN(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title100" id="finish-asynchronous-non-blocking-rsa-crt-private-key-parameters"><h1 class="title topictitle1" id="ariaid-title100" style="">Finish asynchronous (non-blocking) RSA CRT private key parameters.</h1><div class="body"><p class="p">Get the output operands of the RSA CRT private key parameters  and release the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title101" id="parameters-74"><h2 class="title topictitle2" id="ariaid-title101" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title102" id="parameters-75"><h2 class="title topictitle2" id="ariaid-title102" style="">Parameters</h2><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e872"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e874"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e872 "><span><span class="xref"></span> dp d mod (p</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e874 "><span>1)</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title103" id="parameters-76"><h2 class="title topictitle2" id="ariaid-title103" style="">Parameters</h2><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e894"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e896"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e894 "><span><span class="xref"></span> dq d mod (q</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e896 "><span>1)</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title104" id="parameters-77"><h2 class="title topictitle2" id="ariaid-title104" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> qinv q ^ -1 mod p   @see sx_async_rsa_crt_keyparams_go() and sx_rsa_crt_keyparams() static inline void sx_async_rsa_crt_keyparams_end(sx_pk_accel req, sx_op dp, sx_op dq, sx_op qinv) { const char outputs = SX_PK_GET_OUTPUT_OPS(req); const int opsz = SX_PK_GET_OPSIZE(req);  SX_PK_MEM2OP(outputs<span class="xref"></span>, opsz, dp); SX_PK_MEM2OP(outputs<span class="xref"></span>, opsz, dq); SX_PK_MEM2OP(outputs<span class="xref"></span>, opsz, qinv);  SX_PK_RELEASE_REQ(req); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title105" id="compute-rsa-crt-private-key-parameters"><h1 class="title topictitle1" id="ariaid-title105" style="">Compute RSA CRT private key parameters.</h1><div class="body"><p class="p">Computes the following parameters: | Param | Description |
|:----- |:----------- |</p>
<p class="p">| dp = d mod (p | 1) |
| dq = d mod (q | 1)  qinv = q ^ -1 mod p  where d is the private key and the pair p and q are the secret primes used  to create the RSA private key.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title106" id="parameters-78"><h2 class="title topictitle2" id="ariaid-title106" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> cnx Connection structure obtained through SX_PK_OPEN() at startup</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title107" id="parameters-79"><h2 class="title topictitle2" id="ariaid-title107" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> p Prime value p</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title108" id="parameters-80"><h2 class="title topictitle2" id="ariaid-title108" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> q Prime value q</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title109" id="parameters-81"><h2 class="title topictitle2" id="ariaid-title109" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> privkey Private key operand</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title110" id="parameters-82"><h2 class="title topictitle2" id="ariaid-title110" style="">Parameters</h2><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e973"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e975"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e973 "><span><span class="xref"></span> dp d mod (p</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e975 "><span>1)</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title111" id="parameters-83"><h2 class="title topictitle2" id="ariaid-title111" style="">Parameters</h2><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e995"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d12841e997"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e995 "><span><span class="xref"></span> dq d mod (q</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d12841e997 "><span>1)</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title112" id="parameters-84"><h2 class="title topictitle2" id="ariaid-title112" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> qinv q ^ -1 mod p   @return ::SX_OK  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_OUT_OF_RANGE  @return ::SX_ERR_INVALID_PARAM  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_rsa_crt_keyparams_go(), sx_async_rsa_crt_keyparams_end()  for an asynchronous version static inline int sx_rsa_crt_keyparams(struct sx_pk_cnx cnx, const sx_op p, const sx_op q, const sx_op privkey, sx_op dp, sx_op dq, sx_op qinv) { struct sx_pk_dreq pkreq; int status;  pkreq = sx_async_rsa_crt_keyparams_go(cnx, p, q, privkey); if (pkreq.status) return pkreq.status;  status = SX_PK_WAIT(pkreq.req);  sx_async_rsa_crt_keyparams_end(pkreq.req, dp, dq, qinv);  return status; }}</p>
</div>
</div>
</div>
</body>
</html>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2023" />
<meta name="DC.rights.owner" content="(C) Copyright 2023" />
<meta name="generator" content="DITA-OT" /><meta name="DC.type" content="topic" />
<meta name="DC.title" content="&#34;sxops&#34; interface for EC J-PAKE computations." />
<meta name="DC.relation" scheme="URI" content="GUID-82627570-09DA-49A7-95EC-D502E201BEA3.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="sxops-interface-for-ec-j-pake-computations" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<title>"sxops" interface for EC J-PAKE computations.</title>
<meta name="Microsoft.Help.Id" content="GUID-2085FE66-A762-4CC0-B054-7F98E8AF999A" />
<meta name="Microsoft.Help.TocParent" content="GUID-2085FE66-A762-4CC0-B054-7F98E8AF999A-GUID-82627570-09DA-49A7-95EC-D502E201BEA3" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLAB Harmony PIC32CX-BZ System Services Reference 4 10/2023" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
         
         function copyContent(content, button) {
         
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                     button.textContent = "Copy";
                     button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
               console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
         }
         
         function cpy(id, button) {
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            
            copyContent(content, button);
         }
         
         document.addEventListener("DOMContentLoaded", function(event) {
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.style.position = "relative";
               var copy = document.createElement("button");
               copy.textContent = "Copy";
               copy.setAttribute("class", "copy-code");
               
               var content = elem.textContent;
               
               copy.addEventListener("click", function(){
                  copyContent(content, copy);
               });
               
               elem.addEventListener("mouseenter", function(evt){
                  elem.prepend(copy);
               });
            });
            
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.addEventListener("mouseleave", function(evt){
                  document.querySelector(".copy-code").remove();
               });
            });
         });
         
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /></head>
<body>
<div class="nested0" aria-labelledby="ariaid-title1" id="sxops-interface-for-ec-j-pake-computations"><h1 class="title topictitle1" id="ariaid-title1" style="">"sxops" interface for EC J-PAKE computations.</h1><div class="body"><p class="p">Simpler functions to perform public key crypto operations. Included directly
in some interfaces (like sxbuf or OpenSSL engine). The functions
take input operands (large integers) and output operands
which will receive the computed results.</p>
<p class="p">Operands have the "sx_op" type. The specific interfaces (like sxbuf) define
the "sx_op" type.</p>
<p class="p">@file</p>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-82627570-09DA-49A7-95EC-D502E201BEA3.html" title="Enter a short description of your topic here (optional).">Silex_PK_API</a></div>
</div>
</div></div>
<div class="topic nested0" aria-labelledby="ariaid-title2" id="ecjpake-header-file-macro"><h1 class="title topictitle1" id="ariaid-title2" style="">ECJPAKE_HEADER_FILE Macro</h1><div class="body"></div>
<div class="topic nested1" aria-labelledby="ariaid-title3" id="c"><h2 class="title topictitle2" id="ariaid-title3" style="">C</h2><div class="body"><pre class="pre codeblock c"><span class="hl-directive">#define</span> <span class="hl-defines">ECJPAKE_HEADER_FILE</span>
</pre><p class="p">/
Copyright (c) 2020 Silex Insight sa
SPDX-License-Identifier: BSD-3-Clause</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title4" id="make-sure-the-application-is-compatible-with-silexpk-api-version-"><h1 class="title topictitle1" id="ariaid-title4" style="">Make sure the application is compatible with SilexPK API version **/</h1><div class="body"><p class="p">SX_PK_API_ASSERT_COMPATIBLE(1, 3);</p>
<p class="p">struct sx_pk_ecurve;</p>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title5" id="sx-pk-point-function"><h1 class="title topictitle1" id="ariaid-title5" style="">sx_pk_point Function</h1><div class="body"></div>
<div class="topic nested1" aria-labelledby="ariaid-title6" id="c-1"><h2 class="title topictitle2" id="ariaid-title6" style="">C</h2><div class="body"><pre class="pre codeblock c"><strong class="hl-keyword">struct</strong> sx_pk_point {</pre><p class="p">@addtogroup SX_PK_SXOPS_ECJPAKE</p>
<p class="p">@{</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title7" id="curve-generator-point-for-sx-ecjpake-verify-zkp-or-sx-ecjpake-verify-zkp-go-"><h1 class="title topictitle1" id="ariaid-title7" style="">Curve generator point for sx_ecjpake_verify_zkp() or sx_ecjpake_verify_zkp_go() */</h1><div class="body"></div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title8" id="affine-point-parameter-group"><h1 class="title topictitle1" id="ariaid-title8" style="">Affine point parameter group</h1><div class="body"><p class="p">This structure is used for point values which are stored in
two consecutive locations (x and y).
struct sx_pk_point {
sx_op x; /&lt; x-coordinate /
sx_op y; /&lt; y-coordinate /
};</p>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title9" id="asynchronous-ec-j-pake-proof-generation"><h1 class="title topictitle1" id="ariaid-title9" style="">Asynchronous EC J-PAKE proof generation</h1><div class="body"><p class="p">Start a EC J-PAKE proof generation operation on the accelerator
and return immediately.</p>
<p class="p">@remark When the operation finishes on the accelerator,
call sx_async_generate_zkp_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title10" id="parameters"><h2 class="title topictitle2" id="ariaid-title10" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title11" id="parameters-1"><h2 class="title topictitle2" id="ariaid-title11" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> v Random input (&lt; n)</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title12" id="parameters-2"><h2 class="title topictitle2" id="ariaid-title12" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x Exponent</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title13" id="parameters-3"><h2 class="title topictitle2" id="ariaid-title13" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> h Hash digest   Truncation or padding should be done by user application   @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_generate_zkp_go( const struct sx_pk_ecurve curve, const sx_op v, const sx_op x, const sx_op h) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_generate_zkp inputs;  pkreq = SX_PK_ACQUIRE_REQ(curve-&gt;cnx, SX_PK_CMD_ECJPAKE_GENERATE_ZKP); if (pkreq.status) return pkreq;  pkreq.status = SX_PK_LIST_ECC_INSLOTS(pkreq.req, curve, 0, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq;  int opsz = SX_PK_GET_OPSIZE(pkreq.req);  SX_PK_OP2MEM(v, inputs.v.addr, opsz); SX_PK_OP2MEM(x, inputs.x.addr, opsz); SX_PK_OP2MEM(h, inputs.h.addr, opsz);  SX_PK_RUN(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title14" id="finish-asynchronous-non-blocking-ec-j-pake-proof-generation"><h1 class="title topictitle1" id="ariaid-title14" style="">Finish asynchronous (non-blocking) EC J-PAKE proof generation.</h1><div class="body"><p class="p">Get the output operands of the EC J-PAKE proof generation  and release the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title15" id="parameters-4"><h2 class="title topictitle2" id="ariaid-title15" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title16" id="parameters-5"><h2 class="title topictitle2" id="ariaid-title16" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> r The resulting value static inline void sx_ecjpake_generate_zkp_end( sx_pk_accel req, sx_op r) { sx_async_finish_single(req, r); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title17" id="perform-an-ec-j-pake-proof-generation"><h1 class="title topictitle1" id="ariaid-title17" style="">Perform an EC J-PAKE proof generation</h1><div class="body"><p class="p">The proof generation has the following steps: | Param | Description |
|:----- |:----------- |</p>
<p class="p">| 1. r = (v | (x h)) % n <span class="xref"></span></p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title18" id="parameters-6"><h2 class="title topictitle2" id="ariaid-title18" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title19" id="parameters-7"><h2 class="title topictitle2" id="ariaid-title19" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> v Random input (&lt; n)</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title20" id="parameters-8"><h2 class="title topictitle2" id="ariaid-title20" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x Exponent</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title21" id="parameters-9"><h2 class="title topictitle2" id="ariaid-title21" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> h Hash digest   Truncation or padding should be done by user application</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title22" id="parameters-10"><h2 class="title topictitle2" id="ariaid-title22" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> r The result   @return ::SX_OK  @return ::SX_ERR_OUT_OF_RANGE  @return ::SX_ERR_POINT_NOT_ON_CURVE  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_ecjpake_generate_zkp_go(), sx_async_ecjpake_generate_zkp_end() for  an asynchronous version static inline int sx_ecjpake_generate_zkp( const struct sx_pk_ecurve curve, const sx_op v, const sx_op x, const sx_op h, sx_op r ) { uint32_t status; struct sx_pk_dreq pkreq;  pkreq = sx_ecjpake_generate_zkp_go(curve, v, x, h); if (pkreq.status) return pkreq.status;  status = SX_PK_WAIT(pkreq.req);  sx_ecjpake_generate_zkp_end(pkreq.req, r);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title23" id="asynchronous-ec-j-pake-proof-verification"><h1 class="title topictitle1" id="ariaid-title23" style="">Asynchronous EC J-PAKE proof verification</h1><div class="body"><p class="p">Start an EC J-PAKE proof verification operation on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_ecjpake_verify_zkp_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title24" id="parameters-11"><h2 class="title topictitle2" id="ariaid-title24" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title25" id="parameters-12"><h2 class="title topictitle2" id="ariaid-title25" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> v Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title26" id="parameters-13"><h2 class="title topictitle2" id="ariaid-title26" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title27" id="parameters-14"><h2 class="title topictitle2" id="ariaid-title27" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> r Proof to be verified</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title28" id="parameters-15"><h2 class="title topictitle2" id="ariaid-title28" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> h Hash digest</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title29" id="parameters-16"><h2 class="title topictitle2" id="ariaid-title29" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> g Point on the curve (Optional, pass SX_PT_CURVE_GENERATOR to use  the curve generator point)   Truncation or padding should be done by user application   @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_verify_zkp_go( const struct sx_pk_ecurve curve, const struct sx_pk_point v, const struct sx_pk_point x, const sx_op r, const sx_op h, const struct sx_pk_point g) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_verify_zkp inputs;  pkreq = SX_PK_ACQUIRE_REQ(curve-&gt;cnx, SX_PK_CMD_ECJPAKE_VERIFY_ZKP); if (pkreq.status) return pkreq;  pkreq.status = SX_PK_LIST_ECC_INSLOTS(pkreq.req, curve, 0, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq;  int opsz = SX_PK_GET_OPSIZE(pkreq.req);  sx_pk_op2mem(v-&gt;x, inputs.xv.addr, opsz); sx_pk_op2mem(v-&gt;y, inputs.yv.addr, opsz); sx_pk_op2mem(x-&gt;x, inputs.xx.addr, opsz); sx_pk_op2mem(x-&gt;y, inputs.yx.addr, opsz); sx_pk_op2mem(r, inputs.r.addr, opsz); sx_pk_op2mem(h, inputs.h.addr, opsz);  if (g != SX_PT_CURVE_GENERATOR) { sx_pk_op2mem(g-&gt;x, inputs.xg2.addr, opsz); sx_pk_op2mem(g-&gt;y, inputs.yg2.addr, opsz); } else { sx_pk_write_curve_gen(pkreq.req, curve, inputs.xg2, inputs.yg2); }  SX_PK_RUN(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title30" id="finish-asynchronous-non-blocking-ec-j-pake-proof-verification"><h1 class="title topictitle1" id="ariaid-title30" style="">Finish asynchronous (non-blocking) EC J-PAKE proof verification.</h1><div class="body"><p class="p">Finishes the EC J-PAKE proof verification  and releases the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title31" id="parameters-17"><h2 class="title topictitle2" id="ariaid-title31" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation static inline void sx_ecjpake_verify_zkp_end( sx_pk_accel req ) { sx_pk_release_req(req); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title32" id="synchronous-ec-j-pake-proof-verification"><h1 class="title topictitle1" id="ariaid-title32" style="">Synchronous EC J-PAKE proof verification</h1><div class="body"><p class="p">Start an EC J-PAKE proof verification operation on the accelerator  and return immediately.   The proof verification has the following steps:  1. ( (G r) + (X h) ) ?= V   In case of a comparison failure SX_ERR_INVALID_SIGNATURE shall  be returned.   @remark When the operation finishes on the accelerator,  call sx_ecjpake_verify_zkp_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title33" id="parameters-18"><h2 class="title topictitle2" id="ariaid-title33" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title34" id="parameters-19"><h2 class="title topictitle2" id="ariaid-title34" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> v Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title35" id="parameters-20"><h2 class="title topictitle2" id="ariaid-title35" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title36" id="parameters-21"><h2 class="title topictitle2" id="ariaid-title36" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> r Proof to be verified</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title37" id="parameters-22"><h2 class="title topictitle2" id="ariaid-title37" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> h Hash digest</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title38" id="parameters-23"><h2 class="title topictitle2" id="ariaid-title38" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> g Point on the curve (Optional, pass SX_PT_CURVE_GENERATOR to use  the curve generator point)   Truncation or padding should be done by user application   @return ::SX_OK  @return ::SX_ERR_INVALID_SIGNATURE  @return ::SX_ERR_OUT_OF_RANGE  @return ::SX_ERR_POINT_NOT_ON_CURVE  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_ecjpake_verify_zkp_go(), sx_async_ecjpake_verify_zkp_end() for  an asynchronous version static inline int sx_ecjpake_verify_zkp( const struct sx_pk_ecurve curve, const struct sx_pk_point v, const struct sx_pk_point x, const sx_op r, const sx_op h, const struct sx_pk_point g ) { uint32_t status; struct sx_pk_dreq pkreq;  pkreq = sx_ecjpake_verify_zkp_go(curve, v, x, r, h, g); if (pkreq.status) return pkreq.status;  status = sx_pk_wait(pkreq.req);  sx_ecjpake_verify_zkp_end(pkreq.req);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title39" id="asynchronous-ec-j-pake-3-point-addition"><h1 class="title topictitle1" id="ariaid-title39" style="">Asynchronous EC J-PAKE 3 point addition</h1><div class="body"><p class="p">Start a EC J-PAKE 3 point addition operation on the accelerator  and return immediately.   @remark When the operation finishes on the accelerator,  call sx_ecjpake_3pt_add_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title40" id="parameters-24"><h2 class="title topictitle2" id="ariaid-title40" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title41" id="parameters-25"><h2 class="title topictitle2" id="ariaid-title41" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> a Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title42" id="parameters-26"><h2 class="title topictitle2" id="ariaid-title42" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title43" id="parameters-27"><h2 class="title topictitle2" id="ariaid-title43" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> c Point on the curve   Truncation or padding should be done by user application   @return Acquired acceleration request for this operation  static inline struct sx_pk_dreq sx_ecjpake_3pt_add_go( const struct sx_pk_ecurve curve, const struct sx_pk_point a, const struct sx_pk_point b, const struct sx_pk_point c) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_3pt_add inputs;  pkreq = sx_pk_acquire_req(curve-&gt;cnx, SX_PK_CMD_ECJPAKE_3PT_ADD); if (pkreq.status) return pkreq;  pkreq.status = sx_pk_list_ecc_inslots(pkreq.req, curve, 0, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq;  int opsz = sx_pk_get_opsize(pkreq.req);  sx_pk_op2mem(b-&gt;x, inputs.x2_1.addr, opsz); sx_pk_op2mem(b-&gt;y, inputs.x2_2.addr, opsz); sx_pk_op2mem(c-&gt;x, inputs.x3_1.addr, opsz); sx_pk_op2mem(c-&gt;y, inputs.x3_2.addr, opsz); sx_pk_op2mem(a-&gt;x, inputs.x1_1.addr, opsz); sx_pk_op2mem(a-&gt;y, inputs.x1_2.addr, opsz);  sx_pk_run(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title44" id="finish-asynchronous-non-blocking-ec-j-pake-3-point-addition"><h1 class="title topictitle1" id="ariaid-title44" style="">Finish asynchronous (non-blocking) EC J-PAKE 3 point addition.</h1><div class="body"><p class="p">Finishes the EC J-PAKE 3 point addition  and releases the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title45" id="parameters-28"><h2 class="title topictitle2" id="ariaid-title45" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title46" id="parameters-29"><h2 class="title topictitle2" id="ariaid-title46" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> gb The addition result static inline void sx_ecjpake_3pt_add_end( sx_pk_accel req, struct sx_pk_point gb ) { sx_async_finish_pair(req, gb-&gt;x, gb-&gt;y); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title47" id="synchronous-ec-j-pake-3-point-addition"><h1 class="title topictitle1" id="ariaid-title47" style="">Synchronous EC J-PAKE 3 point addition</h1><div class="body"><p class="p">Start a EC J-PAKE 3 point addition operation on the accelerator  and return immediately.   The 3 point addition operation has the following steps:  1. gb = a + b + c   @remark When the operation finishes on the accelerator,  call sx_ecjpake_3pt_add_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title48" id="parameters-30"><h2 class="title topictitle2" id="ariaid-title48" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title49" id="parameters-31"><h2 class="title topictitle2" id="ariaid-title49" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> a Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title50" id="parameters-32"><h2 class="title topictitle2" id="ariaid-title50" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title51" id="parameters-33"><h2 class="title topictitle2" id="ariaid-title51" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> c Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title52" id="parameters-34"><h2 class="title topictitle2" id="ariaid-title52" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> gb The addition result   Truncation or padding should be done by user application   @return ::SX_OK  @return ::SX_ERR_INVALID_SIGNATURE  @return ::SX_ERR_OUT_OF_RANGE  @return ::SX_ERR_POINT_NOT_ON_CURVE  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_ecjpake_verify_zkp_go(), sx_async_ecjpake_verify_zkp_end() for  an asynchronous version static inline int sx_ecjpake_3pt_add( const struct sx_pk_ecurve curve, const struct sx_pk_point a, const struct sx_pk_point b, const struct sx_pk_point c, struct sx_pk_point gb ) { uint32_t status; struct sx_pk_dreq pkreq;  pkreq = sx_ecjpake_3pt_add_go(curve, a,b,c); if (pkreq.status) return pkreq.status;  status = sx_pk_wait(pkreq.req);  sx_ecjpake_3pt_add_end(pkreq.req, gb);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title53" id="asynchronous-ec-j-pake-session-key-generation"><h1 class="title topictitle1" id="ariaid-title53" style="">Asynchronous EC J-PAKE session key generation</h1><div class="body"><p class="p">Start a EC J-PAKE session key generation operation on  the accelerator and return immediately.   @remark When the operation finishes on the accelerator,  call sx_ecjpake_gen_sess_key_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title54" id="parameters-35"><h2 class="title topictitle2" id="ariaid-title54" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title55" id="parameters-36"><h2 class="title topictitle2" id="ariaid-title55" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x4 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title56" id="parameters-37"><h2 class="title topictitle2" id="ariaid-title56" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title57" id="parameters-38"><h2 class="title topictitle2" id="ariaid-title57" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x2 Generated random number</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title58" id="parameters-39"><h2 class="title topictitle2" id="ariaid-title58" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x2s (x2 s) % n <span class="xref"></span>   Truncation or padding should be done by user application   @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_gen_sess_key_go( const struct sx_pk_ecurve curve, const struct sx_pk_point x4, const struct sx_pk_point b, const sx_op x2, const sx_op x2s) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_gen_sess_key inputs;  pkreq = sx_pk_acquire_req(curve-&gt;cnx, SX_PK_CMD_ECJPAKE_GEN_SESS_KEY); if (pkreq.status) return pkreq;  pkreq.status = sx_pk_list_ecc_inslots(pkreq.req, curve, 0, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq;  int opsz = sx_pk_get_opsize(pkreq.req);  sx_pk_op2mem(x4-&gt;x, inputs.x4_1.addr, opsz); sx_pk_op2mem(x4-&gt;y, inputs.x4_2.addr, opsz); sx_pk_op2mem(b-&gt;x, inputs.b_1.addr, opsz); sx_pk_op2mem(b-&gt;y, inputs.b_2.addr, opsz); sx_pk_op2mem(x2, inputs.x2.addr, opsz); sx_pk_op2mem(x2s, inputs.x2s.addr, opsz);  sx_pk_run(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title59" id="finish-asynchronous-non-blocking-ec-j-pake-session-key-generation"><h1 class="title topictitle1" id="ariaid-title59" style="">Finish asynchronous (non-blocking) EC J-PAKE session key generation</h1><div class="body"><p class="p">Finishes the EC J-PAKE session key generation operation  and releases the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title60" id="parameters-40"><h2 class="title topictitle2" id="ariaid-title60" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title61" id="parameters-41"><h2 class="title topictitle2" id="ariaid-title61" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> t The result static inline void sx_ecjpake_gen_sess_key_end( sx_pk_accel req, struct sx_pk_point t) { sx_async_finish_pair(req, t-&gt;x, t-&gt;y); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title62" id="synchronous-ec-j-pake-session-key-generation"><h1 class="title topictitle1" id="ariaid-title62" style="">Synchronous EC J-PAKE session key generation</h1><div class="body"><p class="p">Start a EC J-PAKE session key generation operation on the accelerator  and return immediately.   The session key generation has the following steps: | Param | Description |
|:----- |:----------- |</p>
<p class="p">| 1. T = (b | (x4 x2s)) x2   @remark When the operation finishes on the accelerator,  call sx_ecjpake_gen_sess_key_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title63" id="parameters-42"><h2 class="title topictitle2" id="ariaid-title63" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title64" id="parameters-43"><h2 class="title topictitle2" id="ariaid-title64" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x4 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title65" id="parameters-44"><h2 class="title topictitle2" id="ariaid-title65" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> b Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title66" id="parameters-45"><h2 class="title topictitle2" id="ariaid-title66" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x2 Generated random number</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title67" id="parameters-46"><h2 class="title topictitle2" id="ariaid-title67" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x2s x2 password</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title68" id="parameters-47"><h2 class="title topictitle2" id="ariaid-title68" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> t result   Truncation or padding should be done by user application   @return ::SX_OK  @return ::SX_ERR_INVALID_SIGNATURE  @return ::SX_ERR_OUT_OF_RANGE  @return ::SX_ERR_POINT_NOT_ON_CURVE  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_ecjpake_gen_sess_key_go(), sx_async_ecjpake_gen_sess_key_end() for  an asynchronous version static inline int sx_ecjpake_gen_sess_key( const struct sx_pk_ecurve curve, const struct sx_pk_point x4, const struct sx_pk_point b, const sx_op x2, const sx_op x2s, struct sx_pk_point t ) { uint32_t status; struct sx_pk_dreq pkreq;  pkreq = sx_ecjpake_gen_sess_key_go(curve, x4, b, x2, x2s); if (pkreq.status) return pkreq.status;  status = sx_pk_wait(pkreq.req);  sx_ecjpake_gen_sess_key_end(pkreq.req, t);  return status; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title69" id="asynchronous-ec-j-pake-step-2-calculation"><h1 class="title topictitle1" id="ariaid-title69" style="">Asynchronous EC J-PAKE step 2 calculation</h1><div class="body"><p class="p">Start an EC J-PAKE step 2 calculation operation on  the accelerator and return immediately.   @remark When the operation finishes on the accelerator,  call sx_ecjpake_gen_step_2_end()</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title70" id="parameters-48"><h2 class="title topictitle2" id="ariaid-title70" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title71" id="parameters-49"><h2 class="title topictitle2" id="ariaid-title71" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x4 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title72" id="parameters-50"><h2 class="title topictitle2" id="ariaid-title72" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x3 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title73" id="parameters-51"><h2 class="title topictitle2" id="ariaid-title73" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x1 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title74" id="parameters-52"><h2 class="title topictitle2" id="ariaid-title74" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x2s (x2 s) % n <span class="xref"></span></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title75" id="parameters-53"><h2 class="title topictitle2" id="ariaid-title75" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> s password   Truncation or padding should be done by user application   @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_gen_step_2_go( const struct sx_pk_ecurve curve, const struct sx_pk_point x4, const struct sx_pk_point x3, const struct sx_pk_point x1, const sx_op x2s, const sx_op s) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_gen_step_2 inputs;  pkreq = sx_pk_acquire_req(curve-&gt;cnx, SX_PK_CMD_ECJPAKE_GEN_STEP_2); if (pkreq.status) return pkreq;  pkreq.status = sx_pk_list_ecc_inslots(pkreq.req, curve, 0, (struct sx_pk_slot )&amp;inputs); if (pkreq.status) return pkreq;  int opsz = sx_pk_get_opsize(pkreq.req);  sx_pk_op2mem(x4-&gt;x, inputs.x4_1.addr, opsz); sx_pk_op2mem(x4-&gt;y, inputs.x4_2.addr, opsz); sx_pk_op2mem(x3-&gt;x, inputs.x3_1.addr, opsz); sx_pk_op2mem(x3-&gt;y, inputs.x3_2.addr, opsz); sx_pk_op2mem(x1-&gt;x, inputs.x1_1.addr, opsz); sx_pk_op2mem(x1-&gt;y, inputs.x1_2.addr, opsz); sx_pk_op2mem(x2s, inputs.x2s.addr, opsz); sx_pk_op2mem(s, inputs.s.addr, opsz);  sx_pk_run(pkreq.req);  return pkreq; }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title76" id="finish-an-asynchronous-non-blocking-ec-j-pake-step-2-calculation"><h1 class="title topictitle1" id="ariaid-title76" style="">Finish an asynchronous (non-blocking) EC J-PAKE step 2 calculation</h1><div class="body"><p class="p">Finishes the EC J-PAKE step 2 calculation operation  and releases the reserved resources.   @pre The operation on the accelerator must be finished before  calling this function.</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title77" id="parameters-54"><h2 class="title topictitle2" id="ariaid-title77" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> req The previously acquired acceleration  request for this operation</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title78" id="parameters-55"><h2 class="title topictitle2" id="ariaid-title78" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> a Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title79" id="parameters-56"><h2 class="title topictitle2" id="ariaid-title79" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x2s Generated random password</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title80" id="parameters-57"><h2 class="title topictitle2" id="ariaid-title80" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> ga Point on the curve static inline void sx_ecjpake_gen_step_2_end( sx_pk_accel req, struct sx_pk_point a, sx_op x2s, struct sx_pk_point ga) { sx_op results<span class="xref"></span> = { a-&gt;x, a-&gt;y, x2s, ga-&gt;x, ga-&gt;y };  sx_async_finish_any(req, results, 5); }</p>
</div>
</div>
</div>
<div class="topic nested0" aria-labelledby="ariaid-title81" id="synchronous-ec-j-pake-step-2-calculation"><h1 class="title topictitle1" id="ariaid-title81" style="">Synchronous EC J-PAKE step 2 calculation</h1><div class="body"><p class="p">Start an EC J-PAKE step 2 calculation operation on the accelerator  and return immediately.   The step 2 calculation has the following steps:  1. ga = x1 + x3 + x4  2. rx2s = (x2s s) % curve.n  3. a = ga rx2s</p>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title82" id="parameters-58"><h2 class="title topictitle2" id="ariaid-title82" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> curve Elliptic curve on which to perform the operation.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title83" id="parameters-59"><h2 class="title topictitle2" id="ariaid-title83" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x4 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title84" id="parameters-60"><h2 class="title topictitle2" id="ariaid-title84" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x3 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title85" id="parameters-61"><h2 class="title topictitle2" id="ariaid-title85" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x1 Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title86" id="parameters-62"><h2 class="title topictitle2" id="ariaid-title86" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> x2s Generated random password</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title87" id="parameters-63"><h2 class="title topictitle2" id="ariaid-title87" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> s Password</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title88" id="parameters-64"><h2 class="title topictitle2" id="ariaid-title88" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> a Point on the curve</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title89" id="parameters-65"><h2 class="title topictitle2" id="ariaid-title89" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> rx2s Generated random password</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title90" id="parameters-66"><h2 class="title topictitle2" id="ariaid-title90" style="">Parameters</h2><div class="body"><p class="p"><span class="xref"></span> ga Point on the curve   Truncation or padding should be done by user application   @return ::SX_OK  @return ::SX_ERR_INVALID_SIGNATURE  @return ::SX_ERR_OUT_OF_RANGE  @return ::SX_ERR_POINT_NOT_ON_CURVE  @return ::SX_ERR_NOT_INVERTIBLE  @return ::SX_ERR_UNKNOWN_ERROR  @return ::SX_ERR_BUSY  @return ::SX_ERR_NOT_IMPLEMENTED  @return ::SX_ERR_OPERAND_TOO_LARGE  @return ::SX_ERR_PLATFORM_ERROR  @return ::SX_ERR_EXPIRED   @see sx_async_ecjpake_gen_step_2_go(), sx_async_ecjpake_gen_step_2_end() for  an asynchronous version static inline int sx_ecjpake_gen_step_2( const struct sx_pk_ecurve curve, const struct sx_pk_point x4, const struct sx_pk_point x3, const struct sx_pk_point x1, const sx_op x2s, const sx_op s, struct sx_pk_point a, sx_op rx2s, struct sx_pk_point ga ) { uint32_t status; struct sx_pk_dreq pkreq;  pkreq = sx_ecjpake_gen_step_2_go(curve, x4, x3, x1, x2s, s); if (pkreq.status) return pkreq.status;  status = sx_pk_wait(pkreq.req);  sx_ecjpake_gen_step_2_end(pkreq.req, a, rx2s, ga);  return status; }}</p>
</div>
</div>
</div>
</body>
</html>
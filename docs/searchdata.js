var SearchFiles = ["GUID-B92D56E1-C216-4D2D-827C-26D5B803B704.html","GUID-FFC9758F-305D-4A4A-A577-726CDCFA18C7.html","GUID-2167300F-6A96-440E-83CA-FC9C0C259914.html","GUID-F94F11C2-B9C2-46CA-873A-7F3BA47C12F9.html","GUID-EDAF833A-65A8-4C17-8178-AB52010F5638.html","GUID-62C7BAFF-836C-4CE5-9489-B549665C44AC.html",
							"GUID-62C7BAFF-836C-4CE5-9489-B549665C44AC.html",
							"GUID-62C7BAFF-836C-4CE5-9489-B549665C44AC.html",
							"GUID-B4147259-E267-4C02-B584-20569616762B.html",
							"GUID-B4147259-E267-4C02-B584-20569616762B.html",
							"GUID-B4147259-E267-4C02-B584-20569616762B.html",
							"GUID-B4147259-E267-4C02-B584-20569616762B.html",
							"GUID-B4147259-E267-4C02-B584-20569616762B.html",
							"GUID-F9DDA02A-03F1-4A86-8A4B-9B5067BDF410.html",
							"GUID-F9DDA02A-03F1-4A86-8A4B-9B5067BDF410.html",
							"GUID-F9DDA02A-03F1-4A86-8A4B-9B5067BDF410.html",
							"GUID-F9DDA02A-03F1-4A86-8A4B-9B5067BDF410.html",
							"GUID-F9DDA02A-03F1-4A86-8A4B-9B5067BDF410.html",
							"GUID-D20B7B50-5211-4F70-BA93-38F5AFB937FE.html",
							"GUID-D20B7B50-5211-4F70-BA93-38F5AFB937FE.html",
							"GUID-D20B7B50-5211-4F70-BA93-38F5AFB937FE.html",
							"GUID-D20B7B50-5211-4F70-BA93-38F5AFB937FE.html",
							"GUID-D20B7B50-5211-4F70-BA93-38F5AFB937FE.html",
							"GUID-5295302D-44C9-46D6-9AC9-A8EC8BD8D061.html",
							"GUID-5295302D-44C9-46D6-9AC9-A8EC8BD8D061.html",
							"GUID-5295302D-44C9-46D6-9AC9-A8EC8BD8D061.html",
							"GUID-5295302D-44C9-46D6-9AC9-A8EC8BD8D061.html",
							"GUID-5295302D-44C9-46D6-9AC9-A8EC8BD8D061.html",
							"GUID-3610DABE-8B2A-4194-ADE9-BECF2971F8B4.html",
							"GUID-3610DABE-8B2A-4194-ADE9-BECF2971F8B4.html",
							"GUID-3610DABE-8B2A-4194-ADE9-BECF2971F8B4.html",
							"GUID-3610DABE-8B2A-4194-ADE9-BECF2971F8B4.html",
							"GUID-3610DABE-8B2A-4194-ADE9-BECF2971F8B4.html",
							"GUID-AF6A889B-746F-4F65-8D41-DD8A4B8FCE9C.html",
							"GUID-AF6A889B-746F-4F65-8D41-DD8A4B8FCE9C.html",
							"GUID-AF6A889B-746F-4F65-8D41-DD8A4B8FCE9C.html",
							"GUID-AF6A889B-746F-4F65-8D41-DD8A4B8FCE9C.html",
							"GUID-AF6A889B-746F-4F65-8D41-DD8A4B8FCE9C.html",
							"GUID-4F3FCED2-8D39-4756-838A-1248B8A619A4.html","GUID-B5DC2BA6-61E5-4CF6-B9E9-C5D669141F71.html",
							"GUID-B5DC2BA6-61E5-4CF6-B9E9-C5D669141F71.html",
							"GUID-B5DC2BA6-61E5-4CF6-B9E9-C5D669141F71.html",
							"GUID-27985E91-E0D2-4FA3-8BF8-BA82656F9C77.html",
							"GUID-27985E91-E0D2-4FA3-8BF8-BA82656F9C77.html",
							"GUID-27985E91-E0D2-4FA3-8BF8-BA82656F9C77.html",
							"GUID-27985E91-E0D2-4FA3-8BF8-BA82656F9C77.html",
							"GUID-27985E91-E0D2-4FA3-8BF8-BA82656F9C77.html",
							"GUID-8793536C-F38F-43EA-A057-DE3BA9715EB9.html",
							"GUID-8793536C-F38F-43EA-A057-DE3BA9715EB9.html",
							"GUID-8793536C-F38F-43EA-A057-DE3BA9715EB9.html",
							"GUID-8793536C-F38F-43EA-A057-DE3BA9715EB9.html",
							"GUID-8793536C-F38F-43EA-A057-DE3BA9715EB9.html",
							"GUID-B7BACAEC-0E3B-473A-8B3D-346E615C76C2.html",
							"GUID-B7BACAEC-0E3B-473A-8B3D-346E615C76C2.html",
							"GUID-B7BACAEC-0E3B-473A-8B3D-346E615C76C2.html",
							"GUID-B7BACAEC-0E3B-473A-8B3D-346E615C76C2.html",
							"GUID-B7BACAEC-0E3B-473A-8B3D-346E615C76C2.html",
							"GUID-96F08F37-E558-49D3-9B97-9A086896263A.html","GUID-8DFEF195-91C1-4E48-B28E-100B98852F65.html",
							"GUID-8DFEF195-91C1-4E48-B28E-100B98852F65.html",
							"GUID-8DFEF195-91C1-4E48-B28E-100B98852F65.html",
							"GUID-8DFEF195-91C1-4E48-B28E-100B98852F65.html",
							"GUID-8DFEF195-91C1-4E48-B28E-100B98852F65.html",
							"GUID-76DB3E5C-3201-4663-937C-92CC87FC1608.html",
							"GUID-76DB3E5C-3201-4663-937C-92CC87FC1608.html",
							"GUID-76DB3E5C-3201-4663-937C-92CC87FC1608.html",
							"GUID-76DB3E5C-3201-4663-937C-92CC87FC1608.html",
							"GUID-76DB3E5C-3201-4663-937C-92CC87FC1608.html",
							"GUID-AFA1DA29-4E94-4EA3-8C98-D7181ED0C312.html",
							"GUID-AFA1DA29-4E94-4EA3-8C98-D7181ED0C312.html",
							"GUID-AFA1DA29-4E94-4EA3-8C98-D7181ED0C312.html",
							"GUID-AFA1DA29-4E94-4EA3-8C98-D7181ED0C312.html",
							"GUID-AFA1DA29-4E94-4EA3-8C98-D7181ED0C312.html",
							"GUID-1FC8FBC1-9083-451F-98AE-88094CA864C6.html",
							"GUID-1FC8FBC1-9083-451F-98AE-88094CA864C6.html",
							"GUID-1FC8FBC1-9083-451F-98AE-88094CA864C6.html",
							"GUID-1FC8FBC1-9083-451F-98AE-88094CA864C6.html",
							"GUID-1FC8FBC1-9083-451F-98AE-88094CA864C6.html",
							"GUID-B30A3A3B-5B44-4F2E-9C0E-11781DD07EC8.html",
							"GUID-B30A3A3B-5B44-4F2E-9C0E-11781DD07EC8.html",
							"GUID-B30A3A3B-5B44-4F2E-9C0E-11781DD07EC8.html",
							"GUID-B30A3A3B-5B44-4F2E-9C0E-11781DD07EC8.html",
							"GUID-B30A3A3B-5B44-4F2E-9C0E-11781DD07EC8.html",
							"GUID-D72A7B04-3F6E-408A-ADBF-AC894D945D65.html",
							"GUID-D72A7B04-3F6E-408A-ADBF-AC894D945D65.html",
							"GUID-D72A7B04-3F6E-408A-ADBF-AC894D945D65.html",
							"GUID-D72A7B04-3F6E-408A-ADBF-AC894D945D65.html",
							"GUID-D72A7B04-3F6E-408A-ADBF-AC894D945D65.html",
							"GUID-435A3048-D734-4711-9B4A-8E7035AE4747.html",
							"GUID-435A3048-D734-4711-9B4A-8E7035AE4747.html",
							"GUID-435A3048-D734-4711-9B4A-8E7035AE4747.html",
							"GUID-435A3048-D734-4711-9B4A-8E7035AE4747.html",
							"GUID-435A3048-D734-4711-9B4A-8E7035AE4747.html",
							"GUID-BBF940E8-361C-4418-AA6E-7E55FE94DD87.html","GUID-141C5854-2A82-4DAF-ACA3-C94E8C1DBE17.html",
							"GUID-141C5854-2A82-4DAF-ACA3-C94E8C1DBE17.html",
							"GUID-141C5854-2A82-4DAF-ACA3-C94E8C1DBE17.html",
							"GUID-141C5854-2A82-4DAF-ACA3-C94E8C1DBE17.html",
							"GUID-141C5854-2A82-4DAF-ACA3-C94E8C1DBE17.html",
							"GUID-1BFC4F0D-3A6E-46C0-906B-ED0B302A24A3.html",
							"GUID-1BFC4F0D-3A6E-46C0-906B-ED0B302A24A3.html",
							"GUID-1BFC4F0D-3A6E-46C0-906B-ED0B302A24A3.html",
							"GUID-1BFC4F0D-3A6E-46C0-906B-ED0B302A24A3.html",
							"GUID-1BFC4F0D-3A6E-46C0-906B-ED0B302A24A3.html",
							"GUID-1882683B-DF14-4770-9FE0-4B533354E919.html",
							"GUID-1882683B-DF14-4770-9FE0-4B533354E919.html",
							"GUID-1882683B-DF14-4770-9FE0-4B533354E919.html",
							"GUID-1882683B-DF14-4770-9FE0-4B533354E919.html",
							"GUID-1882683B-DF14-4770-9FE0-4B533354E919.html",
							"GUID-1BBFA501-F854-4426-8EB9-91B8DD825F97.html",
							"GUID-1BBFA501-F854-4426-8EB9-91B8DD825F97.html",
							"GUID-1BBFA501-F854-4426-8EB9-91B8DD825F97.html",
							"GUID-1BBFA501-F854-4426-8EB9-91B8DD825F97.html",
							"GUID-1BBFA501-F854-4426-8EB9-91B8DD825F97.html",
							"GUID-4F655CBC-2139-4E8C-89A0-5BEF04905FD5.html",
							"GUID-4F655CBC-2139-4E8C-89A0-5BEF04905FD5.html",
							"GUID-4F655CBC-2139-4E8C-89A0-5BEF04905FD5.html",
							"GUID-4F655CBC-2139-4E8C-89A0-5BEF04905FD5.html",
							"GUID-4F655CBC-2139-4E8C-89A0-5BEF04905FD5.html",
							"GUID-C54B3EAC-9FFD-458A-8EA2-388E22D8D258.html",
							"GUID-C54B3EAC-9FFD-458A-8EA2-388E22D8D258.html",
							"GUID-C54B3EAC-9FFD-458A-8EA2-388E22D8D258.html",
							"GUID-C54B3EAC-9FFD-458A-8EA2-388E22D8D258.html",
							"GUID-C54B3EAC-9FFD-458A-8EA2-388E22D8D258.html",
							"GUID-962BEC24-6270-4306-8596-236BD157D012.html",
							"GUID-962BEC24-6270-4306-8596-236BD157D012.html",
							"GUID-962BEC24-6270-4306-8596-236BD157D012.html",
							"GUID-962BEC24-6270-4306-8596-236BD157D012.html",
							"GUID-962BEC24-6270-4306-8596-236BD157D012.html",
							"GUID-F7E76DD2-FA51-4CD8-85E8-C41535248CF7.html",
							"GUID-F7E76DD2-FA51-4CD8-85E8-C41535248CF7.html",
							"GUID-F7E76DD2-FA51-4CD8-85E8-C41535248CF7.html",
							"GUID-F7E76DD2-FA51-4CD8-85E8-C41535248CF7.html",
							"GUID-F7E76DD2-FA51-4CD8-85E8-C41535248CF7.html",
							"GUID-477715F1-02E9-4506-B5E1-9F6E8CD53216.html",
							"GUID-477715F1-02E9-4506-B5E1-9F6E8CD53216.html",
							"GUID-477715F1-02E9-4506-B5E1-9F6E8CD53216.html",
							"GUID-477715F1-02E9-4506-B5E1-9F6E8CD53216.html",
							"GUID-477715F1-02E9-4506-B5E1-9F6E8CD53216.html",
							"GUID-277660E0-3BEF-465B-B8F4-B0E72E042EB6.html","GUID-4F0A69F2-47CB-4CDE-BBBB-020E3AD7A253.html",
							"GUID-4F0A69F2-47CB-4CDE-BBBB-020E3AD7A253.html",
							"GUID-4F0A69F2-47CB-4CDE-BBBB-020E3AD7A253.html",
							"GUID-4F0A69F2-47CB-4CDE-BBBB-020E3AD7A253.html",
							"GUID-4F0A69F2-47CB-4CDE-BBBB-020E3AD7A253.html",
							"GUID-09C83FD0-D18A-409C-89DF-0CDD7BA43CE0.html",
							"GUID-09C83FD0-D18A-409C-89DF-0CDD7BA43CE0.html",
							"GUID-09C83FD0-D18A-409C-89DF-0CDD7BA43CE0.html",
							"GUID-09C83FD0-D18A-409C-89DF-0CDD7BA43CE0.html",
							"GUID-09C83FD0-D18A-409C-89DF-0CDD7BA43CE0.html",
							"GUID-33766664-0429-477C-A59C-455948678305.html",
							"GUID-33766664-0429-477C-A59C-455948678305.html",
							"GUID-33766664-0429-477C-A59C-455948678305.html",
							"GUID-33766664-0429-477C-A59C-455948678305.html",
							"GUID-33766664-0429-477C-A59C-455948678305.html",
							"GUID-33766664-0429-477C-A59C-455948678305.html",
							"GUID-CF8AC400-857E-4BB4-87A4-147B8CE59C98.html",
							"GUID-CF8AC400-857E-4BB4-87A4-147B8CE59C98.html",
							"GUID-CF8AC400-857E-4BB4-87A4-147B8CE59C98.html",
							"GUID-CF8AC400-857E-4BB4-87A4-147B8CE59C98.html",
							"GUID-CF8AC400-857E-4BB4-87A4-147B8CE59C98.html",
							"GUID-CF8AC400-857E-4BB4-87A4-147B8CE59C98.html",
							"GUID-CF8AC400-857E-4BB4-87A4-147B8CE59C98.html",
							"GUID-5B276649-6DC6-4941-BF77-079C72DEF916.html",
							"GUID-5B276649-6DC6-4941-BF77-079C72DEF916.html",
							"GUID-5B276649-6DC6-4941-BF77-079C72DEF916.html",
							"GUID-79402B38-EB29-45A2-B098-9C8D8FD5405D.html",
							"GUID-79402B38-EB29-45A2-B098-9C8D8FD5405D.html",
							"GUID-79402B38-EB29-45A2-B098-9C8D8FD5405D.html",
							"GUID-79402B38-EB29-45A2-B098-9C8D8FD5405D.html",
							"GUID-79402B38-EB29-45A2-B098-9C8D8FD5405D.html",
							"GUID-A96B50BD-73CC-4162-A6FB-AECC8A95FE5B.html",
							"GUID-A96B50BD-73CC-4162-A6FB-AECC8A95FE5B.html",
							"GUID-A96B50BD-73CC-4162-A6FB-AECC8A95FE5B.html",
							"GUID-A96B50BD-73CC-4162-A6FB-AECC8A95FE5B.html",
							"GUID-A96B50BD-73CC-4162-A6FB-AECC8A95FE5B.html",
							"GUID-9F5447FF-EF42-4AC4-ADCF-1C0C2E5173CE.html","GUID-A760B515-B9F4-4861-A9EB-FD80AAE94F30.html",
							"GUID-A760B515-B9F4-4861-A9EB-FD80AAE94F30.html",
							"GUID-A760B515-B9F4-4861-A9EB-FD80AAE94F30.html",
							"GUID-A760B515-B9F4-4861-A9EB-FD80AAE94F30.html",
							"GUID-A760B515-B9F4-4861-A9EB-FD80AAE94F30.html",
							"GUID-92FB9B7E-F107-4994-8429-FFABC896EAF4.html",
							"GUID-92FB9B7E-F107-4994-8429-FFABC896EAF4.html",
							"GUID-92FB9B7E-F107-4994-8429-FFABC896EAF4.html",
							"GUID-92FB9B7E-F107-4994-8429-FFABC896EAF4.html",
							"GUID-92FB9B7E-F107-4994-8429-FFABC896EAF4.html",
							"GUID-3944574B-BC67-49E4-BFFF-A0E5EB7CF533.html",
							"GUID-3944574B-BC67-49E4-BFFF-A0E5EB7CF533.html",
							"GUID-3944574B-BC67-49E4-BFFF-A0E5EB7CF533.html",
							"GUID-3944574B-BC67-49E4-BFFF-A0E5EB7CF533.html",
							"GUID-3944574B-BC67-49E4-BFFF-A0E5EB7CF533.html",
							"GUID-1CB186D5-ECE4-41BE-BADE-FC0E1577DF44.html",
							"GUID-1CB186D5-ECE4-41BE-BADE-FC0E1577DF44.html",
							"GUID-1CB186D5-ECE4-41BE-BADE-FC0E1577DF44.html",
							"GUID-1CB186D5-ECE4-41BE-BADE-FC0E1577DF44.html",
							"GUID-1CB186D5-ECE4-41BE-BADE-FC0E1577DF44.html",
							"GUID-03312605-BBAE-4465-A49A-8338257CF202.html",
							"GUID-03312605-BBAE-4465-A49A-8338257CF202.html",
							"GUID-03312605-BBAE-4465-A49A-8338257CF202.html",
							"GUID-03312605-BBAE-4465-A49A-8338257CF202.html",
							"GUID-03312605-BBAE-4465-A49A-8338257CF202.html",
							"GUID-A48E118B-6776-4205-A185-1158D6876D4D.html",
							"GUID-A48E118B-6776-4205-A185-1158D6876D4D.html",
							"GUID-A48E118B-6776-4205-A185-1158D6876D4D.html",
							"GUID-A48E118B-6776-4205-A185-1158D6876D4D.html",
							"GUID-A48E118B-6776-4205-A185-1158D6876D4D.html",
							"GUID-E99DC114-8F37-4C2F-A3C3-2FB637EEA751.html",
							"GUID-E99DC114-8F37-4C2F-A3C3-2FB637EEA751.html",
							"GUID-E99DC114-8F37-4C2F-A3C3-2FB637EEA751.html",
							"GUID-E99DC114-8F37-4C2F-A3C3-2FB637EEA751.html",
							"GUID-E99DC114-8F37-4C2F-A3C3-2FB637EEA751.html",
							"GUID-624ED883-90AD-42A6-B408-56CE812D1BF1.html",
							"GUID-624ED883-90AD-42A6-B408-56CE812D1BF1.html",
							"GUID-624ED883-90AD-42A6-B408-56CE812D1BF1.html",
							"GUID-624ED883-90AD-42A6-B408-56CE812D1BF1.html",
							"GUID-624ED883-90AD-42A6-B408-56CE812D1BF1.html",
							"GUID-B3D492FD-EE43-4E34-B7E0-43508DC5B865.html","GUID-CF31B9F8-A031-4CD3-B9D5-AAC7DF934186.html",
							"GUID-CF31B9F8-A031-4CD3-B9D5-AAC7DF934186.html",
							"GUID-CF31B9F8-A031-4CD3-B9D5-AAC7DF934186.html",
							"GUID-CF31B9F8-A031-4CD3-B9D5-AAC7DF934186.html",
							"GUID-CF31B9F8-A031-4CD3-B9D5-AAC7DF934186.html",
							"GUID-B9EBC7BE-F2C8-4492-9B22-48E9015F3B6E.html",
							"GUID-B9EBC7BE-F2C8-4492-9B22-48E9015F3B6E.html",
							"GUID-B9EBC7BE-F2C8-4492-9B22-48E9015F3B6E.html",
							"GUID-B9EBC7BE-F2C8-4492-9B22-48E9015F3B6E.html",
							"GUID-B9EBC7BE-F2C8-4492-9B22-48E9015F3B6E.html",
							"GUID-D08C61D1-8CD6-4D2F-B74D-E58784C9042B.html","GUID-A7B0958C-E476-48EA-9C30-DA83508CC577.html","GUID-183B334C-1BDF-4564-A870-F4C2BE978405.html",
							"GUID-183B334C-1BDF-4564-A870-F4C2BE978405.html",
							"GUID-183B334C-1BDF-4564-A870-F4C2BE978405.html",
							"GUID-D08972F4-21A8-4F0E-8273-03AC48C7F790.html",
							"GUID-D08972F4-21A8-4F0E-8273-03AC48C7F790.html",
							"GUID-D08972F4-21A8-4F0E-8273-03AC48C7F790.html",
							"GUID-7D9AC457-8781-4DAA-BEDB-6CA258BA5C59.html",
							"GUID-7D9AC457-8781-4DAA-BEDB-6CA258BA5C59.html",
							"GUID-7D9AC457-8781-4DAA-BEDB-6CA258BA5C59.html",
							"GUID-4B67B429-8AD1-401B-A4C5-E80B38261F31.html",
							"GUID-4B67B429-8AD1-401B-A4C5-E80B38261F31.html",
							"GUID-4B67B429-8AD1-401B-A4C5-E80B38261F31.html",
							"GUID-C51A10C8-084D-4BF8-A6F0-3EE59657C130.html",
							"GUID-C51A10C8-084D-4BF8-A6F0-3EE59657C130.html",
							"GUID-C51A10C8-084D-4BF8-A6F0-3EE59657C130.html",
							"GUID-D6B3AF6D-9520-47FA-AC15-AE93D53328FC.html",
							"GUID-D6B3AF6D-9520-47FA-AC15-AE93D53328FC.html",
							"GUID-D6B3AF6D-9520-47FA-AC15-AE93D53328FC.html",
							"GUID-C689652B-94C6-440A-90DC-152E945B54A1.html",
							"GUID-C689652B-94C6-440A-90DC-152E945B54A1.html",
							"GUID-C689652B-94C6-440A-90DC-152E945B54A1.html",
							"GUID-0FEC3EB2-1308-4A1C-B574-9559D9EC3D32.html",
							"GUID-0FEC3EB2-1308-4A1C-B574-9559D9EC3D32.html",
							"GUID-0FEC3EB2-1308-4A1C-B574-9559D9EC3D32.html",
							"GUID-C7436175-9555-4084-8CC2-D745C53F113C.html",
							"GUID-C7436175-9555-4084-8CC2-D745C53F113C.html",
							"GUID-C7436175-9555-4084-8CC2-D745C53F113C.html",
							"GUID-259CFA61-09A7-423C-8608-8494531680CC.html",
							"GUID-259CFA61-09A7-423C-8608-8494531680CC.html",
							"GUID-259CFA61-09A7-423C-8608-8494531680CC.html",
							"GUID-60770A63-E7A8-4C18-9B4D-1A78A64FAFC6.html",
							"GUID-60770A63-E7A8-4C18-9B4D-1A78A64FAFC6.html",
							"GUID-60770A63-E7A8-4C18-9B4D-1A78A64FAFC6.html",
							"GUID-133C54E9-8E07-4D8E-BDC4-289780F9AAF2.html",
							"GUID-133C54E9-8E07-4D8E-BDC4-289780F9AAF2.html",
							"GUID-133C54E9-8E07-4D8E-BDC4-289780F9AAF2.html",
							"GUID-E2612D52-C312-4265-8EE8-A9EA4B8DDDC7.html",
							"GUID-E2612D52-C312-4265-8EE8-A9EA4B8DDDC7.html",
							"GUID-E2612D52-C312-4265-8EE8-A9EA4B8DDDC7.html",
							"GUID-B0A065DE-8AA5-45D9-9564-74D2D6B2737A.html",
							"GUID-B0A065DE-8AA5-45D9-9564-74D2D6B2737A.html",
							"GUID-B0A065DE-8AA5-45D9-9564-74D2D6B2737A.html",
							"GUID-2A4A2013-6E0B-4723-ACFA-4F47F89002D0.html",
							"GUID-2A4A2013-6E0B-4723-ACFA-4F47F89002D0.html",
							"GUID-2A4A2013-6E0B-4723-ACFA-4F47F89002D0.html",
							"GUID-2A4A2013-6E0B-4723-ACFA-4F47F89002D0.html",
							"GUID-2A4A2013-6E0B-4723-ACFA-4F47F89002D0.html",
							"GUID-1F2868F0-CA59-47E2-80D0-16DF4E8A01CE.html",
							"GUID-1F2868F0-CA59-47E2-80D0-16DF4E8A01CE.html",
							"GUID-1F2868F0-CA59-47E2-80D0-16DF4E8A01CE.html",
							"GUID-1F2868F0-CA59-47E2-80D0-16DF4E8A01CE.html",
							"GUID-1F2868F0-CA59-47E2-80D0-16DF4E8A01CE.html",
							"GUID-8AADBB19-32FD-4C50-AE4F-482599F9D02F.html",
							"GUID-8AADBB19-32FD-4C50-AE4F-482599F9D02F.html",
							"GUID-8AADBB19-32FD-4C50-AE4F-482599F9D02F.html",
							"GUID-8AADBB19-32FD-4C50-AE4F-482599F9D02F.html",
							"GUID-8AADBB19-32FD-4C50-AE4F-482599F9D02F.html",
							"GUID-F1364A8C-3E96-429B-A880-609E7A704762.html",
							"GUID-F1364A8C-3E96-429B-A880-609E7A704762.html",
							"GUID-F1364A8C-3E96-429B-A880-609E7A704762.html",
							"GUID-F1364A8C-3E96-429B-A880-609E7A704762.html",
							"GUID-F1364A8C-3E96-429B-A880-609E7A704762.html",
							"GUID-C9597087-8DE9-4755-9D6A-C93DF62BD1E1.html",
							"GUID-C9597087-8DE9-4755-9D6A-C93DF62BD1E1.html",
							"GUID-C9597087-8DE9-4755-9D6A-C93DF62BD1E1.html",
							"GUID-C9597087-8DE9-4755-9D6A-C93DF62BD1E1.html",
							"GUID-C9597087-8DE9-4755-9D6A-C93DF62BD1E1.html",
							"GUID-AAC3B8D6-B77A-4883-BE1B-0EA0BE4872BC.html",
							"GUID-AAC3B8D6-B77A-4883-BE1B-0EA0BE4872BC.html",
							"GUID-AAC3B8D6-B77A-4883-BE1B-0EA0BE4872BC.html",
							"GUID-AAC3B8D6-B77A-4883-BE1B-0EA0BE4872BC.html",
							"GUID-AAC3B8D6-B77A-4883-BE1B-0EA0BE4872BC.html",
							"GUID-B1E12C3C-2987-4791-BA2A-54F90EB76C38.html",
							"GUID-B1E12C3C-2987-4791-BA2A-54F90EB76C38.html",
							"GUID-B1E12C3C-2987-4791-BA2A-54F90EB76C38.html",
							"GUID-B1E12C3C-2987-4791-BA2A-54F90EB76C38.html",
							"GUID-B1E12C3C-2987-4791-BA2A-54F90EB76C38.html",
							"GUID-C949561B-9512-4FF1-B590-1A41E6336777.html",
							"GUID-C949561B-9512-4FF1-B590-1A41E6336777.html",
							"GUID-C949561B-9512-4FF1-B590-1A41E6336777.html",
							"GUID-C949561B-9512-4FF1-B590-1A41E6336777.html",
							"GUID-C949561B-9512-4FF1-B590-1A41E6336777.html",
							"GUID-FCE3BB9C-EE95-44A0-AD6B-699B9CF1395B.html",
							"GUID-FCE3BB9C-EE95-44A0-AD6B-699B9CF1395B.html",
							"GUID-FCE3BB9C-EE95-44A0-AD6B-699B9CF1395B.html",
							"GUID-FCE3BB9C-EE95-44A0-AD6B-699B9CF1395B.html",
							"GUID-FCE3BB9C-EE95-44A0-AD6B-699B9CF1395B.html",
							"GUID-6F51DFED-F916-4803-8B8F-0A9286A08226.html",
							"GUID-6F51DFED-F916-4803-8B8F-0A9286A08226.html",
							"GUID-6F51DFED-F916-4803-8B8F-0A9286A08226.html",
							"GUID-6F51DFED-F916-4803-8B8F-0A9286A08226.html",
							"GUID-6F51DFED-F916-4803-8B8F-0A9286A08226.html",
							"GUID-7CAED737-9F28-458E-B9A3-1D20184705F0.html",
							"GUID-7CAED737-9F28-458E-B9A3-1D20184705F0.html",
							"GUID-7CAED737-9F28-458E-B9A3-1D20184705F0.html",
							"GUID-7CAED737-9F28-458E-B9A3-1D20184705F0.html",
							"GUID-7CAED737-9F28-458E-B9A3-1D20184705F0.html",
							"GUID-9FC50B7F-D694-4BE2-94AE-576D308FF56B.html",
							"GUID-9FC50B7F-D694-4BE2-94AE-576D308FF56B.html",
							"GUID-9FC50B7F-D694-4BE2-94AE-576D308FF56B.html",
							"GUID-9FC50B7F-D694-4BE2-94AE-576D308FF56B.html",
							"GUID-9FC50B7F-D694-4BE2-94AE-576D308FF56B.html",
							"GUID-5A8DBB18-071C-4159-87F2-E34ED758FCB1.html",
							"GUID-5A8DBB18-071C-4159-87F2-E34ED758FCB1.html",
							"GUID-5A8DBB18-071C-4159-87F2-E34ED758FCB1.html",
							"GUID-5A8DBB18-071C-4159-87F2-E34ED758FCB1.html",
							"GUID-E95D4418-FDD2-49A3-999F-6EFBA54DDA3D.html","GUID-A04B5B1F-202B-4944-B18F-13E4857CC3CD.html","GUID-4552A2E4-E35C-4FD0-9C01-0EE86D4F6163.html","GUID-079BEEAB-D3FE-415A-8EA6-F8A704302FCB.html","GUID-9B3F465C-7297-4547-B7C6-3AAABEB7E261.html","GUID-D80A0687-7882-4113-8AC1-DE50E569ECB3.html",
							"GUID-D80A0687-7882-4113-8AC1-DE50E569ECB3.html",
							"GUID-D80A0687-7882-4113-8AC1-DE50E569ECB3.html",
							"GUID-40B6BE17-6888-442C-B278-C7315CF29BB6.html",
							"GUID-40B6BE17-6888-442C-B278-C7315CF29BB6.html",
							"GUID-40B6BE17-6888-442C-B278-C7315CF29BB6.html",
							"GUID-4A279764-C14B-42E7-AE63-74FB5385A12A.html",
							"GUID-4A279764-C14B-42E7-AE63-74FB5385A12A.html",
							"GUID-4A279764-C14B-42E7-AE63-74FB5385A12A.html",
							"GUID-0B6BCA96-AD39-49A5-ADEE-70FADE4954CE.html",
							"GUID-0B6BCA96-AD39-49A5-ADEE-70FADE4954CE.html",
							"GUID-0B6BCA96-AD39-49A5-ADEE-70FADE4954CE.html",
							"GUID-42E66214-74F6-4727-BA23-90B47F7A46D1.html",
							"GUID-42E66214-74F6-4727-BA23-90B47F7A46D1.html",
							"GUID-42E66214-74F6-4727-BA23-90B47F7A46D1.html",
							"GUID-6D4995AC-20AC-4C62-BB7A-C15D087FB8B5.html",
							"GUID-6D4995AC-20AC-4C62-BB7A-C15D087FB8B5.html",
							"GUID-6D4995AC-20AC-4C62-BB7A-C15D087FB8B5.html",
							"GUID-2B957012-A09E-4195-AD9B-7816864AE7D4.html",
							"GUID-2B957012-A09E-4195-AD9B-7816864AE7D4.html",
							"GUID-2B957012-A09E-4195-AD9B-7816864AE7D4.html",
							"GUID-C41105AD-522B-4866-AC66-75A20110587A.html",
							"GUID-C41105AD-522B-4866-AC66-75A20110587A.html",
							"GUID-C41105AD-522B-4866-AC66-75A20110587A.html",
							"GUID-2CA9741B-15B1-4C21-8568-66639406EED6.html",
							"GUID-2CA9741B-15B1-4C21-8568-66639406EED6.html",
							"GUID-2CA9741B-15B1-4C21-8568-66639406EED6.html",
							"GUID-8A4CFC3C-660B-4DEA-803D-8B510920C4FA.html",
							"GUID-8A4CFC3C-660B-4DEA-803D-8B510920C4FA.html",
							"GUID-8A4CFC3C-660B-4DEA-803D-8B510920C4FA.html",
							"GUID-93985CDD-F578-4CB7-AE78-E65FC8AFCF1E.html",
							"GUID-93985CDD-F578-4CB7-AE78-E65FC8AFCF1E.html",
							"GUID-93985CDD-F578-4CB7-AE78-E65FC8AFCF1E.html",
							"GUID-05B545E2-37BC-44D7-90A2-033861C5AFB4.html",
							"GUID-05B545E2-37BC-44D7-90A2-033861C5AFB4.html",
							"GUID-05B545E2-37BC-44D7-90A2-033861C5AFB4.html",
							"GUID-D850D1AE-FD20-484E-BAD0-1356CA400E66.html",
							"GUID-D850D1AE-FD20-484E-BAD0-1356CA400E66.html",
							"GUID-D850D1AE-FD20-484E-BAD0-1356CA400E66.html",
							"GUID-AE441BF4-67BB-443B-96F3-7A167FBC89E4.html",
							"GUID-AE441BF4-67BB-443B-96F3-7A167FBC89E4.html",
							"GUID-AE441BF4-67BB-443B-96F3-7A167FBC89E4.html",
							"GUID-181EFEDD-2EC3-47C5-8B34-A5BCB4C94F9B.html",
							"GUID-181EFEDD-2EC3-47C5-8B34-A5BCB4C94F9B.html",
							"GUID-181EFEDD-2EC3-47C5-8B34-A5BCB4C94F9B.html",
							"GUID-313F50D3-16E7-49B1-A249-C4C5E027EB83.html",
							"GUID-313F50D3-16E7-49B1-A249-C4C5E027EB83.html",
							"GUID-313F50D3-16E7-49B1-A249-C4C5E027EB83.html",
							"GUID-AC61FBEF-AB6A-4211-883E-9B8B67E3EF27.html",
							"GUID-AC61FBEF-AB6A-4211-883E-9B8B67E3EF27.html",
							"GUID-AC61FBEF-AB6A-4211-883E-9B8B67E3EF27.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-7BCE9F7A-D28B-445B-9ED2-D7EA1B1B4B2F.html",
							"GUID-7BCE9F7A-D28B-445B-9ED2-D7EA1B1B4B2F.html",
							"GUID-7BCE9F7A-D28B-445B-9ED2-D7EA1B1B4B2F.html",
							"GUID-FD428666-13E8-4B77-A4DB-5ED53F992A23.html",
							"GUID-FD428666-13E8-4B77-A4DB-5ED53F992A23.html",
							"GUID-FD428666-13E8-4B77-A4DB-5ED53F992A23.html",
							"GUID-34734A12-8C88-4DB1-941A-46CC30B465D7.html",
							"GUID-34734A12-8C88-4DB1-941A-46CC30B465D7.html",
							"GUID-34734A12-8C88-4DB1-941A-46CC30B465D7.html",
							"GUID-2B7BCE9C-B7BB-4D41-995B-8A109D44C68F.html",
							"GUID-2B7BCE9C-B7BB-4D41-995B-8A109D44C68F.html",
							"GUID-2B7BCE9C-B7BB-4D41-995B-8A109D44C68F.html",
							"GUID-99485118-6F10-4B1E-B539-85DCE4019F88.html",
							"GUID-99485118-6F10-4B1E-B539-85DCE4019F88.html",
							"GUID-99485118-6F10-4B1E-B539-85DCE4019F88.html",
							"GUID-2F226F4D-8C80-4A6C-8416-45D070CCB143.html",
							"GUID-2F226F4D-8C80-4A6C-8416-45D070CCB143.html",
							"GUID-2F226F4D-8C80-4A6C-8416-45D070CCB143.html",
							"GUID-2F226F4D-8C80-4A6C-8416-45D070CCB143.html",
							"GUID-2F226F4D-8C80-4A6C-8416-45D070CCB143.html",
							"GUID-36B94A80-5692-4ECF-A2C1-EA0254B835BF.html",
							"GUID-36B94A80-5692-4ECF-A2C1-EA0254B835BF.html",
							"GUID-36B94A80-5692-4ECF-A2C1-EA0254B835BF.html",
							"GUID-36B94A80-5692-4ECF-A2C1-EA0254B835BF.html",
							"GUID-36B94A80-5692-4ECF-A2C1-EA0254B835BF.html",
							"GUID-0251276B-DF3F-47DD-8545-BF927AF7DF37.html",
							"GUID-0251276B-DF3F-47DD-8545-BF927AF7DF37.html",
							"GUID-0251276B-DF3F-47DD-8545-BF927AF7DF37.html",
							"GUID-0251276B-DF3F-47DD-8545-BF927AF7DF37.html",
							"GUID-0251276B-DF3F-47DD-8545-BF927AF7DF37.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-DD8C4D06-9F06-429F-9591-4CFA63D07E97.html",
							"GUID-02FDBC5B-C6C9-43FC-9770-801325FFED37.html",
							"GUID-02FDBC5B-C6C9-43FC-9770-801325FFED37.html",
							"GUID-02FDBC5B-C6C9-43FC-9770-801325FFED37.html",
							"GUID-02FDBC5B-C6C9-43FC-9770-801325FFED37.html",
							"GUID-02FDBC5B-C6C9-43FC-9770-801325FFED37.html",
							"GUID-E19B8456-6CA2-404B-9C0E-0C2C8661E453.html",
							"GUID-E19B8456-6CA2-404B-9C0E-0C2C8661E453.html",
							"GUID-E19B8456-6CA2-404B-9C0E-0C2C8661E453.html",
							"GUID-E19B8456-6CA2-404B-9C0E-0C2C8661E453.html",
							"GUID-E19B8456-6CA2-404B-9C0E-0C2C8661E453.html",
							"GUID-0A7A702E-7C09-4487-AF02-48F8EBB5A1DF.html",
							"GUID-0A7A702E-7C09-4487-AF02-48F8EBB5A1DF.html",
							"GUID-0A7A702E-7C09-4487-AF02-48F8EBB5A1DF.html",
							"GUID-0A7A702E-7C09-4487-AF02-48F8EBB5A1DF.html",
							"GUID-0A7A702E-7C09-4487-AF02-48F8EBB5A1DF.html",
							"GUID-601EC36F-434F-4CEE-BF96-232B23F39458.html","GUID-4D1778DA-A40E-449E-974B-2A194F3B4526.html",
							"GUID-4D1778DA-A40E-449E-974B-2A194F3B4526.html",
							"GUID-4D1778DA-A40E-449E-974B-2A194F3B4526.html",
							"GUID-4D1778DA-A40E-449E-974B-2A194F3B4526.html",
							"GUID-4D1778DA-A40E-449E-974B-2A194F3B4526.html",
							"GUID-BFF159D7-FBC0-4F77-9F6B-4188DC546565.html",
							"GUID-BFF159D7-FBC0-4F77-9F6B-4188DC546565.html",
							"GUID-BFF159D7-FBC0-4F77-9F6B-4188DC546565.html",
							"GUID-BFF159D7-FBC0-4F77-9F6B-4188DC546565.html",
							"GUID-BFF159D7-FBC0-4F77-9F6B-4188DC546565.html",
							"GUID-68EE2145-0277-44A8-9EAD-5DA10C2A1702.html",
							"GUID-68EE2145-0277-44A8-9EAD-5DA10C2A1702.html",
							"GUID-68EE2145-0277-44A8-9EAD-5DA10C2A1702.html",
							"GUID-68EE2145-0277-44A8-9EAD-5DA10C2A1702.html",
							"GUID-68EE2145-0277-44A8-9EAD-5DA10C2A1702.html",
							"GUID-137F1BAC-39B0-4300-8E31-9E072547390A.html",
							"GUID-137F1BAC-39B0-4300-8E31-9E072547390A.html",
							"GUID-137F1BAC-39B0-4300-8E31-9E072547390A.html",
							"GUID-137F1BAC-39B0-4300-8E31-9E072547390A.html",
							"GUID-137F1BAC-39B0-4300-8E31-9E072547390A.html",
							"GUID-1C10D202-0B0E-4646-9A39-E851B3C17C04.html",
							"GUID-1C10D202-0B0E-4646-9A39-E851B3C17C04.html",
							"GUID-1C10D202-0B0E-4646-9A39-E851B3C17C04.html",
							"GUID-1C10D202-0B0E-4646-9A39-E851B3C17C04.html",
							"GUID-1C10D202-0B0E-4646-9A39-E851B3C17C04.html",
							"GUID-4C1ABF34-C433-4B31-9C0E-3640379C4505.html",
							"GUID-4C1ABF34-C433-4B31-9C0E-3640379C4505.html",
							"GUID-F7CAEC8A-C062-4C3C-AC08-D645032D9E8A.html",
							"GUID-F7CAEC8A-C062-4C3C-AC08-D645032D9E8A.html",
							"GUID-F7CAEC8A-C062-4C3C-AC08-D645032D9E8A.html",
							"GUID-F7CAEC8A-C062-4C3C-AC08-D645032D9E8A.html",
							"GUID-F7CAEC8A-C062-4C3C-AC08-D645032D9E8A.html",
							"GUID-F1605631-7DC9-4572-BCA1-85BBD08E6F01.html",
							"GUID-F1605631-7DC9-4572-BCA1-85BBD08E6F01.html",
							"GUID-F1605631-7DC9-4572-BCA1-85BBD08E6F01.html",
							"GUID-F1605631-7DC9-4572-BCA1-85BBD08E6F01.html",
							"GUID-F1605631-7DC9-4572-BCA1-85BBD08E6F01.html",
							"GUID-B25B1045-E18C-4AC4-ABBF-5CB9F6CEBA21.html",
							"GUID-B25B1045-E18C-4AC4-ABBF-5CB9F6CEBA21.html",
							"GUID-B25B1045-E18C-4AC4-ABBF-5CB9F6CEBA21.html",
							"GUID-B25B1045-E18C-4AC4-ABBF-5CB9F6CEBA21.html",
							"GUID-B25B1045-E18C-4AC4-ABBF-5CB9F6CEBA21.html",
							"GUID-F9698DC6-BF78-4773-A5E3-CA7D4F570394.html","GUID-04D7627E-7290-429B-88B9-2EFFFA11A3A8.html","GUID-070C3957-164B-4B25-B4D1-A01BBA16D143.html","GUID-E5AC2B5B-4DA1-4D7D-A714-901692577E30.html","GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-15DB80F8-532D-4B27-BCD1-E272D026D496.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-D0A0E15E-A5F3-45C8-B0BB-53DCE5A64018.html",
							"GUID-1B1F437C-8198-4F09-A55A-E6CC9DC2F0D2.html",
							"GUID-1B1F437C-8198-4F09-A55A-E6CC9DC2F0D2.html",
							"GUID-1B1F437C-8198-4F09-A55A-E6CC9DC2F0D2.html",
							"GUID-1B1F437C-8198-4F09-A55A-E6CC9DC2F0D2.html",
							"GUID-1B1F437C-8198-4F09-A55A-E6CC9DC2F0D2.html",
							"GUID-1B1F437C-8198-4F09-A55A-E6CC9DC2F0D2.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-E0055619-2139-42DA-97D1-F835927C2BB4.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-D8D857B8-0293-4D84-A0E6-364F92FFD026.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-6CD7C8E0-DD5B-486E-80A9-87573F66262F.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-FD99E031-E3FF-4C96-88A3-327CDB03FFBC.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-F905E6E8-E863-41E1-97F8-FBB50F33260E.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-63FA0ED0-29CE-4F9B-AD5B-AECD9F0A97F7.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-D35B19AE-30B6-42EB-80E0-E184688A4835.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-C1425EF6-E258-4BB3-8A42-A4FA273D986A.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-34AF272B-8BA5-4F07-A02F-3927F5AD84D8.html",
							"GUID-B1B6548B-B190-4C76-AC2E-B4A3887DC4F0.html",
							"GUID-B1B6548B-B190-4C76-AC2E-B4A3887DC4F0.html",
							"GUID-B1B6548B-B190-4C76-AC2E-B4A3887DC4F0.html",
							"GUID-B1B6548B-B190-4C76-AC2E-B4A3887DC4F0.html",
							"GUID-B1B6548B-B190-4C76-AC2E-B4A3887DC4F0.html",
							"GUID-B1B6548B-B190-4C76-AC2E-B4A3887DC4F0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A04B89DB-7744-4F17-A9C5-892B32D918A0.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-A0B4C5A1-F2BD-4379-8CFD-BD1493E3C4C8.html",
							"GUID-82627570-09DA-49A7-95EC-D502E201BEA3.html","GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-C78B9ED1-3736-4C02-A930-8E6589BC9828.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-97A2208A-3D08-416E-B595-BF8E4CB0A0CB.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-CA533744-0688-4663-8A7F-42E17766C1DE.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-1A6BCB16-A904-411E-8229-5C74FE66DFE9.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-942E859B-BDC8-4F06-B929-774C39EE0C54.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-04A94486-92A6-423A-9905-EEB57946E54E.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-26A4A2B8-7D31-4D78-BB31-F75FBB908464.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-512CCF5A-7460-4383-AE8B-D5140D999504.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-ECD3BB24-C6EF-46A7-8FF4-736422466487.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-CBDA31F9-FD08-4BF5-BA92-67688E2614CA.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-B725494B-97FD-49F1-B9AD-97ECF6E8EB9B.html",
							"GUID-1BAE1DD1-EB49-43B8-96E6-0BD84B506526.html",
							"GUID-1BAE1DD1-EB49-43B8-96E6-0BD84B506526.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-3FF8AD86-4F85-4405-B250-DFA932E59A09.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-F8482363-DAD9-4083-B4A4-9679B255B8A3.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-7812B486-71F4-4F9B-B268-B67C7AA3B547.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-696B451A-CBE8-4FD5-BBFC-BE8F8BFA5428.html",
							"GUID-F939E2FB-9143-46F0-8D4C-A6C39832A572.html",
							"GUID-F939E2FB-9143-46F0-8D4C-A6C39832A572.html",
							"GUID-F939E2FB-9143-46F0-8D4C-A6C39832A572.html",
							"GUID-F939E2FB-9143-46F0-8D4C-A6C39832A572.html",
							"GUID-F939E2FB-9143-46F0-8D4C-A6C39832A572.html",
							"GUID-F939E2FB-9143-46F0-8D4C-A6C39832A572.html",
							"GUID-F939E2FB-9143-46F0-8D4C-A6C39832A572.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-6F8ADFF3-9FEC-4989-BFB7-CF11CF1A50E7.html",
							"GUID-AA710303-8EC4-46F9-9F40-B61401D0F4FB.html","GUID-911DF565-32FA-4B08-9364-0C6499C671E0.html","GUID-9D2DBA97-140B-4DEA-A9BF-A14020B464F5.html","GUID-9B98EF15-8C1B-41AA-9A06-BDCC3E553185.html",
							"GUID-9B98EF15-8C1B-41AA-9A06-BDCC3E553185.html",
							"GUID-88A19DBB-A943-4B81-B812-8573EAB52040.html",
							"GUID-88A19DBB-A943-4B81-B812-8573EAB52040.html",
							"GUID-88A19DBB-A943-4B81-B812-8573EAB52040.html",
							"GUID-88A19DBB-A943-4B81-B812-8573EAB52040.html",
							"GUID-88A19DBB-A943-4B81-B812-8573EAB52040.html",
							"GUID-E9FE0B85-08F1-4BCB-8AB1-73EAA5C91157.html",
							"GUID-E9FE0B85-08F1-4BCB-8AB1-73EAA5C91157.html",
							"GUID-E9FE0B85-08F1-4BCB-8AB1-73EAA5C91157.html",
							"GUID-E9FE0B85-08F1-4BCB-8AB1-73EAA5C91157.html",
							"GUID-E9FE0B85-08F1-4BCB-8AB1-73EAA5C91157.html",
							"GUID-D809FE8D-1A88-4B24-9682-56D449249AA9.html",
							"GUID-D809FE8D-1A88-4B24-9682-56D449249AA9.html",
							"GUID-D809FE8D-1A88-4B24-9682-56D449249AA9.html",
							"GUID-D809FE8D-1A88-4B24-9682-56D449249AA9.html",
							"GUID-D809FE8D-1A88-4B24-9682-56D449249AA9.html",
							"GUID-8E1992ED-A7DA-46BB-BC0E-B86943301F0A.html",
							"GUID-8E1992ED-A7DA-46BB-BC0E-B86943301F0A.html",
							"GUID-8E1992ED-A7DA-46BB-BC0E-B86943301F0A.html",
							"GUID-8E1992ED-A7DA-46BB-BC0E-B86943301F0A.html",
							"GUID-8E1992ED-A7DA-46BB-BC0E-B86943301F0A.html",
							"GUID-ECE70EDD-690B-4375-9802-C976474D8C8E.html",
							"GUID-ECE70EDD-690B-4375-9802-C976474D8C8E.html",
							"GUID-ECE70EDD-690B-4375-9802-C976474D8C8E.html",
							"GUID-ECE70EDD-690B-4375-9802-C976474D8C8E.html",
							"GUID-ECE70EDD-690B-4375-9802-C976474D8C8E.html",
							"GUID-5DDB10FF-5CEA-414D-B0CF-388C68AD3AA8.html",
							"GUID-5DDB10FF-5CEA-414D-B0CF-388C68AD3AA8.html",
							"GUID-5DDB10FF-5CEA-414D-B0CF-388C68AD3AA8.html",
							"GUID-5DDB10FF-5CEA-414D-B0CF-388C68AD3AA8.html",
							"GUID-5DDB10FF-5CEA-414D-B0CF-388C68AD3AA8.html",
							"GUID-ACA732A7-9AED-4CAE-BFCD-6B19A151009E.html","GUID-DB1CF0C7-2AFD-44E1-8C4E-B1476A82AD33.html",
							"GUID-DB1CF0C7-2AFD-44E1-8C4E-B1476A82AD33.html",
							"GUID-4BEE312E-9BD5-48DA-956B-32536E21A510.html",
							"GUID-4BEE312E-9BD5-48DA-956B-32536E21A510.html",
							"GUID-4BEE312E-9BD5-48DA-956B-32536E21A510.html",
							"GUID-4BEE312E-9BD5-48DA-956B-32536E21A510.html",
							"GUID-4BEE312E-9BD5-48DA-956B-32536E21A510.html",
							"GUID-AB223016-7B9D-438B-BEA9-6D5A2DF6A2F3.html",
							"GUID-AB223016-7B9D-438B-BEA9-6D5A2DF6A2F3.html",
							"GUID-AB223016-7B9D-438B-BEA9-6D5A2DF6A2F3.html",
							"GUID-AB223016-7B9D-438B-BEA9-6D5A2DF6A2F3.html",
							"GUID-AB223016-7B9D-438B-BEA9-6D5A2DF6A2F3.html",
							"GUID-1D2B3A27-BCDF-4C33-A963-088714C9F015.html",
							"GUID-1D2B3A27-BCDF-4C33-A963-088714C9F015.html",
							"GUID-1D2B3A27-BCDF-4C33-A963-088714C9F015.html",
							"GUID-1D2B3A27-BCDF-4C33-A963-088714C9F015.html",
							"GUID-1D2B3A27-BCDF-4C33-A963-088714C9F015.html",
							"GUID-7C562439-484A-40C2-9D10-53C0C2B56158.html","GUID-78F824B5-4E7B-4D65-B310-BE37C8C38844.html",
							"GUID-78F824B5-4E7B-4D65-B310-BE37C8C38844.html",
							"GUID-78F824B5-4E7B-4D65-B310-BE37C8C38844.html",
							"GUID-78F824B5-4E7B-4D65-B310-BE37C8C38844.html",
							"GUID-78F824B5-4E7B-4D65-B310-BE37C8C38844.html",
							"GUID-78F824B5-4E7B-4D65-B310-BE37C8C38844.html",
							"GUID-91F85717-52F6-4CFD-8CB5-8B48E2337117.html",
							"GUID-91F85717-52F6-4CFD-8CB5-8B48E2337117.html",
							"GUID-91F85717-52F6-4CFD-8CB5-8B48E2337117.html",
							"GUID-91F85717-52F6-4CFD-8CB5-8B48E2337117.html",
							"GUID-91F85717-52F6-4CFD-8CB5-8B48E2337117.html",
							"GUID-CB303268-21AC-4928-8CEC-EC61F27AE06C.html",
							"GUID-CB303268-21AC-4928-8CEC-EC61F27AE06C.html",
							"GUID-CB303268-21AC-4928-8CEC-EC61F27AE06C.html",
							"GUID-CB303268-21AC-4928-8CEC-EC61F27AE06C.html",
							"GUID-CB303268-21AC-4928-8CEC-EC61F27AE06C.html",
							"GUID-51C8F892-B88F-49CA-8621-6865A61C4312.html",
							"GUID-51C8F892-B88F-49CA-8621-6865A61C4312.html",
							"GUID-51C8F892-B88F-49CA-8621-6865A61C4312.html",
							"GUID-51C8F892-B88F-49CA-8621-6865A61C4312.html",
							"GUID-51C8F892-B88F-49CA-8621-6865A61C4312.html",
							"GUID-FB690C39-0AAB-4487-9A39-19E6DEEB1A7A.html",
							"GUID-FB690C39-0AAB-4487-9A39-19E6DEEB1A7A.html",
							"GUID-FB690C39-0AAB-4487-9A39-19E6DEEB1A7A.html",
							"GUID-FB690C39-0AAB-4487-9A39-19E6DEEB1A7A.html",
							"GUID-FB690C39-0AAB-4487-9A39-19E6DEEB1A7A.html",
							"GUID-71678952-BDEB-4E0F-82CC-E2A763378BAD.html",
							"GUID-71678952-BDEB-4E0F-82CC-E2A763378BAD.html",
							"GUID-71678952-BDEB-4E0F-82CC-E2A763378BAD.html",
							"GUID-71678952-BDEB-4E0F-82CC-E2A763378BAD.html",
							"GUID-71678952-BDEB-4E0F-82CC-E2A763378BAD.html",
							"GUID-B36D4356-7F5A-4819-9133-53F8509A92CB.html",
							"GUID-B36D4356-7F5A-4819-9133-53F8509A92CB.html",
							"GUID-B36D4356-7F5A-4819-9133-53F8509A92CB.html",
							"GUID-B36D4356-7F5A-4819-9133-53F8509A92CB.html",
							"GUID-B36D4356-7F5A-4819-9133-53F8509A92CB.html",
							"GUID-795D782C-B095-4F59-B03E-45D97B2E06A0.html","GUID-89822127-8C60-4EC6-BD4B-3A85D0C1D2D0.html",
							"GUID-89822127-8C60-4EC6-BD4B-3A85D0C1D2D0.html",
							"GUID-89822127-8C60-4EC6-BD4B-3A85D0C1D2D0.html",
							"GUID-89822127-8C60-4EC6-BD4B-3A85D0C1D2D0.html",
							"GUID-89822127-8C60-4EC6-BD4B-3A85D0C1D2D0.html",
							"GUID-5DE78138-6399-43B7-B313-FA77803BF94A.html",
							"GUID-5DE78138-6399-43B7-B313-FA77803BF94A.html",
							"GUID-5DE78138-6399-43B7-B313-FA77803BF94A.html",
							"GUID-5DE78138-6399-43B7-B313-FA77803BF94A.html",
							"GUID-5DE78138-6399-43B7-B313-FA77803BF94A.html",
							"GUID-456A8A0F-56A6-4850-AC7A-C7160BD3E1E7.html",
							"GUID-456A8A0F-56A6-4850-AC7A-C7160BD3E1E7.html",
							"GUID-456A8A0F-56A6-4850-AC7A-C7160BD3E1E7.html",
							"GUID-456A8A0F-56A6-4850-AC7A-C7160BD3E1E7.html",
							"GUID-456A8A0F-56A6-4850-AC7A-C7160BD3E1E7.html",
							"GUID-456A8A0F-56A6-4850-AC7A-C7160BD3E1E7.html",
							"GUID-456A8A0F-56A6-4850-AC7A-C7160BD3E1E7.html",
							"GUID-202B78CF-4509-4C63-8B85-8E5B0DC0046D.html",
							"GUID-202B78CF-4509-4C63-8B85-8E5B0DC0046D.html",
							"GUID-202B78CF-4509-4C63-8B85-8E5B0DC0046D.html",
							"GUID-202B78CF-4509-4C63-8B85-8E5B0DC0046D.html",
							"GUID-202B78CF-4509-4C63-8B85-8E5B0DC0046D.html",
							"GUID-202B78CF-4509-4C63-8B85-8E5B0DC0046D.html",
							"GUID-D6BCFD39-CE70-438A-A853-9D84010E43C8.html",
							"GUID-D6BCFD39-CE70-438A-A853-9D84010E43C8.html",
							"GUID-D6BCFD39-CE70-438A-A853-9D84010E43C8.html",
							"GUID-D6BCFD39-CE70-438A-A853-9D84010E43C8.html",
							"GUID-D6BCFD39-CE70-438A-A853-9D84010E43C8.html",
							"GUID-956305A1-EE85-4D7F-81C3-1BEBB3FB7114.html",
							"GUID-956305A1-EE85-4D7F-81C3-1BEBB3FB7114.html",
							"GUID-956305A1-EE85-4D7F-81C3-1BEBB3FB7114.html",
							"GUID-956305A1-EE85-4D7F-81C3-1BEBB3FB7114.html",
							"GUID-956305A1-EE85-4D7F-81C3-1BEBB3FB7114.html",
							"GUID-51FD9A2A-6D80-455D-B236-6554EB19EEA3.html","GUID-A87D6632-B8F0-48A7-B9DD-73BE3F3169B3.html",
							"GUID-A87D6632-B8F0-48A7-B9DD-73BE3F3169B3.html",
							"GUID-A87D6632-B8F0-48A7-B9DD-73BE3F3169B3.html",
							"GUID-A87D6632-B8F0-48A7-B9DD-73BE3F3169B3.html",
							"GUID-A87D6632-B8F0-48A7-B9DD-73BE3F3169B3.html",
							"GUID-0ED5D037-0BA2-4452-8785-43824DAC786E.html",
							"GUID-0ED5D037-0BA2-4452-8785-43824DAC786E.html",
							"GUID-0ED5D037-0BA2-4452-8785-43824DAC786E.html",
							"GUID-0ED5D037-0BA2-4452-8785-43824DAC786E.html",
							"GUID-0ED5D037-0BA2-4452-8785-43824DAC786E.html",
							"GUID-3E56273D-2281-483B-A760-BB0C244FB93B.html",
							"GUID-3E56273D-2281-483B-A760-BB0C244FB93B.html",
							"GUID-3E56273D-2281-483B-A760-BB0C244FB93B.html",
							"GUID-3E56273D-2281-483B-A760-BB0C244FB93B.html",
							"GUID-3E56273D-2281-483B-A760-BB0C244FB93B.html",
							"GUID-C49074E7-EF91-4C60-9FDB-775143F0CDB6.html",
							"GUID-C49074E7-EF91-4C60-9FDB-775143F0CDB6.html",
							"GUID-C49074E7-EF91-4C60-9FDB-775143F0CDB6.html",
							"GUID-C49074E7-EF91-4C60-9FDB-775143F0CDB6.html",
							"GUID-C49074E7-EF91-4C60-9FDB-775143F0CDB6.html",
							"GUID-15679EB4-CBE3-4C56-89BF-58E25631A744.html",
							"GUID-15679EB4-CBE3-4C56-89BF-58E25631A744.html",
							"GUID-15679EB4-CBE3-4C56-89BF-58E25631A744.html",
							"GUID-15679EB4-CBE3-4C56-89BF-58E25631A744.html",
							"GUID-15679EB4-CBE3-4C56-89BF-58E25631A744.html",
							"GUID-03E57600-9702-4A2C-A0EB-FDBFD942A560.html",
							"GUID-03E57600-9702-4A2C-A0EB-FDBFD942A560.html",
							"GUID-03E57600-9702-4A2C-A0EB-FDBFD942A560.html",
							"GUID-03E57600-9702-4A2C-A0EB-FDBFD942A560.html",
							"GUID-03E57600-9702-4A2C-A0EB-FDBFD942A560.html",
							"GUID-1261E3B1-C162-4E9F-A193-269270E7B5C3.html",
							"GUID-1261E3B1-C162-4E9F-A193-269270E7B5C3.html",
							"GUID-1261E3B1-C162-4E9F-A193-269270E7B5C3.html",
							"GUID-1261E3B1-C162-4E9F-A193-269270E7B5C3.html",
							"GUID-1261E3B1-C162-4E9F-A193-269270E7B5C3.html",
							"GUID-C00FE673-5F64-432B-8429-A6B400DBED34.html",
							"GUID-C00FE673-5F64-432B-8429-A6B400DBED34.html",
							"GUID-C00FE673-5F64-432B-8429-A6B400DBED34.html",
							"GUID-C00FE673-5F64-432B-8429-A6B400DBED34.html",
							"GUID-C00FE673-5F64-432B-8429-A6B400DBED34.html",
							"GUID-BD25E707-A5F1-44A2-9D31-2A71D87619DD.html","GUID-CC0D96FC-D06E-47E3-8539-B6EF8CDD4B5F.html",
							"GUID-CC0D96FC-D06E-47E3-8539-B6EF8CDD4B5F.html",
							"GUID-CC0D96FC-D06E-47E3-8539-B6EF8CDD4B5F.html",
							"GUID-CC0D96FC-D06E-47E3-8539-B6EF8CDD4B5F.html",
							"GUID-CC0D96FC-D06E-47E3-8539-B6EF8CDD4B5F.html",
							"GUID-43596460-CC50-42F7-9F0D-E2C30FEB4D16.html",
							"GUID-43596460-CC50-42F7-9F0D-E2C30FEB4D16.html",
							"GUID-43596460-CC50-42F7-9F0D-E2C30FEB4D16.html",
							"GUID-43596460-CC50-42F7-9F0D-E2C30FEB4D16.html",
							"GUID-43596460-CC50-42F7-9F0D-E2C30FEB4D16.html",
							"GUID-480322DE-77D7-4DD6-9AB0-9B92A193D321.html","GUID-A7AA3BE6-76B0-4441-A2A8-A735E57CEA4B.html","GUID-E2FE39AA-AEBF-4BFC-981A-FDE351717FCF.html",
							"GUID-E2FE39AA-AEBF-4BFC-981A-FDE351717FCF.html",
							"GUID-E2FE39AA-AEBF-4BFC-981A-FDE351717FCF.html",
							"GUID-E2FE39AA-AEBF-4BFC-981A-FDE351717FCF.html",
							"GUID-E2FE39AA-AEBF-4BFC-981A-FDE351717FCF.html",
							"GUID-C2B25B6A-06D0-4675-88E7-806BE81D2608.html",
							"GUID-C2B25B6A-06D0-4675-88E7-806BE81D2608.html",
							"GUID-506892AE-D002-4491-9276-91CED2223F59.html",
							"GUID-506892AE-D002-4491-9276-91CED2223F59.html",
							"GUID-FAD156F3-42E3-4F3E-93A6-286A1E61A7A8.html",
							"GUID-FAD156F3-42E3-4F3E-93A6-286A1E61A7A8.html",
							"GUID-FAD156F3-42E3-4F3E-93A6-286A1E61A7A8.html",
							"GUID-FAD156F3-42E3-4F3E-93A6-286A1E61A7A8.html",
							"GUID-FAD156F3-42E3-4F3E-93A6-286A1E61A7A8.html",
							"GUID-67754858-0E79-4B34-B7FC-9BD8E749C5E0.html",
							"GUID-67754858-0E79-4B34-B7FC-9BD8E749C5E0.html",
							"GUID-67754858-0E79-4B34-B7FC-9BD8E749C5E0.html",
							"GUID-67754858-0E79-4B34-B7FC-9BD8E749C5E0.html",
							"GUID-67754858-0E79-4B34-B7FC-9BD8E749C5E0.html",
							"GUID-BFF47215-A835-40F5-899A-1D22EA0F9218.html",
							"GUID-BFF47215-A835-40F5-899A-1D22EA0F9218.html",
							"GUID-DE7B998F-24F2-4627-ADC5-EFA317231FAA.html",
							"GUID-DE7B998F-24F2-4627-ADC5-EFA317231FAA.html",
							"GUID-51F76052-F1E0-4F1C-8F6F-7AFA694BB491.html",
							"GUID-51F76052-F1E0-4F1C-8F6F-7AFA694BB491.html",
							"GUID-A0388FC8-41A1-47DD-91E2-22B04BD5641D.html",
							"GUID-A0388FC8-41A1-47DD-91E2-22B04BD5641D.html",
							"GUID-A0388FC8-41A1-47DD-91E2-22B04BD5641D.html",
							"GUID-A0388FC8-41A1-47DD-91E2-22B04BD5641D.html",
							"GUID-A0388FC8-41A1-47DD-91E2-22B04BD5641D.html",
							"GUID-2FEFAEB3-85AE-447D-83D3-6CDDE02BE9CE.html",
							"GUID-2FEFAEB3-85AE-447D-83D3-6CDDE02BE9CE.html",
							"GUID-2FEFAEB3-85AE-447D-83D3-6CDDE02BE9CE.html",
							"GUID-2FEFAEB3-85AE-447D-83D3-6CDDE02BE9CE.html",
							"GUID-2FEFAEB3-85AE-447D-83D3-6CDDE02BE9CE.html",
							"GUID-44C4E7EF-FFAB-4879-BD41-4531A8970EC5.html",
							"GUID-44C4E7EF-FFAB-4879-BD41-4531A8970EC5.html",
							"GUID-44C4E7EF-FFAB-4879-BD41-4531A8970EC5.html",
							"GUID-44C4E7EF-FFAB-4879-BD41-4531A8970EC5.html",
							"GUID-44C4E7EF-FFAB-4879-BD41-4531A8970EC5.html",
							"GUID-14CCB15F-E1E1-4AFF-8A37-58AAE24355E6.html",
							"GUID-14CCB15F-E1E1-4AFF-8A37-58AAE24355E6.html",
							"GUID-14CCB15F-E1E1-4AFF-8A37-58AAE24355E6.html",
							"GUID-14CCB15F-E1E1-4AFF-8A37-58AAE24355E6.html",
							"GUID-14CCB15F-E1E1-4AFF-8A37-58AAE24355E6.html",
							"GUID-314C9E27-C6B6-4B76-8DCA-EDC476B6725E.html",
							"GUID-314C9E27-C6B6-4B76-8DCA-EDC476B6725E.html",
							"GUID-314C9E27-C6B6-4B76-8DCA-EDC476B6725E.html",
							"GUID-314C9E27-C6B6-4B76-8DCA-EDC476B6725E.html",
							"GUID-314C9E27-C6B6-4B76-8DCA-EDC476B6725E.html",
							"GUID-4F0C3848-B380-498A-BA1B-CA5CE881089F.html",
							"GUID-4F0C3848-B380-498A-BA1B-CA5CE881089F.html",
							"GUID-4F0C3848-B380-498A-BA1B-CA5CE881089F.html",
							"GUID-4F0C3848-B380-498A-BA1B-CA5CE881089F.html",
							"GUID-4F0C3848-B380-498A-BA1B-CA5CE881089F.html",
							"GUID-F1F7E292-408A-430C-96F7-E56F9973D6DB.html",
							"GUID-F1F7E292-408A-430C-96F7-E56F9973D6DB.html",
							"GUID-1D5B1B99-0641-45A0-8B5A-B4A6BB2CCDAF.html",
							"GUID-1D5B1B99-0641-45A0-8B5A-B4A6BB2CCDAF.html",
							"GUID-F61D0B4D-CFF1-4C8E-9AC2-0DB9D46D281E.html",
							"GUID-F61D0B4D-CFF1-4C8E-9AC2-0DB9D46D281E.html",
							"GUID-0800C3A0-23F8-41BB-B8AD-4D9C0407AB38.html",
							"GUID-0800C3A0-23F8-41BB-B8AD-4D9C0407AB38.html",
							"GUID-BCD0D013-9731-4C5F-98F7-0ABE5DF2AE13.html",
							"GUID-BCD0D013-9731-4C5F-98F7-0ABE5DF2AE13.html",
							"GUID-10BECA42-C215-4EF0-A038-D502DF6F0D90.html",
							"GUID-10BECA42-C215-4EF0-A038-D502DF6F0D90.html",
							"GUID-541D9C51-818E-40A4-A5A1-D93105218B56.html",
							"GUID-541D9C51-818E-40A4-A5A1-D93105218B56.html",
							"GUID-F34C1448-7392-41AB-8D75-1456B23DB5BE.html",
							"GUID-F34C1448-7392-41AB-8D75-1456B23DB5BE.html",
							"GUID-B0E907E1-ED35-4105-ADC5-5FB00201912D.html",
							"GUID-B0E907E1-ED35-4105-ADC5-5FB00201912D.html",
							"GUID-B0E907E1-ED35-4105-ADC5-5FB00201912D.html",
							"GUID-B0E907E1-ED35-4105-ADC5-5FB00201912D.html",
							"GUID-B0E907E1-ED35-4105-ADC5-5FB00201912D.html",
							"GUID-3B61CC09-3FC9-46B2-929B-D3A07FD22818.html",
							"GUID-3B61CC09-3FC9-46B2-929B-D3A07FD22818.html",
							"GUID-3B61CC09-3FC9-46B2-929B-D3A07FD22818.html",
							"GUID-3B61CC09-3FC9-46B2-929B-D3A07FD22818.html",
							"GUID-3B61CC09-3FC9-46B2-929B-D3A07FD22818.html",
							"GUID-A8EDA004-F102-4770-B491-B3DBAA1855F4.html",
							"GUID-A8EDA004-F102-4770-B491-B3DBAA1855F4.html",
							"GUID-A8EDA004-F102-4770-B491-B3DBAA1855F4.html",
							"GUID-A8EDA004-F102-4770-B491-B3DBAA1855F4.html",
							"GUID-A8EDA004-F102-4770-B491-B3DBAA1855F4.html",
							"GUID-5048EC42-E9B5-4703-B9B7-AF738306CD06.html",
							"GUID-5048EC42-E9B5-4703-B9B7-AF738306CD06.html",
							"GUID-5048EC42-E9B5-4703-B9B7-AF738306CD06.html",
							"GUID-5048EC42-E9B5-4703-B9B7-AF738306CD06.html",
							"GUID-5048EC42-E9B5-4703-B9B7-AF738306CD06.html",
							"GUID-B975F912-1867-423B-9006-8E914377D12B.html",
							"GUID-B975F912-1867-423B-9006-8E914377D12B.html",
							"GUID-B975F912-1867-423B-9006-8E914377D12B.html",
							"GUID-B975F912-1867-423B-9006-8E914377D12B.html",
							"GUID-B975F912-1867-423B-9006-8E914377D12B.html",
							"GUID-377DB73D-A7BD-4394-A8AB-994F3C5308F4.html",
							"GUID-377DB73D-A7BD-4394-A8AB-994F3C5308F4.html",
							"GUID-6F443732-8F03-4525-A5EA-E0D25379C8AB.html","GUID-5E76E081-070E-46EA-86A9-EE08F3F1481F.html","GUID-80611E1C-ADA6-450A-B484-9B67D8C6BCFE.html","GUID-3D686B12-9733-42ED-A3A8-8418CBB8CFA2.html","GUID-9914BAEF-0E8A-43F0-A610-212D102107A6.html","GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-F3053C15-A0B6-4DB9-870B-B5953F0CF73D.html",
							"GUID-317A5E50-6A52-4E41-AD29-F92236737621.html","GUID-31B0123A-ACC5-421E-A0B3-EEF9FB7B3DE8.html",
							"GUID-31B0123A-ACC5-421E-A0B3-EEF9FB7B3DE8.html",
							"GUID-31B0123A-ACC5-421E-A0B3-EEF9FB7B3DE8.html",
							"GUID-31B0123A-ACC5-421E-A0B3-EEF9FB7B3DE8.html",
							"GUID-31B0123A-ACC5-421E-A0B3-EEF9FB7B3DE8.html",
							"GUID-F0D5BC61-51C6-4783-A108-9C27942DBA35.html",
							"GUID-F0D5BC61-51C6-4783-A108-9C27942DBA35.html",
							"GUID-F0D5BC61-51C6-4783-A108-9C27942DBA35.html",
							"GUID-F0D5BC61-51C6-4783-A108-9C27942DBA35.html",
							"GUID-F0D5BC61-51C6-4783-A108-9C27942DBA35.html",
							"GUID-AA422ABF-9E14-4C73-9C94-13EF0D429C4A.html",
							"GUID-AA422ABF-9E14-4C73-9C94-13EF0D429C4A.html",
							"GUID-AA422ABF-9E14-4C73-9C94-13EF0D429C4A.html",
							"GUID-AA422ABF-9E14-4C73-9C94-13EF0D429C4A.html",
							"GUID-AA422ABF-9E14-4C73-9C94-13EF0D429C4A.html",
							"GUID-37F8C718-FAC5-4D6A-8398-84BF0C1EBF5E.html",
							"GUID-37F8C718-FAC5-4D6A-8398-84BF0C1EBF5E.html",
							"GUID-37F8C718-FAC5-4D6A-8398-84BF0C1EBF5E.html",
							"GUID-37F8C718-FAC5-4D6A-8398-84BF0C1EBF5E.html",
							"GUID-37F8C718-FAC5-4D6A-8398-84BF0C1EBF5E.html",
							"GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B.html","GUID-7551DC67-D79D-4F0C-B56F-7B17E12400E0.html","GUID-CDA512D8-0DE4-4672-8716-04CAC681CB38.html","GUID-F05182E4-B102-4775-A746-1FF37F465312.html","GUID-E8251634-7B15-4073-A103-5A5F128B8699.html","GUID-125F1A93-76CC-4BD7-BACA-01844FBD5F4F.html","GUID-21750586-F9F2-4E33-87FB-8F2994BF4744.html","GUID-07985EED-D525-413B-AEFE-78B563328687.html","GUID-02A694CF-88A5-4ADA-8785-7EEEC62D66EA.html"];

var SearchTitles = ["PIC32CX-BZ Family System Services",
"PIC32CX-BZ2 System Services",
"PIC32CX-BZ2 Device Support Component Library Help",
"Device Support Library Usage",
"RF System",
"wssEnable_t Enum",
"C",
"Description",
"SYS_ClkGen_Config Function",
"C",
"Description",
"Parameters",
"Returns",
"SYS_Load_Cal Function",
"C",
"Description",
"Parameters",
"Returns",
"RF_NeedCal Function",
"C",
"Description",
"Parameters",
"Returns",
"RF_Timer_Cal Function",
"C",
"Description",
"Parameters",
"Returns",
"RF_SetIdleMode Function",
"C",
"Description",
"Parameters",
"Returns",
"Temperature_Reading Function",
"C",
"Description",
"Parameters",
"Returns",
"PMU System",
"PMU_Mode_T Enum",
"C",
"Description",
"PMU_Get_Mode Function",
"C",
"Description",
"Parameters",
"Returns",
"PMU_Set_Mode Function",
"C",
"Description",
"Parameters",
"Returns",
"PMU_ConfigCurrentSensor Function",
"C",
"Description",
"Parameters",
"Returns",
"Info Block",
"InformationBlockLoad Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetBdAddr Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetMACAddr Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetAntennaGain Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetBatVoltage2v2Sar Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetBatVoltage3v0Sar Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetRssiOffset Function",
"C",
"Description",
"Parameters",
"Returns",
"Sleep System",
"DEVICE_SLEEP_ConfigAclbClk Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_ConfigRetRam Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_ConfigRfClk Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_ConfigRfMbs Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_ConfigRfXtal Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_ConfigSubSysPllLock Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_ConfigSubSysXtalReady Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_DisableDebugBus Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SLEEP_ConfigWssLowPowerMode Function",
"C",
"Description",
"Parameters",
"Returns",
"Deep Sleep System",
"DEVICE_SetDeepSleepWakeUpSrc Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_GetDeepSleepWakeUpSrc Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_EnterExtremeDeepSleep Function",
"C",
"Description",
"Parameters",
"Parameters",
"Returns",
"DEVICE_EnterDeepSleep Function",
"C",
"Description",
"Parameters",
"Parameters",
"Parameters",
"Returns",
"DEVICE_DeepSleepWakeSrc_T Enum",
"C",
"Description",
"DEVICE_deepSleepIntervalCal Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_ClearDeepSleepReg Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL Extension for FreeRTOS",
"OSAL_QUEUE_Create Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_CreateSet Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_AddToSet Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_SelectFromSet Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_Send Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_SendISR Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_Receive Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_IsFullISR Function",
"C",
"Description",
"Parameters",
"Returns",
"App Idle Task",
"app_idle_task Function",
"C",
"Description",
"Parameters",
"Returns",
"app_idle_updateRtcCnt Function",
"C",
"Description",
"Parameters",
"Returns",
"PIC32CX-BZ2 Persistent Data Server Component Library Help",
"PDS Library Usage",
"ITEM_ID_TO_MEM_MAPPING Macro",
"C",
"Description",
"ITEM_UNDER_SECURITY_CONTROL Macro",
"C",
"Description",
"PDS_DECLARE_ITEM Macro",
"C",
"Description",
"NO_ITEM_FLAGS Macro",
"C",
"Description",
"NO_FILE_MARKS Macro",
"C",
"Description",
"PDS_MAX_FILE_SIZE Macro",
"C",
"Description",
"PDS_DIRECTORY_ID_MASK Macro",
"C",
"Description",
"SIZE_MODIFICATION_ALLOWED Macro",
"C",
"Description",
"PDS_MODULE OFFSET Macro",
"C",
"Description",
"PDS_DataServerState_t Enum",
"C",
"Description",
"ItemIdToMemoryMapping_t Struct",
"C",
"Description",
"PDS_DirDescr_t Struct",
"C",
"Description",
"PDS_Operation_Offset_t Struct",
"C",
"Description",
"PDS_UpdateMemory_t Struct",
"C",
"Description",
"PDS_AddItemExcpetionFromDeleteAll Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_Delete Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_DeleteAll Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_GetItemDescr Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_GetPendingItemsCount Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_Init Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_InitItems Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_IsAbleToRestore Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_RegisterUpdateMemoryCallback Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_RegisterWriteCompleteCallback Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_Restore Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_Store Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_StoreItemTaskHandler Function",
"C",
"Description",
"Returns",
"PIC32CX-BZ2 Bootloader Services Component Help",
"PIC32CX-BZ2 Standalone Bootloader Component Help",
"Configuration Options",
"DFU Functionality - Serial image bootloader",
"Bootloader API Usage",
"FW_IMAGE_BLOCK_SIZE Macro",
"C",
"Description",
"FW_IMAGE_EXPECTED_CONT_IDX Macro",
"C",
"Description",
"FW_IMAGE_EXPECTED_PL_LEN Macro",
"C",
"Description",
"HEADER_SIZE Macro",
"C",
"Description",
"IMG_MEM_TOPOLOGY_COUNT Macro",
"C",
"Description",
"MAX_AUTH_KEY_LEN Macro",
"C",
"Description",
"MAX_MEM_TOPOLOGIES Macro",
"C",
"Description",
"MAX_SLOTS Macro",
"C",
"Description",
"METADATA_HEADER_SIZE Macro",
"C",
"Description",
"SLOT_PARAMS Struct",
"C",
"Description",
"SLOT0_BASE_ADDR Macro",
"C",
"Description",
"SLOT0_FIRMWARE Macro",
"C",
"Description",
"SLOT0_HEADER Macro",
"C",
"Description",
"SLOT1_BASE_ADDR Macro",
"C",
"Description",
"SLOT1_FIRMWARE Macro",
"C",
"Description",
"SLOT1_HEADER Macro",
"C",
"Description",
"UNAUTH_FW_SIZE Macro",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"DEVICE_CONTEXT Struct",
"C",
"Description",
"IMG_MEM_INTERFACE Struct",
"C",
"Description",
"IMG_MEM_TOPOLOGY Struct",
"C",
"Description",
"VALID_SLOT Struct",
"C",
"Description",
"FW_IMG_HDR Struct",
"C",
"Description",
"IMG_MEM_AuthenticateHeaderStart Function",
"C",
"Description",
"Parameters",
"Returns",
"IMG_MEM_FindValidTopologies Function",
"C",
"Description",
"Parameters",
"Returns",
"IMG_MEM_SlotSort Function",
"C",
"Description",
"Parameters",
"Returns",
"IMG_MEM_ValidateHeader Function",
"C",
"Description",
"Parameters",
"Returns",
"C",
"Description",
"Parameters",
"Returns",
"IMG_MEM_AuthenticateHeaderStatusGet Function",
"C",
"Description",
"Parameters",
"Returns",
"IMG_MEM_CacheAndValidateHeaders Function",
"C",
"Description",
"Parameters",
"Returns",
"IMG_MEM_CacheHeader Function",
"C",
"Description",
"Parameters",
"Returns",
"DFU API Usage",
"dfu Function",
"C",
"Description",
"Parameters",
"Returns",
"program_exec_main Function",
"C",
"Description",
"Parameters",
"Returns",
"Crc32Init Function",
"C",
"Description",
"Parameters",
"Returns",
"Crc32Add Function",
"C",
"Description",
"Parameters",
"Returns",
"Crc32Result Function",
"C",
"Description",
"Parameters",
"Returns",
"UART_ERROR Enum",
"C",
"UART_Init Function",
"C",
"Description",
"Parameters",
"Returns",
"UART_Read Function",
"C",
"Description",
"Parameters",
"Returns",
"UART_Write Function",
"C",
"Description",
"Parameters",
"Returns",
"PIC32CX-BZ3 System Services",
"PIC32CX-BZ3 Secure Boot ROM Help",
"PIC32CX-BZ3 Secure Boot ROM Usage",
"SX_symcrypt_API",
"True Random Number Generator (TRNG)",
"TRNG_API_H Macro",
"C",
"Configuration parameters for the TRNG */",
"FIFO level below which the module leaves the idle state to refill the FIFO",
"Number of clock cycles to wait before sampling data from the noise source",
"Number of clock cycles to wait before stopping the rings after the FIFO is full",
"Clock divider for the frequency at which the outputs of the rings are sampled",
"TRNG initialization",
"SX_TRNG_INIT Macro",
"C",
"Parameters",
"Parameters",
"Get random bytes",
"Parameters",
"Parameters",
"Parameters",
"Status/error codes of sxsymcrypt functions",
"STATUSCODES_API_FILE Macro",
"C",
"The function or operation succeeded */",
"Waiting on the hardware to process this operation */",
"SX_ERR_HW_PROCESSING Macro",
"C",
"No hardware available for a new operation Retry later */",
"No compatible hardware for this operation",
"SX_ERR_INCOMPATIBLE_HW Macro",
"C",
"Invalid authentication tag in authenticated decryption */",
"Hardware DMA error",
"SX_ERR_DMA_FAILED Macro",
"C",
"Fatal error trying to call a function with an uninitialized object",
"SX_ERR_UNITIALIZED_OBJ Macro",
"C",
"Fatal error trying to call an AEAD or block cipher create function with an",
"SX_ERR_INVALID_KEYREF Macro",
"C",
"Fatal error trying to create instance with not enough memory */",
"Input or output buffer size too large */",
"SX_ERR_TOO_BIG Macro",
"C",
"Input or output buffer size too small */",
"The given key size is not supported by the algorithm or the hardware */",
"SX_ERR_INVALID_KEY_SZ Macro",
"C",
"Input tag size is invalid */",
"Input nonce size is invalid */",
"SX_ERR_INVALID_NONCE_SIZE Macro",
"C",
"Too many feeds were inputed */",
"Input data size granularity is incorrect */",
"SX_ERR_WRONG_SIZE_GRANULARITY Macro",
"C",
"Attempt to use HW keys with a mode that does not support HW keys */",
"Attempt to use a mode or engine that does not support context saving */",
"SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED Macro",
"C",
"Attempt to feed AAD after input data was fed */",
"Hardware cannot work anymore",
"Cryptographic message hashing SM3",
"SXSYMCRYPT_SM3_API_FILE Macro",
"C",
"GM/T 0004-2012: SM3 cryptographic hash algorithm */",
"Parameters",
"Parameters",
"Cryptographic message hashing SHA-2",
"SXSYMCRYPT_SHA2_API_FILE Macro",
"C",
"Hash algorithm SHA-2 224",
"SXHASHALG_SHA2_224 Macro",
"C",
"Hash algorithm SHA-2 256",
"SXHASHALG_SHA2_256 Macro",
"C",
"Hash algorithm SHA-2 384",
"SXHASHALG_SHA2_384 Macro",
"C",
"Hash algorithm SHA-2 512",
"SXHASHALG_SHA2_512 Macro",
"C",
"Prepares a SHA256 hash operation context",
"SX_HASH_CREATE_SHA256 Macro",
"C",
"Parameters",
"Parameters",
"Prepares a SHA384 hash operation context",
"SX_HASH_CREATE_SHA384 Macro",
"C",
"Parameters",
"Parameters",
"Prepares a SHA512 hash operation context",
"SX_HASH_CREATE_SHA512 Macro",
"C",
"Parameters",
"Parameters",
"Prepares a SHA224 hash operation context",
"Parameters",
"Parameters",
"Cryptographic message hashing SHA-1",
"SXSYMCRYPT_SHA1_API_FILE Macro",
"C",
"Hash algorithm SHA-1 (Secure Hash Algorithm 1)",
"SXHASHALG_SHA1 Macro",
"C",
"Prepares a SHA1 hash operation context",
"Parameters",
"Parameters",
"Common functions used for generation a MAC (message authentication code)",
"MAC_API_FILE Macro",
"C",
"Feeds data to be used for MAC generation",
"SX_MAC_FEED Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Starts MAC generation operation",
"SX_MAC_GENERATE Macro",
"C",
"Parameters",
"Parameters",
"Resumes MAC operation in context-saving",
"SX_MAC_RESUME_STATE Macro",
"C",
"Parameters",
"Starts a partial MAC operation",
"SX_MAC_SAVE_STATE Macro",
"C",
"Parameters",
"Waits until the given MAC generation operation has finished",
"SX_MAC_WAIT Macro",
"C",
"Parameters",
"Returns the MAC generation operation status",
"Parameters",
"Common function definitions for keys",
"KEYREF_API_FILE Macro",
"C",
"Returns a reference to a key whose key material is in user memory",
"SX_KEYREF_LOAD_MATERIAL Macro",
"C",
"Parameters",
"Parameters",
"Returns a reference to a key selected by an index",
"Parameters",
"Hardware interrupts",
"INTERRUPTS_API_FILE Macro",
"C",
"Prepares the hardware to use hardware interrupts",
"(FUNC_SX_INTERRUPTS_ENABLE)(void); Typedef",
"C",
"SX_INTERRUPTS_ENABLE Macro",
"C",
"Disables all hardware interrupts",
"(FUNC_SX_INTERRUPTS_DISABLE)(void); Typedef",
"C",
"INTERNAL_HEADER_FILE Macro",
"C",
"SX_EXTRA_IN_DESCS Macro",
"C",
"SX_HASH_PRIV_SZ Macro",
"C",
"SX_BLKCIPHER_PRIV_SZ Macro",
"C",
"A cryptomaster DMA descriptor */",
"Input and output descriptors and related state for cmdma */",
"DMA controller",
"Key reference",
"An AEAD operation",
"A simple block cipher operation",
"A hash operation",
"A operation to load a countermeasures mask into the hardware",
"Cryptographic HMAC(Keyed-Hash Message Authentication Code)",
"HMAC_API_FILE Macro",
"C",
"Prepares a HMAC SHA256 MAC operation",
"SX_MAC_CREATE_HMAC_SHA2_256 Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares a HMAC SHA384 MAC operation",
"SX_MAC_CREATE_HMAC_SHA2_384 Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares a HMAC SHA512 MAC operation",
"SX_MAC_CREATE_HMAC_SHA2_512 Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares a HMAC SHA1 MAC operation",
"SX_MAC_CREATE_HMAC_SHA1 Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares a HMAC SHA224 MAC operation",
"Parameters",
"Parameters",
"Parameters",
"Cryptographic message hashing",
"HASH_API_FILE Macro",
"C",
"Creates a hash operation context",
"SX_HASH_CREATE Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Return the digest size produced by the given hash algorithm */",
"Return the block size used by the given hash algorithm */",
"SX_HASH_GET_ALG_BLOCKSZ Macro",
"C",
"Resume hashing in context-saving (partial hashing)",
"SX_HASH_RESUME_STATE Macro",
"C",
"Parameters",
"Assign data to be hashed",
"SX_HASH_FEED Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Starts the partial hashing operation",
"SX_HASH_SAVE_STATE Macro",
"C",
"Parameters",
"Starts the hashing operation",
"SX_HASH_DIGEST Macro",
"C",
"Parameters",
"Parameters",
"Waits until the given hash operation has finished",
"SX_HASH_WAIT Macro",
"C",
"Parameters",
"Returns the status of the given hash operation context",
"SX_HASH_STATUS Macro",
"C",
"Parameters",
"Returns digest size in bytes for the hash operation context",
"SX_HASH_GET_DIGESTSZ Macro",
"C",
"Parameters",
"Returns block size in bytes for the hash operation context",
"SX_HASH_GET_BLOCKSZ Macro",
"C",
"Parameters",
"Abandon a created hash operation context",
"Parameters",
"AES counter-measures mask load",
"CMMASK_API_FILE Macro",
"C",
"Loads random used in the AES counter-measures",
"SX_CM_LOAD_MASK Macro",
"C",
"Parameters",
"Parameters",
"Waits until the given AES counter-measures load operation has finished",
"SX_CM_LOAD_MASK_WAIT Macro",
"C",
"Parameters",
"Returns the status of the given AES counter-measures load operation context",
"Parameters",
"Message Authentication Code AES CMAC",
"CMAC_API_FILE Macro",
"C",
"Prepares an AES CMAC generation",
"Parameters",
"Parameters",
"Common simple block cipher modes",
"BLKCIPHER_API_FILE Macro",
"C",
"Prepares an AES XTS block cipher encryption",
"SX_BLKCIPHER_CREATE_AESXTS_ENC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES XTS block cipher decryption",
"SX_BLKCIPHER_CREATE_AESXTS_DEC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES CTR block cipher encryption",
"SX_BLKCIPHER_CREATE_AESCTR_ENC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES CTR block cipher decryption",
"SX_BLKCIPHER_CREATE_AESCTR_DEC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES ECB block cipher encryption",
"SX_BLKCIPHER_CREATE_AESECB_ENC Macro",
"C",
"Parameters",
"Parameters",
"Prepares an AES ECB block cipher decryption",
"SX_BLKCIPHER_CREATE_AESECB_DEC Macro",
"C",
"Parameters",
"Parameters",
"Prepares an AES CBC block cipher encryption",
"SX_BLKCIPHER_CREATE_AESCBC_ENC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES CBC block cipher decryption",
"SX_BLKCIPHER_CREATE_AESCBC_DEC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES CFB block cipher encryption",
"SX_BLKCIPHER_CREATE_AESCFB_ENC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES CFB block cipher decryption",
"SX_BLKCIPHER_CREATE_AESCFB_DEC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES OFB block cipher encryption",
"SX_BLKCIPHER_CREATE_AESOFB_ENC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES OFB block cipher decryption",
"SX_BLKCIPHER_CREATE_AESOFB_DEC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Adds data to be encrypted/decrypted",
"SX_BLKCIPHER_CRYPT Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Starts a block cipher operation",
"SX_BLKCIPHER_RUN Macro",
"C",
"Parameters",
"Resumes AES operation in context-saving",
"SX_BLKCIPHER_RESUME_STATE Macro",
"C",
"Parameters",
"Starts a partial block cipher operation",
"SX_BLKCIPHER_SAVE_STATE Macro",
"C",
"Parameters",
"Waits until the given block cipher operation has finished",
"SX_BLKCIPHER_WAIT Macro",
"C",
"Parameters",
"Returns the block cipher operation status",
"Parameters",
"Authenticated encryption with associated data(AEAD)",
"AEAD_API_FILE Macro",
"C",
"Initialization vector (IV) size in bytes for GCM encryption/decryption */",
"Size in bytes of GCM authentication tag */",
"SX_GCM_TAG_SZ Macro",
"C",
"Maximum size in bytes of CCM authentication tag */",
"Prepares an AES GCM AEAD encryption operation",
"SX_AEAD_CREATE_AESGCM_ENC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES GCM AEAD decryption operation",
"SX_AEAD_CREATE_AESGCM_DEC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES CCM AEAD encryption operation",
"SX_AEAD_CREATE_AESCCM_ENC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Prepares an AES CCM AEAD decryption operation",
"SX_AEAD_CREATE_AESCCM_DEC Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Adds AAD chunks",
"SX_AEAD_FEED_AAD Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Adds data to be encrypted or decrypted",
"SX_AEAD_CRYPT Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Starts an AEAD encryption and tag computation",
"SX_AEAD_PRODUCE_TAG Macro",
"C",
"Parameters",
"Parameters",
"Starts an AEAD decryption and tag validation",
"SX_AEAD_VERIFY_TAG Macro",
"C",
"Parameters",
"Parameters",
"Resumes AEAD operation in context-saving",
"SX_AEAD_RESUME_STATE Macro",
"C",
"Parameters",
"Starts a partial AEAD operation",
"SX_AEAD_SAVE_STATE Macro",
"C",
"Parameters",
"Waits until the given AEAD operation has finished",
"SX_AEAD_WAIT Macro",
"C",
"Parameters",
"Returns the AEAD operation status",
"Parameters",
"Silex_PK_API",
"\"sxops\" interface to read write operands from/to memory",
"ADAPTER_HEADER_FILE Macro",
"C",
"Write the operand into memory filling 'sz' bytes 0-pading if needed",
"(FUNC_SX_PK_OP2MEM_LE)(const Typedef",
"C",
"SX_PK_OP2MEM_LE Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Write the operand into memory filling 'sz' bytes 0-pading if needed",
"(FUNC_SX_PK_OP2MEM_BE)(const Typedef",
"C",
"SX_PK_OP2MEM_BE Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Write the operand into memory filling 'sz' bytes 0-pading if needed",
"(FUNC_SX_PK_OP2MEM)(const Typedef",
"C",
"SX_PK_OP2MEM Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Write the operand into memory which has the exact size needed",
"(FUNC_SX_PK_OP2VMEM_LE)(const Typedef",
"C",
"SX_PK_OP2VMEM_LE Macro",
"C",
"Parameters",
"Parameters",
"Write the operand into memory which has the exact size needed",
"(FUNC_SX_PK_OP2VMEM_BE)(const Typedef",
"C",
"SX_PK_OP2VMEM_BE Macro",
"C",
"Parameters",
"Parameters",
"Write the operand into memory which has the exact size needed",
"(FUNC_SX_PK_OP2VMEM)(const Typedef",
"C",
"SX_PK_OP2VMEM Macro",
"C",
"Parameters",
"Parameters",
"Convert raw little endian bytes format to operand",
"(FUNC_SX_PK_MEM2OP_LE)(const Typedef",
"C",
"SX_PK_MEM2OP_LE Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Convert raw big endian bytes format to operand",
"(FUNC_SX_PK_MEM2OP_BE)(const Typedef",
"C",
"SX_PK_MEM2OP_BE Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Convert raw bytes to operand",
"(FUNC_SX_PK_MEM2OP)(const Typedef",
"C",
"SX_PK_MEM2OP Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Return the size in bytes of the operand",
"(FUNC_SX_OP_SIZE)(const Typedef",
"C",
"Parameters",
"Asymmetric cryptographic command definitions",
"CMDDEFS_HEADER_FILE Macro",
"C",
"SX_PK_CMD_MOD_ADD Macro",
"C",
"Modular substraction of operands A and B */",
"Modular multiplication of operands A and B with odd modulo */",
"SX_PK_CMD_ODD_MOD_MULT Macro",
"C",
"Modular inversion of an operand with even modulo */",
"Modular inversion of an operand with even modulo */",
"SX_PK_CMD_EVEN_MOD_REDUCE Macro",
"C",
"Modular reduction of an operand with odd modulo */",
"Modular division of operands A and B with odd modulo */",
"SX_PK_CMD_ODD_MOD_DIV Macro",
"C",
"Modular inversion of an operand with odd modulo */",
"Modular square root **/",
"SX_PK_CMD_MOD_SQRT Macro",
"C",
"Multiplication **/",
"Modular exponentiation operation */",
"SX_PK_CMD_MOD_EXP Macro",
"C",
"Diffie Hellman modular exponentiation operation with countermeasures",
"SX_PK_CMD_DH_MOD_EXP_CM Macro",
"C",
"RSA modular exponentiation operation with countermeasures*/",
"Modular exponentiation operation (for RSA) with Chinese Remainder Theorem */",
"SX_PK_CMD_MOD_EXP_CRT Macro",
"C",
"Modular exponentiation operation (for RSA) with Chinese Remainder Theorem",
"SX_PK_CMD_MOD_EXP_CRT_CM Macro",
"C",
"RSA private key including lambda(n) computation from primes",
"SX_PK_CMD_RSA_KEYGEN Macro",
"C",
"RSA CRT private key parameters computation */",
"Montgomery point multiplication for X25519 and X448",
"SX_PK_CMD_MONTGOMERY_PTMUL Macro",
"C",
"Elliptic curve ECDSA signature verification operation */",
"Elliptic curve ECDSA signature generation operation */",
"SX_PK_CMD_ECDSA_GEN Macro",
"C",
"Elliptic curve point addition operation */",
"Elliptic curve point multiplication operation */",
"SX_PK_CMD_ECC_PTMUL Macro",
"C",
"Elliptic curve point multiplication operation with countermeasures */",
"Elliptic curve point decompression operation */",
"SX_PK_CMD_ECC_PT_DECOMP Macro",
"C",
"Elliptic curve check parameters a b */",
"Elliptic curve check parameter n = p */",
"SX_PK_CMD_CHECK_PARAM_N Macro",
"C",
"Elliptic curve check x y point p */",
"Elliptic curve point doubling */",
"SX_PK_CMD_ECC_PT_DOUBLE Macro",
"C",
"Elliptic curve point on curve check */",
"EDDSA point multiplication operation",
"SX_PK_CMD_EDDSA_PTMUL Macro",
"C",
"EDDSA 2nd part of signature operation",
"SX_PK_CMD_EDDSA_SIGN Macro",
"C",
"EDDSA signature verification operation",
"SX_PK_CMD_EDDSA_VER Macro",
"C",
"DSA signature generation */",
"DSA signature verification */",
"SX_PK_CMD_DSA_VER Macro",
"C",
"Asymmetric cryptographic acceleration core interface",
"CORE_HEADER_FILE Macro",
"C",
"Default operand endianness",
"SX_PK_OP_DEFAULT_ENDIANNESS Macro",
"C",
"struct Function",
"C",
"Acceleration request",
"Struct",
"C",
"Return SilexPK constraints",
"SX_PK_LIST_CONSTRAINTS Macro",
"C",
"Parameters",
"Parameters",
"Description of the (hardware) accelerator capabilities and features */",
"Maximum pending requests at any time */",
"Maximum operand size for prime field operands 0 when not supported */",
"Maximum operand size for elliptic curve operands 0 when not supported */",
"Maximum operand size for binary field operands 0 when not supported */",
"Operand size for IK operands 0 when not supported */",
"Opaque structure for offload with SilexPK library */",
"Return the crypto acceleration capabilities and features",
"SX_PK_FETCH_CAPABILITIES Macro",
"C",
"Parameters",
"Library configuration for SX_PK_OPEN() */",
"Maximum simultaneous requests the application will start",
"Device index to use",
"User memory */",
"Size of user provided memory */",
"Personalization string for IK */",
"Personalization string size in 32 bit words",
"Open SilexPK and related hardware and allocate internal resources",
"SX_PK_OPEN Macro",
"C",
"Parameters",
"Finish using any public key acceleration",
"SX_PK_CLOSE Macro",
"C",
"Parameters",
"Encapsulated acceleration request",
"The acquired acceleration request **/",
"The status of SX_PK_ACQUIRE_REQ() **/",
"Get a SilexPK request instance locked to perform the given operation",
"SX_PK_ACQUIRE_REQ Macro",
"C",
"Parameters",
"Parameters",
"Least significant bit of Ax is 1 (flag A) */",
"Least significant bit of Rx is 1 (flag B) */",
"PK_OP_FLAGS_EDDSA_RX_LSB Macro",
"C",
"Return the instance number of the hardware accelerator for this request",
"int Typedef",
"C",
"SX_PK_GET_REQ_ID Macro",
"C",
"Parameters",
"Add the context pointer to an acceleration request",
"(FUNC_SX_PK_SET_USER_CONTEXT)(sx_pk_accel Typedef",
"C",
"SX_PK_SET_USER_CONTEXT Macro",
"C",
"Parameters",
"Parameters",
"Get the context pointer from an acceleration request",
"(FUNC_SX_PK_GET_USER_CONTEXT)(sx_pk_accel Typedef",
"C",
"SX_PK_GET_USER_CONTEXT Macro",
"C",
"Parameters",
"Return the global operands size detected for the request",
"(FUNC_SX_PK_GET_OPSIZE)(sx_pk_accel Typedef",
"C",
"SX_PK_GET_OPSIZE Macro",
"C",
"Parameters",
"Operand slot structure */",
"Memory address of the operand slot **/",
"Pair of slots",
"First slot **/",
"Second slot **/",
"List slots for input operands for an ECC operation",
"SX_PK_LIST_ECC_INSLOTS Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"List slots for input operands for a GF(p) modular operation",
"SX_PK_LIST_GFP_INSLOTS Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Run the operation request in hardware",
"(FUNC_SX_PK_RUN)(sx_pk_accel Typedef",
"C",
"SX_PK_RUN Macro",
"C",
"Parameters",
"Check if the current operation is still ongoing or finished",
"(FUNC_SX_PK_GET_STATUS)(sx_pk_accel Typedef",
"C",
"SX_PK_GET_STATUS Macro",
"C",
"Parameters",
"Legacy name of SX_PK_GET_STATUS() **/",
"Wait until the current operation finishes",
"(FUNC_SX_PK_WAIT)(sx_pk_accel Typedef",
"C",
"SX_PK_WAIT Macro",
"C",
"Parameters",
"Clear the interrupt request signal",
"(FUNC_SX_PK_CLEAR_IRQ)(void); Typedef",
"C",
"SX_PK_CLEARIRQ Macro",
"C",
"Return the public key acceleration request which finished its operation",
"SX_PK_POP_FINISHED_REQ Macro",
"C",
"Parameters",
"Return a platform notification that notifies when a request completed",
"SX_PK_GET_GLOBAL_NOTIFICATION_ID Macro",
"C",
"Parameters",
"Legacy name of SX_PK_GET_GLOBAL_NOTIFICATION_ID() **/",
"Return a platform notification id of completion of this request",
"(FUNC_SX_PK_GET_REQ_COMPLETION_ID)(sx_pk_accel Typedef",
"C",
"SX_PK_GET_REQ_COMPLETION_ID Macro",
"C",
"Parameters",
"Fetch array of addresses to output operands",
"char Typedef",
"C",
"SX_PK_GET_OUTPUT_OPS Macro",
"C",
"Parameters",
"Give back the public key acceleration request",
"(FUNC_SX_PK_RELEASE_REQ)(sx_pk_accel Typedef",
"C",
"SX_PK_RELEASE_REQ Macro",
"C",
"Parameters",
"Elliptic curve configuration and parameters",
"\"sxops\" interface for DSA cryptographic computations",
"DSA_HEADER_FILE Macro",
"C",
"Make sure the application is compatible with SilexPK API version **/",
"Asynchronous (non-blocking) DSA signature generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"DSA signature generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) DSA signature verification",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"DSA signature verification",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Predefined and custom elliptic curve definitions",
"EC_CURVES_HEADER_FILE Macro",
"C",
"int Function",
"C",
"Slots to write custom curve parameters into */",
"Create a prime elliptic curve",
"SX_PK_CREATE_ECP_CURVE Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Create a binary elliptic curve",
"SX_PK_CREATE_ECB_CURVE Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Destroy a custom ecp or ecb curve",
"SX_PK_DESTROY_EC_CURVE Macro",
"C",
"Parameters",
"Get a reference to the predefined NIST P192 elliptic curve",
"SX_PK_GET_CURVE_NISTP192 Macro",
"C",
"Parameters",
"Get a reference to the predefined NIST P256 elliptic curve",
"SX_PK_GET_CURVE_NISTP256 Macro",
"C",
"Parameters",
"Get a reference to the predefined NIST P384 elliptic curve",
"SX_PK_GET_CURVE_NISTP384 Macro",
"C",
"Parameters",
"Get a reference to the predefined NIST P521 elliptic curve",
"SX_PK_GET_CURVE_NISTP521 Macro",
"C",
"Parameters",
"Get a reference to the predefined ED25519 elliptic curve",
"SX_PK_GET_CURVE_ED25519 Macro",
"C",
"Parameters",
"Get a reference to the predefined ED448 elliptic curve",
"SX_PK_GET_CURVE_ED448 Macro",
"C",
"Parameters",
"Get a reference to the predefined X25519 elliptic curve",
"SX_PK_GET_CURVE_X25519 Macro",
"C",
"Parameters",
"Get a reference to the predefined X448 elliptic curve",
"SX_PK_GET_CURVE_X448 Macro",
"C",
"Parameters",
"Get a reference to the predefined SEC p256k1 elliptic curve",
"SX_PK_GET_CURVE_SECP256K1 Macro",
"C",
"Parameters",
"Get a reference to the predefined fp256 elliptic curve",
"SX_PK_GET_CURVE_FP256 Macro",
"C",
"Parameters",
"Write the generator point of the curve into the slots (internal)",
"SX_PK_WRITE_CURVE_GEN Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Return the operand size in bytes for the given curve",
"SX_PK_CURVE_OPSIZE Macro",
"C",
"Parameters",
"\"sxops\" interface for Weierstrass elliptic curve computations",
"ECCWEIERSTRASS_HEADER_FILE Macro",
"C",
"Make sure the application is compatible with SilexPK API version **/",
"inline",
"C",
"Curve generator point for sx_ecp_ptmult() or sx_async_ecp_mult_go() */",
"SX_PTMULT_CURVE_GENERATOR Macro",
"C",
"inline",
"C",
"Asynchronous ECDSA signature generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) ECDSA generation",
"Parameters",
"Parameters",
"Parameters",
"Generate an ECDSA signature on an elliptic curve",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) ECDSA verification",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Verify ECDSA signature on an elliptic curve",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"@} */",
"inline",
"C",
"Asynchronous EC point multiplication",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous EC point multiplication",
"Parameters",
"Parameters",
"Parameters",
"Compute point multiplication on an elliptic curve",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous EC point doubling",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous EC point doubling",
"Parameters",
"Parameters",
"Parameters",
"Compute point doubling on an elliptic curve",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) EC point on curve check",
"Parameters",
"Parameters",
"Parameters",
"Check if the given point is on the given elliptic curve",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) EC point decompression",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) EC point decompression",
"Parameters",
"Parameters",
"ECC point decompression",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"@addtogroup SX_PK_SXOPS_ECOPS",
"Asynchronous (non-blocking) EC point addition",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) EC point addition",
"Parameters",
"Parameters",
"Parameters",
"Compute point addition on an elliptic curve",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"\"sxops\" interface for EC J-PAKE computations",
"ECJPAKE_HEADER_FILE Macro",
"C",
"Make sure the application is compatible with SilexPK API version **/",
"sx_pk_point Function",
"C",
"Curve generator point for sx_ecjpake_verify_zkp() or sx_ecjpake_verify_zkp_go() */",
"Affine point parameter group",
"Asynchronous EC J-PAKE proof generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) EC J-PAKE proof generation",
"Parameters",
"Parameters",
"Perform an EC J-PAKE proof generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous EC J-PAKE proof verification",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) EC J-PAKE proof verification",
"Parameters",
"Synchronous EC J-PAKE proof verification",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous EC J-PAKE 3 point addition",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) EC J-PAKE 3 point addition",
"Parameters",
"Parameters",
"Synchronous EC J-PAKE 3 point addition",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous EC J-PAKE session key generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) EC J-PAKE session key generation",
"Parameters",
"Parameters",
"Synchronous EC J-PAKE session key generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous EC J-PAKE step 2 calculation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish an asynchronous (non-blocking) EC J-PAKE step 2 calculation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Synchronous EC J-PAKE step 2 calculation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Simpler functions for base ED25519 operations",
"ED25519_HEADER_FILE Macro",
"C",
"Size in bytes of a reduced value in ED25519 operations */",
"Size in bytes of an encoded ED25519 point */",
"SX_ED25519_PT_SZ Macro",
"C",
"Size in bytes of a digest in ED25519 operations */",
"SX_ED25519_DGST_SZ Macro",
"C",
"An encoded ED25519 point */",
"Bytes array representing encoded point for ED25519 **/",
"A ED25519 scalar value */",
"Bytes array representing scalar for ED25519 **/",
"A hash digest used in the ED25519 protocol */",
"Bytes array of hash digest **/",
"EDDSA point multiplication (ED25519)",
"SX_ED25519_PTMULT Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous EDDSA point multiplication (ED25519)",
"SX_ASYNC_ED25519_PTMULT_GO Macro",
"C",
"Parameters",
"Parameters",
"Collect the result of asynchronous EDDSA point multiplication (ED25519)",
"SX_ASYNC_ED25519_PTMULT_END Macro",
"C",
"Parameters",
"Parameters",
"Compute signature scalar s for pure EDDSA (ED25519)",
"SX_ED25519_SIGN Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous second part signature generation for pure EDDSA (ED25519)",
"SX_PK_ASYNC_ED25519_SIGN_GO Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Collect the result of asynchronous computation of ED25519 signature scalar",
"SX_ASYNC_ED25519_SIGN_END Macro",
"C",
"Parameters",
"Parameters",
"Verify an EDDSA signature (ED25519)",
"SX_ED25519_VERIFY Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) verify an ED25519 signature",
"SX_ASYNC_ED25519_VERIFY_GO Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Simpler functions for base ED448 operations",
"ED448_HEADER_FILE Macro",
"C",
"Size in bytes of a reduced value in ED448 operations */",
"Size in bytes of an encoded ED448 point */",
"SX_ED448_PT_SZ Macro",
"C",
"Size in bytes of a digest in ED448 operations */",
"SX_ED448_DGST_SZ Macro",
"C",
"An encoded ED448 point */",
"Bytes array representing encoded point for ED448 **/",
"A ED448 scalar value */",
"Bytes array representing scalar for ED448 **/",
"A hash digest used in the ED448 protocol */",
"Bytes array of hash digest **/",
"EDDSA point multiplication (ED448)",
"SX_ED448_PTMULT Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous EDDSA point multiplication (ED448)",
"SX_ASYNC_ED448_PTMULT_GO Macro",
"C",
"Parameters",
"Parameters",
"Collect the result of asynchronous EDDSA point multiplication (ED448)",
"SX_ASYNC_ED448_PTMULT_END Macro",
"C",
"Parameters",
"Parameters",
"Compute signature scalar s for pure EDDSA (ED448)",
"SX_ED448_SIGN Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous second part signature generation for pure EDDSA (ED448)",
"SX_PK_ASYNC_ED448_SIGN_GO Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Collect the result of asynchronous computation of ED448 signature scalar",
"SX_ASYNC_ED448_SIGN_END Macro",
"C",
"Parameters",
"Parameters",
"Verify an EDDSA signature (ED448)",
"SX_ED448_VERIFY Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) verify an ED448 signature",
"SX_ASYNC_ED448_VERIFY_GO Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"\"sxops\" interface to finalise acceleration requests",
"SXOPS_IMPL_HEADER_FILE Macro",
"C",
"Make sure the application is compatible with SilexPK API version **/",
"Finish an operation with one result operands",
"Parameters",
"Parameters",
"Finish an operation with two result operands",
"Parameters",
"Parameters",
"Parameters",
"Finish an operation with four result operands",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Input slots for operations",
"INPUTSLOTS_HEADER_FILE Macro",
"C",
"Input slots for ::SX_PK_CMD_ODD_MOD_INV ::SX_PK_CMD_ODD_MOD_REDUCE",
"Input slots for ::SX_PK_CMD_MOD_ADD ::SX_PK_CMD_MOD_SUB",
"Input slots for ::SX_PK_CMD_MULT */",
"Input slots for ::SX_PK_CMD_MOD_EXP */",
"Input slots for ::SX_PK_CMD_RSA_MOD_EXP_CM */",
"Input slots for ::SX_PK_CMD_MOD_EXP_CRT */",
"Input slots for ::SX_PK_CMD_RSA_KEYGEN */",
"Input slots for ::SX_PK_CMD_RSA_CRT_KEYPARAMS */",
"Input slots for ::SX_PK_CMD_SRP_USER_KEY_GEN */",
"Input slots for ::SX_PK_CMD_ECKCDSA_SIGN */",
"Input slots for ::SX_PK_CMD_MONTGOMERY_PTMUL */",
"Input slots for ::SX_PK_CMD_ECC_PT_ADD */",
"Input slots for ::SX_PK_CMD_ECC_PTMUL */",
"Input slots for ::SX_PK_CMD_ECC_PT_DOUBLE */",
"Input slots for ::SX_PK_CMD_ECC_PTONCURVE */",
"Input slots for ::SX_PK_CMD_ECC_PT_DECOMP */",
"Input slots for ::SX_PK_CMD_ECDSA_VER",
"Input slots for ::SX_PK_CMD_ECDSA_GEN ::SX_PK_CMD_SM2_GEN */",
"Input slots for ::SX_PK_CMD_SM2_EXCH */",
"Input slots for ::SX_PK_CMD_ECKCDSA_PUBKEY_GEN */",
"Input slots for ::SX_PK_CMD_EDDSA_PTMUL */",
"Input slots for ::SX_PK_CMD_EDDSA_SIGN */",
"Input slots for ::SX_PK_CMD_EDDSA_VER */",
"Input slots for ::SX_PK_CMD_MILLER_RABIN */",
"Input slots for ::SX_PK_CMD_DSA_SIGN */",
"Input slots for ::SX_PK_CMD_DSA_VER */",
"Input slots for ::SX_PK_CMD_SM9_EXP */",
"Input slots for ::SX_PK_CMD_SM9_PMULG1 */",
"Input slots for ::SX_PK_CMD_SM9_PMULG2 */",
"Input slots for ::SX_PK_CMD_SM9_PAIR */",
"Input slots for ::SX_PK_CMD_SM9_PRIVSIGKEYGEN */",
"Input slots for ::SX_PK_CMD_SM9_SIGNATUREGEN */",
"Input slots for ::SX_PK_CMD_SM9_SIGNATUREVERIFY */",
"Input slots for ::SX_PK_CMD_SM9_PRIVENCRKEYGEN */",
"Input slots for ::SX_PK_CMD_SM9_SENDKEY */",
"Input slots for ::SX_PK_CMD_SM9_REDUCEH */",
"Input slots for ::SX_PK_CMD_ECJPAKE_GENERATE_ZKP */",
"Input slots for ::SX_PK_CMD_ECJPAKE_VERIFY_ZKP */",
"Input slots for ::SX_PK_CMD_ECJPAKE_3PT_ADD */",
"Input slots for ::SX_PK_CMD_ECJPAKE_GEN_STEP_2 */",
"Input slots for ::SX_PK_CMD_ECJPAKE_GEN_SESS_KEY */",
"Inputs slots for ::SX_PK_CMD_SRP_SERVER_PUBLIC_KEY_GEN */",
"Inputs slots for ::SX_PK_CMD_SRP_SERVER_SESSION_KEY_GEN */",
"Inputs slots for ::SX_PK_CMD_CHECK_PARAM_AB */",
"Inputs slots for ::SX_PK_CMD_CHECK_PARAM_N */",
"INTERNAL_HEADER_FILE_PK Macro",
"C",
"Memory operation functions",
"IOMEM_HEADER_FILE Macro",
"C",
"Clear device memory",
"Parameters",
"Parameters",
"Write src to device memory at dst",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Simpler functions for base Montgomery elliptic curve operations",
"MONTGOMERY_HEADER_FILE Macro",
"C",
"Size in bytes of a point on X25519 curve */",
"Size in bytes of a point on X448 curve */",
"SX_X448_PT_SZ Macro",
"C",
"An X25519 point */",
"Bytes array representation of a X25519 point **/",
"An X448 point */",
"Bytes array representation of a X448 point **/",
"Montgomery point multiplication (X25519)",
"SX_X25519_PTMULT Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous Montgomery point multiplication (X25519)",
"SX_ASYNC_X25519_PTMULT_GO Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Collect the result of asynchronous Montgomery point multiplication (X25519)",
"SX_ASYNC_X25519_PTMULT_END Macro",
"C",
"Parameters",
"Parameters",
"Montgomery point multiplication (X448)",
"SX_X448_PTMULT Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous Montgomery point multiplication (X448)",
"SX_ASYNC_X448_PTMULT_GO Macro",
"C",
"Parameters",
"Parameters",
"Parameters",
"Collect the result of asynchronous Montgomery point multiplication (X448)",
"SX_ASYNC_X448_PTMULT_END Macro",
"C",
"Parameters",
"Parameters",
"\"sxops\" interface for RSA and GF(p) cryptographic computations",
"RSA_HEADER_FILE Macro",
"C",
"Make sure the application is compatible with SilexPK API version **/",
"inline",
"C",
"Asynchronous (non-blocking) Primitive modular operation with 1 operand",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Compute single operand modular operation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) Primitive modular operation with 2 operands",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Primitive modular operation with 2 operands",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) mod inversion",
"Parameters",
"Parameters",
"Parameters",
"Compute modular inversion",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) modular exponentiation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) modular exponentiation",
"Parameters",
"Parameters",
"Compute modular exponentiation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"@} */",
"inline",
"C",
"Asynchronous (non-blocking) modular exponentiation with CRT",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) modular exponentiation with CRT",
"Parameters",
"Parameters",
"Compute modular exponentiation with CRT",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) RSA private key generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) RSA private key generation",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Compute RSA private key and lambda_n from primes p and q",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Asynchronous (non-blocking) RSA CRT private key parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Finish asynchronous (non-blocking) RSA CRT private key parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Compute RSA CRT private key parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"Parameters",
"SilexPK status codes",
"SX_PK_STATUSCODES_HEADER_FILE Macro",
"C",
"SX_ERR_IK_MODE Function",
"C",
"The function or operation succeeded */",
"The function or operation was given an invalid parameter */",
"SX_ERR_INVALID_PARAM Macro",
"C",
"Unknown error */",
"The operation is still executing */",
"SX_ERR_BUSY Macro",
"C",
"The input operand is not a quadratic residue */",
"The input value for Rabin-Miller test is a composite value */",
"SX_ERR_COMPOSITE_VALUE Macro",
"C",
"Inversion of non-invertible value */",
"The signature is not valid",
"SX_ERR_INVALID_SIGNATURE Macro",
"C",
"The functionality or operation is not supported */",
"The output operand is a point at infinity */",
"SX_ERR_POINT_AT_INFINITY Macro",
"C",
"The input value is outside the expected range */",
"The modulus has an unexpected value",
"SX_ERR_INVALID_MODULUS Macro",
"C",
"The input point is not on the defined elliptic curve */",
"The input operand is too large */",
"SX_ERR_OPERAND_TOO_LARGE Macro",
"C",
"A platform specific error */",
"The evaluation period for the product expired */",
"SX_ERR_EXPIRED Macro",
"C",
"The hardware is still in IK mode",
"SX_ERR_IK_MODE Macro",
"C",
"The parameters of the elliptic curve are not valid */",
"Return a brief text string describing the given status code",
"char Typedef",
"C",
"SX_DESCRIBE_STATUSCODE Macro",
"C",
"Parameters",
"Basic \"sxops\" operand definition",
"ADAPTER_TYPES_HEADER Macro",
"C",
"Basic operand representation **/",
"Size in bytes of operand **/",
"Memory of operand bytes in big endian **/",
"Simple \"sxops\" implementation based on sx_buf**/",
"Semantic version numbers of the SilexPK API",
"SX_PK_VERSION_HEADER_FILE Macro",
"C",
"Major version number of the SilexPK API",
"SX_PK_API_MAJOR Macro",
"C",
"Minor version number of the SilexPK API",
"SX_PK_API_MINOR Macro",
"C",
"Check application has compatible version numbers",
"SX_PK_API_IS_COMPATIBLE(appmajor Macro",
"C",
"Assert that the application is compatible with the library",
"SX_PK_API_ASSERT_COMPATIBLE(appmajor Macro",
"C",
"PIC32CX-BZ3 Device Support Component Library Help",
"Device Support Library Usage",
"RF System",
"wssEnable_t Enum",
"C",
"SYS_ClkGen_Config Function",
"C",
"Description",
"Parameters",
"Returns",
"SYS_Load_Cal Function",
"C",
"Description",
"Parameters",
"Returns",
"RF_NeedCal Function",
"C",
"Description",
"Parameters",
"Returns",
"RF_Timer_Cal Function",
"C",
"Description",
"Parameters",
"Returns",
"RF_SetIdleMode Function",
"C",
"Description",
"Parameters",
"Returns",
"Temperature_Reading Function",
"C",
"Description",
"Parameters",
"Returns",
"PMU System",
"PMU_Mode_T Enum",
"C",
"PMU_Get_Mode Function",
"C",
"Description",
"Parameters",
"Returns",
"PMU_Set_Mode Function",
"C",
"Description",
"Parameters",
"Returns",
"PMU_ConfigCurrentSensor Function",
"C",
"Description",
"Parameters",
"Returns",
"Info Block",
"IB_GetAdcTiming Function",
"C",
"Description",
"Parameters",
"Parameters",
"Returns",
"IB_GetBdAddr Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetMACAddr Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetAntennaGain Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetBatVoltage2v2Sar Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetBatVoltage3v0Sar Function",
"C",
"Description",
"Parameters",
"Returns",
"IB_GetRssiOffset Function",
"C",
"Description",
"Parameters",
"Returns",
"Deep Sleep System",
"DEVICE_ClearDeepSleepReg Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_DeepSleepIntervalCal Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_EnterDeepSleep Function",
"C",
"Description",
"Parameters",
"Parameters",
"Parameters",
"Returns",
"DEVICE_EnterExtremeDeepSleep Function",
"C",
"Description",
"Parameters",
"Parameters",
"Returns",
"DEVICE_GetDeepSleepWakeUpSrc Function",
"C",
"Description",
"Parameters",
"Returns",
"DEVICE_SetDeepSleepWakeUpSrc Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL Extension for FreeRTOS",
"OSAL_QUEUE_Create Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_CreateSet Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_AddToSet Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_SelectFromSet Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_Send Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_SendISR Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_Receive Function",
"C",
"Description",
"Parameters",
"Returns",
"OSAL_QUEUE_IsFullISR Function",
"C",
"Description",
"Parameters",
"Returns",
"App Idle Task",
"app_idle_task Function",
"C",
"Description",
"Parameters",
"Returns",
"app_idle_updateRtcCnt Function",
"C",
"Description",
"Parameters",
"Returns",
"PIC32CX-BZ3 Persistent Data Server Component Library Help",
"PDS Library Usage",
"PDS_AddItemExcpetionFromDeleteAll Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_DataServerState_t Enum",
"C",
"PDS_DECLARE_ITEM(item Macro",
"C",
"PDS_Delete Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_DeleteAll Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_DirDescr_t Struct",
"C",
"PDS_DIRECTORY_ID_MASK Function",
"C",
"PDS_DIRECTORY_ID_MASK Macro",
"C",
"PDS_GetItemDescr Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_GetPendingItemsCount Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_Init Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_InitItems Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_IsAbleToRestore Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_IsAbleToStore Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_MAX_FILE_SIZE Macro",
"C",
"PDS_MemId_t Typedef",
"C",
"PDS_MODULE_APP_OFFSET Function",
"C",
"PDS_MODULE_APP_OFFSET Macro",
"C",
"PDS_MODULE_BT_OFFSET Macro",
"C",
"PDS_MODULE_RES_OFFSET Macro",
"C",
"PDS_MODULE_ZB_OFFSET Macro",
"C",
"PDS_Operation_Offset_t Struct",
"C",
"PDS_RegisterUpdateMemoryCallback Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_RegisterWriteCompleteCallback Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_Restore Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_Store Function",
"C",
"Description",
"Parameters",
"Returns",
"PDS_StoreItemTaskHandler Function",
"C",
"Description",
"Parameters",
"Returns",
"SIZE_MODIFICATION_ALLOWED Macro",
"C",
"PIC32CX-BZ3 Boot Services Help",
"PIC32CX-BZ3 Standalone Bootloader Component Help",
"Configuration Options",
"DFU Functionality - Serial image bootloader",
"Bootloader API Usage",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"AUTH_STATUS Enum",
"C",
"Description",
"DFU API Usage",
"Crc32Add Function",
"C",
"Description",
"Parameters",
"Returns",
"Crc32Init Function",
"C",
"Description",
"Parameters",
"Returns",
"Crc32Result Function",
"C",
"Description",
"Parameters",
"Returns",
"dfu Function",
"C",
"Description",
"Parameters",
"Returns",
"Microchip Information",
"The Microchip Website",
"Product Change Notification Service",
"Customer Support",
"Microchip Devices Code Protection Feature",
"Legal Notice",
"Trademarks",
"Quality Management System",
"Worldwide Sales and Service"];

var SearchInfo = [" PIC32CX-BZ Family System Services  The PIC32CX-BZ System services provides several services to protocol developers and application users which use PIC32CX-BZ products   It gives common system services like device driver library persistence data server library standalone bootloader and Bootloader services These services are created as components in Harmony 3  Secure Boot ROM: The Boot ROM allows to ensure the integrity of the device at boot *Note: Not supported on all devices  Device Support Library: This service provides help on the Device Support library that can be used as interface with RF System PMU System Info Block and Sleep System  Persistent Data Server Library: This service provides help on the PDS library that can be used for storing and restoring of important data in non-volatile memory using wear leveling mechanism  Standalone Bootloader: This service provides help on the Standalone Bootloader component that can be used to upgrade firmware on a target device without the need for an external programmer or debugger  Bootloader Services: This service provides help on the OTA Services that can be used to create signed firmware image for OTA with the provided header and OTA header information  ",
							" PIC32CX-BZ2 System Services  This page has the necessary supporting documentation to get started with application development on PIC32CX-BZ2 and WBZ45x Family of devices  ",
							" PIC32CX-BZ2 Device Support Component Library Help The PIC32CX-BZ2 Device Support Component Library provides software API's for various subsystems in the PIC32CX-BZ2  These systems include:  RF System - Helps in initialization calibration and other activities for using RF Sub system  PMU System - Helps in setting various power modes available in the PMU System  Information Block - Helps in getting the factory default values of information like device/MAC address ADC value temperature etc  Sleep System - Helps to enter or exit the sleep modes supported by the system  Deep Sleep System - Helps configure and enter deep sleep modes supported by the system   Additionally device component includes the following two services as sources  OSAL(Operating System Abstraction Layer) Extension for FreeRTOS  Application Idle task service   ",
							" Device Support Library Usage  Configuring the library  There is no configuration for this library  Device Support Libraries groups classification   RF System  PMU System  Information Base  Sleep System  Deep Sleep System   Using the library - An Example  When the device is first powered on the system will be calibrated with its factory settings by calling:  SYS_Load_Cal();  Similarly other API’s can be used Refer API information for more details on its description and usage  ",
							" RF System RF System helps in initialization calibration and other activities for using RF Sub system  The major routines of RF System   Configuring RF system clock that will be fed into the MCU clock  Loading system calibration values for RF system  Helps to check whether the RF needs to be calibrated or not  RF Calibration based on timer event  Reading current temperature ADC value   ",
							" wssEnable_t Enum ",
							" C typedef enum { WSS_ENABLE_NONE //None WSS_ENABLE_BLE // BLE Enable WSS_ENABLE_ZB // Zigbee Enable WSS_ENABLE_BLE_ZB //BLE and Zigbee Enable }wssEnable_t; ",
							" Description Wireless Subsystem Enable Flag ",
							" SYS_ClkGen_Config Function ",
							" C void SYS_ClkGen_Config(void); ",
							" Description This routine will configure the RF system clock that feeds the MCU ",
							" Parameters None ",
							" Returns None ",
							" SYS_Load_Cal Function ",
							" C void SYS_Load_Cal(wssEnable_t wssEnable); ",
							" Description This routine will load the System calibration values for the RF and PMU subsystems The main functions are RF initialization BLE Modem initialization load Calibration data from IB VCO coarse tune (ACLB) and Initialize Arbiter ",
							" Parameters Param Description wssEnable_t wssEnable wireless subsystem enable flag 0: None 1: BLE enable 2: ZB enable 3: BLE enable ZB enable ",
							" Returns None ",
							" RF_NeedCal Function ",
							" C bool RF_NeedCal(void); ",
							" Description This routine will decide if RF need to be calibrated current method is a default 60 sec timer to trigger calibration ",
							" Parameters None ",
							" Returns A boolean value: True means RF need to be calibrated False means RF doesn't need to be calibrated ",
							" RF_Timer_Cal Function ",
							" C void RF_Timer_Cal(wssEnable_t wssEnable); ",
							" Description This routine will calibrate the RF from a Timer event condition The main functions are TX_Power_Compensation and RSSI_ED_Compensation which are compensation over temperature Since temperature may change over time user can choose do RF_Timer_Cal over time ",
							" Parameters Param Description wssEnable_t wssEnable wireless subsystem enable flag 0: None 1: BLE enable 2: ZB enable 3: BLE enable ZB enable ",
							" Returns None ",
							" RF_SetIdleMode Function ",
							" C void RF_SetIdleMode(void); ",
							" Description This routine will the RF subsystem as idle mode ",
							" Parameters None ",
							" Returns None ",
							" Temperature_Reading Function ",
							" C uint16_t Temperature_Reading(void); ",
							" Description This routine will read current temperature ADC value The functionality is provided by RF IP ",
							" Parameters None ",
							" Returns uint16 The ADC value of current temperature ",
							" PMU System The PMU (Power Management Unit) subsystem helps in setting various power modes available in the system  Power Management Unit Subsystem is a complex power controller that requires specific configuration and handling by the software for correct safe operation of the SOC The software routines help in handles the startup and operation of the PMU  ",
							" PMU_Mode_T Enum ",
							" C typedef enum { // Linear mode - This is the default mode when CPU and peripherals are running PMU_MODE_MLDO = 1 // Buck (DC-DC/switching) mode; supports High Power (PWM) - The most efficient mode //when the CPU and peripherals are running In this mode the SoC is powered by the DC-DC converter PMU_MODE_BUCK_PWM // 2 // Buck (DC-DC/switching) mode; supports Low Power (PSK) mode PMU_MODE_BUCK_PSM // 3 } PMU_Mode_T; ",
							" Description Supported PMU Modes ",
							" PMU_Get_Mode Function ",
							" C PMU_Mode_T PMU_Get_Mode(void); ",
							" Description This routine will get the power mode of the system ",
							" Parameters None ",
							" Returns PMU_Mode_T - PMU_MODE_MLDO // 1 PMU_MODE_BUCK_PWM // 2 PMU_MODE_BUCK_PSM // 3 ",
							" PMU_Set_Mode Function ",
							" C uint8_t PMU_Set_Mode(PMU_Mode_T mode); ",
							" Description This routine will set the power mode of the system ",
							" Parameters Param Description PMU_Mode_T PMU_MODE_MLDO // 1 PMU_MODE_BUCK_PWM // 2 PMU_MODE_BUCK_PSM // 3 ",
							" Returns uint8_t 0 is success 1 is fail which means no BDADDR IB ",
							" PMU_ConfigCurrentSensor Function ",
							" C bool PMU_ConfigCurrentSensor(bool enable); ",
							" Description This routine will configure the BUCK current sensor It only can be configured when the power mode is set as PMU_MODE_BUCK_PSM Disable current sensor can improve the current consumption of sleep mode ",
							" Parameters Param Description bool enable Enable/Disable BUCK current sensor false: Disable true : Enable ",
							" Returns bool - true is success false is fail due to power mode is not in PMU_MODE_BUCK_PSM ",
							" Info Block Information block helps in getting factory set values from the information base  Information block helps in  loading all settings from the Info Block into the appropriate sub-systems for proper chip operation  getting the Bluetooth Device Address  getting the Zigbee MAC Address  getting factory temperature ADC value  getting Battery voltage 3 0 V ADC value  getting Battery voltage 2 2 V ADC value  getting RSSI compensation offset value  getting antenna gain value   ",
							" InformationBlockLoad Function ",
							" C uint8_t InformationBlockLoad(uint8_t checkIb uint8_t * checkIbExist wssEnable_t wssEnable); ",
							" Description This routine will load all settings from the Info Block into the appropriate sub-systems for proper chip operation NOTE: This is done automatically by RF_SYS_Initialize(uint8_t wssEnable) ",
							" Parameters None ",
							" Returns uint8_t 0 is success 1 is fail ",
							" IB_GetBdAddr Function ",
							" C bool IB_GetBdAddr(uint8_t * p_bdAddr); ",
							" Description This routine will get Bluetooth Device Address from IB If there exists BDADDR IB then it will return the BDADDR stored in IB Otherwise it returns FAILS (1) ",
							" Parameters Param Description uint8_t \"p_Addr\" the pointer to the memory stores BDADDR ",
							" Returns A boolean value True means valid BDADDR IB ",
							" IB_GetMACAddr Function ",
							" C bool IB_GetMACAddr(uint8_t * p_addr); ",
							" Description This routine will get ZB MAC Address from IB If there exists MAC_ADDR IB then it will return the MAC_ADDR stored in IB Otherwise it returns FAILS (1)) ",
							" Parameters Param Description uint8_t \"p_Addr\" the pointer to the memory stores MAC_ADDR ",
							" Returns A boolean value True means valid ZB MAC Address IB ",
							" IB_GetAntennaGain Function ",
							" C bool IB_GetAntennaGain(int8_t * p_antennaGain); ",
							" Description This routine will get antenna gain value from IB The value can be used to calculate radiative power radiative power = conductive power + antenna gain ",
							" Parameters Param Description int8_t p_antennaGain the memory to store antenna gain value ",
							" Returns A boolean value True means vaild antenna gain IB ",
							" IB_GetBatVoltage2v2Sar Function ",
							" C bool IB_GetBatVoltage2v2Sar(int16_t * p_batVoltageSar); ",
							" Description This routine will get Battery voltage 2 2 V ADC value from IB The value can be used for Battery voltage slope and detect battery voltage ",
							" Parameters IB_BatteryCalSar_T p_batVoltageSar - the pointer to the memory stores Battery voltage ADC value ",
							" Returns A boolean value True means valid Battery voltage ADC IB ",
							" IB_GetBatVoltage3v0Sar Function ",
							" C bool IB_GetBatVoltage3v0Sar(int16_t * p_batVoltageSar); ",
							" Description This routine will get Battery voltage 3 0 V ADC value from IB The value can be used for Battery voltage slope and detect battery voltage ",
							" Parameters IB_BatteryCalSar_T p_batVoltageSar - the pointer to the memory stores Battery voltage ADC value ",
							" Returns A boolean value True means valid Battery voltage ADC IB ",
							" IB_GetRssiOffset Function ",
							" C bool IB_GetRssiOffset(int8_t * p_rssiOffset); ",
							" Description This routine will get RSSI compensation offset value from IB The value can be used to compensation RSSI detection ",
							" Parameters Param Description int8_t p_rssiOffset the memory to store RSSI compensation offset value ",
							" Returns A boolean value True means vaild RSSI compensation offset IB ",
							" Sleep System Sleep system helps to enter and exit sleep modes  Two routines are defined  Device Enter Sleep Mode routine  Device Exit Sleep Mode routine   ",
							" DEVICE_SLEEP_ConfigAclbClk Function ",
							" C void DEVICE_SLEEP_ConfigAclbClk(bool enable); ",
							" Description The API is used to enable/disable ACLB clock ",
							" Parameters bool enable Set as true to enable ACLB; set as false to disable ",
							" Returns None ",
							" DEVICE_SLEEP_ConfigRetRam Function ",
							" C void DEVICE_SLEEP_ConfigRetRam(bool enable); ",
							" Description The API is used to enable/disable retention RAM ",
							" Parameters bool enable Set as true to enable retention RAM; set as false to disable ",
							" Returns None ",
							" DEVICE_SLEEP_ConfigRfClk Function ",
							" C void DEVICE_SLEEP_ConfigRfClk(bool enable); ",
							" Description The API is used to enable/disable RF clock ",
							" Parameters bool enable Set as true to enable RF clock; set as false to disable ",
							" Returns None ",
							" DEVICE_SLEEP_ConfigRfMbs Function ",
							" C void DEVICE_SLEEP_ConfigRfMbs(bool enable); ",
							" Description The API is used to enable/disable RF MBS ",
							" Parameters bool enable Set as true to enable RF MBS; set as false to disable ",
							" Returns None ",
							" DEVICE_SLEEP_ConfigRfXtal Function ",
							" C void DEVICE_SLEEP_ConfigRfXtal(bool enable); ",
							" Description The API is used to enable/disable RF crystal ",
							" Parameters bool enable Set as true to enable RF crystal; set as false to disable ",
							" Returns None ",
							" DEVICE_SLEEP_ConfigSubSysPllLock Function ",
							" C void DEVICE_SLEEP_ConfigSubSysPllLock(bool enable); ",
							" Description The API is used to enable/disable BT/ZB sub-system bypass PLL lock ",
							" Parameters bool enable Set as true to enable BT/ZB sub-system bypass PLL lock; set as false to disable ",
							" Returns None ",
							" DEVICE_SLEEP_ConfigSubSysXtalReady Function ",
							" C void DEVICE_SLEEP_ConfigSubSysXtalReady(bool enable); ",
							" Description The API is used to enable/disable BT/ZB sub-system crystal ",
							" Parameters bool enable Set as true to enable BT/ZB sub-system crystal; set as false to disable ",
							" Returns None ",
							" DEVICE_SLEEP_DisableDebugBus Function ",
							" C void DEVICE_SLEEP_DisableDebugBus(void); ",
							" Description The API is used to disable debug bus for power saving purpose ",
							" Parameters None ",
							" Returns None ",
							" DEVICE_SLEEP_ConfigWssLowPowerMode Function ",
							" C void DEVICE_SLEEP_ConfigWssLowPowerMode(void); ",
							" Description The API is used to bring the wireless subsystem in low power mode n It should be called when the application requests the device into deep sleep or xtreme deep sleep mode ",
							" Parameters None ",
							" Returns None ",
							" Deep Sleep System Enter a short description of your topic here (optional)  These API’s allow the system to be configured and placed into its Deep Sleep state  ",
							" DEVICE_SetDeepSleepWakeUpSrc Function ",
							" C void DEVICE_SetDeepSleepWakeUpSrc(DEVICE_DeepSleepWakeSrc_T wakeUpSrc); ",
							" Description The API is used to set the wake up source of deep sleep mode ",
							" Parameters Param Description wakeUpSrc Tthe wake up source See @ref DEVICE_DeepSleepWakeSrc_T ",
							" Returns None ",
							" DEVICE_GetDeepSleepWakeUpSrc Function ",
							" C void DEVICE_GetDeepSleepWakeUpSrc(DEVICE_DeepSleepWakeSrc_T *wakeUpSrc); ",
							" Description The API is used to get the wake up source of deep sleep mode ",
							" Parameters Param Description wakeUpSrc Pointer to the wake up source See @ref DEVICE_DeepSleepWakeSrc_T ",
							" Returns None ",
							" DEVICE_EnterExtremeDeepSleep Function ",
							" C void DEVICE_EnterExtremeDeepSleep(bool enableInt0); ",
							" Description The API is used to enter extreme deep sleep mode ",
							" Parameters Param Description enableInt0 Enable/Disable if the device can be woken from extreme deep sleep mode by INT0 ",
							" Parameters None ",
							" Returns None ",
							" DEVICE_EnterDeepSleep Function ",
							" C void DEVICE_EnterDeepSleep(bool enableRetRam uint32_t interval); ",
							" Description The API is used to enter deep sleep mode ",
							" Parameters Param Description enableRetRam Enable/Disable retention ram ",
							" Parameters Param Description interval The interval of deep sleep mode (unit: ms) Set as 0 will keep the device in the deep sleep mode until the INT0 (PB4) is triggered ",
							" Parameters None ",
							" Returns None ",
							" DEVICE_DeepSleepWakeSrc_T Enum ",
							" C typedef enum DEVICE_DeepSleepWakeSrc_T { DEVICE_DEEP_SLEEP_WAKE_NONE // The device is not waken from deep sleep DEVICE_DEEP_SLEEP_WAKE_INT0 // The device is waken from deep sleep by interrupt 0 DEVICE_DEEP_SLEEP_WAKE_RTC // The device is waken from deep sleep by RTC DEVICE_DEEP_SLEEP_WAKE_DSWDT // The device is waken from deep sleep by Deep Sleep Watch Dog Timeout DEVICE_DEEP_SLEEP_WAKE_MCLR // The device is waken from deep sleep by MCLR DEVICE_DEEP_SLEEP_WAKE_OTHER // The device is waken from deep sleep by the other reason DEVICE_DEEP_SLEEP_WAKE_END } DEVICE_DeepSleepWakeSrc_T; ",
							" Description Various available deep Sleep Wakeup Sources ",
							" DEVICE_deepSleepIntervalCal Function ",
							" C uint32_t DEVICE_deepSleepIntervalCal(uint32_t expectedInt); ",
							" Description The API is used to perform the deep sleep interval calibration to exclude the HW preparation time of advertising ",
							" Parameters Param Description expectedInt The expected deep sleep interval ",
							" Returns The deep sleep interval after calibration ",
							" DEVICE_ClearDeepSleepReg Function ",
							" C bool DEVICE_ClearDeepSleepReg(void); ",
							" Description The API is used to clear the deep sleep related register If the device is waken from deep sleep mode the related register will be cleared If it's a normal Power-on Reset no register will be cleared ",
							" Parameters None ",
							" Returns A boolean value True means the device is waken from deep sleep mode ",
							" OSAL Extension for FreeRTOS  OSAL (Operating System Abstraction Layer) Extension for FreeRTOS provide extension for OSAL mappings for the FreeRTOS Real-time operating system The following table defines OSAL routines        Fuction Name  Short Description      OSAL_QUEUE_Create  Creates a new queue instance    OSAL_QUEUE_CreateSet  Creates a new queue set instance    OSAL_QUEUE_AddToSet  Adds the queues and semaphores to the set    OSAL_QUEUE_SelectFromSet  Block to wait for something to be available from the queues or semaphore that have been added to the set    OSAL_QUEUE_Send  Post an item into an OSAL Queue    OSAL_QUEUE_SendISR  Post an item into an OSAL Queue from ISR    OSAL_QUEUE_Receive  Receive an item from an OSAL Queue    OSAL_QUEUE_IsFullISR  Query if an OSAL Queue is full       ",
							" OSAL_QUEUE_Create Function ",
							" C OSAL_RESULT OSAL_QUEUE_Create(OSAL_QUEUE_HANDLE_TYPE *queID uint32_t queueLength uint32_t itemSize); ",
							" Description Creates a new queue instance and returns a handle by which the new queue can be referenced ",
							" Parameters Param Description queID A pointer to the queue ID queueLength The maximum number of items that the queue can contain itemSize The number of bytes each item in the queue will require Items are queued by copy not by reference so this is the number of bytes that will be copied for each posted item Each item in the queue must be the same size ",
							" Returns OSAL_RESULT_TRUE - A queue had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_CreateSet Function ",
							" C OSAL_RESULT OSAL_QUEUE_CreateSet(OSAL_QUEUE_SET_HANDLE_TYPE *queID uint32_t queueLength); ",
							" Description Creates a new queue set instance and returns a handle by which the new queue can be referenced ",
							" Parameters Param Description queID A pointer to the queue ID queueLength The maximum number of items that the queue can contain ",
							" Returns OSAL_RESULT_TRUE - A queue set had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_AddToSet Function ",
							" C OSAL_RESULT OSAL_QUEUE_AddToSet(OSAL_QUEUE_SET_MEMBER_HANDLE_TYPE *queSetMember OSAL_QUEUE_SET_HANDLE_TYPE *queSetID); ",
							" Description Add the queues and semaphores to the set Reading from these queues and semaphore can only be performed after a call to xQueueSelectFromSet() has returned the queue or semaphore handle from this point on ",
							" Parameters Param Description queSetMember Member queue or semaphore to be added in the set queSetID A pointer to the queue ID ",
							" Returns OSAL_RESULT_TRUE - A queue had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_SelectFromSet Function ",
							" C OSAL_RESULT OSAL_QUEUE_SelectFromSet(OSAL_QUEUE_SET_MEMBER_HANDLE_TYPE *queSetMember OSAL_QUEUE_SET_HANDLE_TYPE *queSetID uint16_t waitMS); ",
							" Description Block to wait for something to be available from the queues or semaphore that have been added to the set ",
							" Parameters Param Description queSetMember Member queue or semaphore to be added in the set queSetID A pointer to the queue ID waitMS wait time in milliseconds other value OSAL_WAIT_FOREVER ",
							" Returns OSAL_RESULT_TRUE - A queue had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_Send Function ",
							" C OSAL_RESULT OSAL_QUEUE_Send(OSAL_QUEUE_HANDLE_TYPE *queID void *itemToQueue uint16_t waitMS); ",
							" Description Post an item into an OSAL Queue The item is queued by copy not by reference This function must not be called from an interrupt service routine See OSAL_QUEUE_SendISR() for an alternative which may be used in an ISR ",
							" Parameters Param Description queID A pointer to the queue ID itemToQueue A pointer to the item that is to be placed on the queue The size of the items the queue will hold was defined when the queue was created so this many bytes will be copied from itemToQueue into the queue storage area waitMS Time limit to wait in milliseconds 0 do not wait OSAL_WAIT_FOREVER return only when semaphore is obtained Other values timeout delay ",
							" Returns OSAL_RESULT_TRUE - Item copied to the queue OSAL_RESULT_FALSE - Item not copied to the queue or timeout occurred ",
							" OSAL_QUEUE_SendISR Function ",
							" C OSAL_RESULT OSAL_QUEUE_SendISR(OSAL_QUEUE_HANDLE_TYPE *queID void *itemToQueue); ",
							" Description Post an item into an OSAL Queue The item is queued by copy not by reference The highest priority task currently blocked on the queue will be released and made ready to run This form of the send function should be used witin an ISR ",
							" Parameters Param Description queID A pointer to the queue ID itemToQueue A pointer to the item that is to be placed on the queue The size of the items the queue will hold was defined when the queue was created so this many bytes will be copied from itemToQueue into the queue storage area waitMS Time limit to wait in milliseconds 0 do not wait OSAL_WAIT_FOREVER return only when semaphore is obtained Other values timeout delay ",
							" Returns OSAL_RESULT_TRUE - Item copied to the queue OSAL_RESULT_FALSE - Item not copied to the queue or timeout occurred ",
							" OSAL_QUEUE_Receive Function ",
							" C OSAL_RESULT OSAL_QUEUE_Receive(OSAL_QUEUE_HANDLE_TYPE *queID void *pBuffer uint16_t waitMS); ",
							" Description Receive an item from an OSAL Queue The item is received by copy so a buffer of adequate size must be provided The number of bytes copied into the buffer was defined when the queue was created Successfully received items are removed from the queue This function must not be used in an interrupt service routine ",
							" Parameters Param Description queID A pointer to the queue ID buffer A pointer to the buffer into which the received item will be copied The size of the items the queue hold was defined when the queue was created so this many bytes will be copied from the queue storage area into the buffer waitMS Time limit to wait in milliseconds 0 do not wait OSAL_WAIT_FOREVER return only when semaphore is obtained Other values timeout delay ",
							" Returns OSAL_RESULT_TRUE - An item was successfully received from the queue OSAL_RESULT_FALSE - An item was not successfully received from the queue or timeout occurred ",
							" OSAL_QUEUE_IsFullISR Function ",
							" C OSAL_RESULT OSAL_QUEUE_IsFullISR(OSAL_QUEUE_HANDLE_TYPE *queID); ",
							" Description Query if an OSAL Queue is full These function should be used only from witin an ISR or within a critical section ",
							" Parameters Param Description queID A pointer to the queue ID ",
							" Returns OSAL_RESULT_TRUE - The queue is Full OSAL_RESULT_FALSE - The queue is not Full ",
							" App Idle Task  App Idle task service provides idle task routines which will be called from FreeRTOS Idle hook function It executes the idle activities The following activities may be carried out  RF Calibration if RF needs calibration  Storing of PDS Items by calling PDS Store Item Handler  Checking whether the Zigbee stack is ready to sleep  Requesting BLE to enter sleep mode     ",
							" app_idle_task Function ",
							" C void app_idle_task( void ); ",
							" Description This function performs the activities like PDS store Sleep and other RF system idle activities which can be performed when the complete system is idle ",
							" Parameters None ",
							" Returns None ",
							" app_idle_updateRtcCnt Function ",
							" C void app_idle_updateRtcCnt(uint32_t cnt); ",
							" Description RTC based tickless idle mode Hook function records RTC counter value in each tick interrupt to ensure the real time RTC counter value be recorded during system is active Then RTC tickless idle mode can use this value to calculate how much time passed during system sleep ",
							" Parameters Param Description cnt RTC counter value ",
							" Returns None ",
							" PIC32CX-BZ2 Persistent Data Server Component Library Help The PIC32CX-BZ2 Persistent Data Server Component Library provides interface for storing and restoring items into the Non volatile memory using wear leveling mechanism  PERSISTENT DATA SERVER (PDS)  The Persistent Data Server (PDS) component implements interfaces and functionality for storing and restoring data in a non-volatile (NV) memory storage  In PDS particular pieces of persistent data are called files and groups of parameters are called directories Following section describes how to define such persistent items and overview of PDS API functions that can be used to store and restore them  User can specify parameters he(she) wants to backup in a non-volatile memory and restore in case of power failure This service is provided by Persistent Data Server (PDS) module The BitCloud (TM) stack also uses the same service for its internal structures  The main feature behind the wear leveling PDS is the mechanism designed to extend the lifetime of the NV storage as well as to protect data from being lost when a reset occurs during writing to the NV This mechanism is based on writing data evenly through the dedicated area so that the storage’s lifetime in not limited by the number of reading and writing operations performed with more frequently used parameters For this purpose the non-volatile storage organized as a cyclic log with new versions of data being written at the end of the log not in place where the previous versions of the same data are stored  ",
							" PDS Library Usage PIC32CX-BZ2 Persistent Data Server(PDS) Library Usage  Configuring the library  There is no configuration of this library  Using the library  Defining Files and Directories  In PDS particular pieces of persistent data are called files (or items) and groups of files are called directories Note that directories are just the way to refer to particular files and a file can belong to several directories at once Files and directories contain the meta-information about the data that allows its maintenance within the NV – file descriptors and directory descriptors  The PDS component defines a number of file units for individual stack parameters and directories to group files for more subtle control The application may define its own items  File and File Descriptor  Each item which user wants to backup in a non-volatile memory and restore in case of power failure is treated as a FILE - actual item value with associated service information FILE DESCRIPTOR Each file could be accessed by it's ID a unique 16-bit value associated with a file File descriptor keeps information about item's size and it's displacement in RAM and inside the NV storage  All file descriptors should be placed in a special segment inside the MCU Flash memory - [PDS_FF] The PDS_FILE_DESCR() macro is used to initialize descriptor and PDS_DECLARE_FILE() macro is used to place descriptor to required segment  A file descriptor consists of the following parts:    memoryId: memory identifier associated with a file  size: the size of file’s data  ramAddr: the pointer to item’s entity in RAM (that is to a variable holding file’s data) if one exists or NULL otherwise  fileMarks: file marks specifying specific characteristics of the file File marks may be set either to following values:  SIZE_MODIFICATION_ALLOWED: indicates that size of the file can be different in new firmware image after over-the-air upgrade Usually is set for files storing table data such as binding table group table and others  ITEM_UNDER_SECURITY_CONTROL: no impact works same as NO_FILE_MARKS  NO_FILE_MARKS: no special characteristics for the file     A file descriptor tied to some data in RAM is defined by using the PDS_DECLARE_FILE macro in the code that may be used by both the stack and the application:   PDS_DECLARE_FILE(memoryId size ramAddr fileMarks)   Directory and Directory Descriptor  PDS is able to operate with separate files or with file lists - DIRECTORIES Directory nesting is allowed Each directory should be provided with DIRECTORY DESCRIPTOR which keeps information about associated items Directories could be accessed by 16-bit ID different from already associated with files  All directory descriptors should be placed in a special segment inside the MCU Flash memory - [PDS_FD] The PDS_DECLARE_DIR() macro is used to place a directory to required segment  Directory descriptors are special entities describing a group of file A directory descriptor is defined in the code (the stack’s or the application’s one) and is placed to the separate flash memory segment  The directory descriptor consists of the following parts:  list: pointer to the list of files IDs associated with the directory This list should be placed in the flash memory (by the use of the PROGMEM_DECLARE macro – see an example below)  filesCount: the amount of files associated with the directory  memoryId: memory identifier associated with the directory   A directory is declared via the PDS_DECLARE_DIR macro in the following way:   PDS_DECLARE_DIR(const PDS_DirDescr_t csGeneralParamsDirDescr) = { list = CsGeneralMemoryIdsTable filesCount = ARRAY_SIZE(CsGeneralMemoryIdsTable) memoryId = BC_GENERAL_PARAMS_MEM_ID }; //Where CsGeneralMemoryIdsTable is the list of objects defined in the following way: PROGMEM_DECLARE(const PDS_MemId_t CsGeneralMemoryIdsTable[]) = { CS_UID_MEM_ID CS_RF_TX_POWER_MEM_ID //other parameters in this list }      Major Functions       Name  Description      PDS_Init  initializes the Persistence Data Server    PDS_InitItems  initializes the Persistence Data Server Items    PDS_Restore  Restores data from non-volatile storage    PDS_Store  Stores data in non-volatile memory in background not blocking other processes    PDS_DeleteAll  deletes data from non-volatile storage    PDS_AddItemExcpetionFromDeleteAll  extempts the item from the Delete All command    PDS_Delete  removes specified file records from NV Storage    PDS_IsAbleToRestore  Checks if the specified PDS file or directory can be restored from non-volatile memory    PDS_RegisterWriteCompleteCallback  registers the callback for the Item Write completion    PDS_RegisterUpdateMemoryCallback  registers the callback for the Item update memory    PDS_StoreItemTaskHandler  task that handles the store items into NV memory    PDS_GetPendingItemsCount  gets the number of items pending in the PDS write queue    PDS_GetItemDescr  gets the item descriptor for the given item ID       ",
							" ITEM_ID_TO_MEM_MAPPING Macro ",
							" C /** PDS Item to memory mapping Definition */ #define ITEM_ID_TO_MEM_MAPPING(item size pointer func flag) { itemId = item itemSize = size itemData = pointer filler = func flags = flag} ",
							" Description PDS Item to memory mapping Definition ",
							" ITEM_UNDER_SECURITY_CONTROL Macro ",
							" C #define ITEM_UNDER_SECURITY_CONTROL 0x02U ",
							" Description PDS Item under security control Flag ",
							" PDS_DECLARE_ITEM Macro ",
							" C #define PDS_DECLARE_ITEM(item size pointer func flag) PDS_FF_OBJECT(ItemIdToMemoryMapping_t pds_ff_##item) = ITEM_ID_TO_MEM_MAPPING(item size pointer func flag); ",
							" Description PDS Declare Item Definition To declare an itemfile in the PDS item : Item ID (Unique Indentifier number)for that particular ItemFile size: size of the item (Maximum allowed size for an Item is 2K (2048 Bytes) pointer: RAM address of the Item func: filler function can be set to NULL (will be called during the store operation) Shall be kept to min size flag: NO_ITEM_FLAGS SIZE_MODIFICATION_ALLOWED ITEM_UNDER_SECURITY_CONTROL ",
							" NO_ITEM_FLAGS Macro ",
							" C #define NO_ITEM_FLAGS 0x00U ",
							" Description PDS Item No Item Flags ",
							" NO_FILE_MARKS Macro ",
							" C #define NO_FILE_MARKS 0U ",
							" Description No File Marks ",
							" PDS_MAX_FILE_SIZE Macro ",
							" C #define PDS_MAX_FILE_SIZE (2 * 1024) //bytes ",
							" Description Ensure that the max size of the item is less than or equal to PDS_MAX_FILE_SIZE ",
							" PDS_DIRECTORY_ID_MASK Macro ",
							" C #define PDS_DIRECTORY_ID_MASK 0x0C00U // (Bit 11 and Bit 10) ",
							" Description Use this Directory mask on declaring directory item id's along with module specific offsets ",
							" SIZE_MODIFICATION_ALLOWED Macro ",
							" C #define SIZE_MODIFICATION_ALLOWED 0x01U ",
							" Description PDS Item Size Modificaiton Allowed Flag ",
							" PDS_MODULE OFFSET Macro ",
							" C #define PDS_MODULE_OT_OFFSET (1 11) #define PDS_MODULE_APP_OFFSET (1 12) #define PDS_MODULE_BT_OFFSET (1 13) #define PDS_MODULE_ZB_OFFSET (1 14) #define PDS_MODULE_RES_OFFSET (1 15) ",
							" Description ",
							" PDS_DataServerState_t Enum ",
							" C typedef enum { PDS_SUCCESS // Command completed successfully } PDS_DataServerState_t; ",
							" Description PDS Data Server State Enumeration ",
							" ItemIdToMemoryMapping_t Struct ",
							" C typedef struct { // Item identifier PDS_MemId_t itemId; // Size of the item uint16_t itemSize; // Pointer to the item data void *itemData; // Function which gets called upon operation completion void (*filler)(void); // Flags uint8_t flags; } ItemIdToMemoryMapping_t; ",
							" Description PDS Item to memory mapping structure ",
							" PDS_DirDescr_t Struct ",
							" C typedef struct { // PDS Memory identifier record list PDS_MemIdRec_t list; // Number of files in the directory uint16_t filesCount; // Memory identifier PDS_MemId_t memoryId; } PDS_DirDescr_t; ",
							" Description PDS Directory Descriptor structure ",
							" PDS_Operation_Offset_t Struct ",
							" C typedef struct { // Item identifier PDS_MemId_t id; // Item offset uint16_t offset; // size of item uint16_t size; // corresponding ram address for the item uint8_t *ramAddr; }PDS_Operation_Offset_t; ",
							" Description PDS Operation offset structure ",
							" PDS_UpdateMemory_t Struct ",
							" C typedef struct { // Item identifier PDS_MemId_t id; // Data pointer void *data; // current item size uint16_t size; // last size of item uint16_t oldSize; }PDS_UpdateMemory_t; ",
							" Description PDS Update Memory structure ",
							" PDS_AddItemExcpetionFromDeleteAll Function ",
							" C bool PDS_AddItemExcpetionFromDeleteAll (PDS_MemId_t itemID); ",
							" Description This routine extempts the item from the Delete All command Makes the item double persistent ",
							" Parameters Param Description PDS_MemId_t Item ID to be exempted ",
							" Returns bool - True ",
							" PDS_Delete Function ",
							" C PDS_DataServerState_t PDS_Delete(PDS_MemId_t memoryId); ",
							" Description This routine removes specified file records from NV Storage ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be removed from NV memory ",
							" Returns PDS state as an operation result ",
							" PDS_DeleteAll Function ",
							" C PDS_DataServerState_t PDS_DeleteAll(bool includingPersistentItems); ",
							" Description This routine deletes data from non-volatile storage except the Persistent items depending on the parameter passed ",
							" Parameters Param Description includingPersistentItems deletes Persistent items if TRUE deletes all other items except Persistent items if FALSE ",
							" Returns PDS_DataServerState_t - status of PDS DeleteAll ",
							" PDS_GetItemDescr Function ",
							" C bool PDS_GetItemDescr(PDS_MemId_t memoryId ",
							" Description This routine gets the item descriptor for the given item ID ",
							" Parameters Param Description memoryId item id itemDescrToGet pointer to item descriptor to be loaded ",
							" Returns true if descriptor is found out for the given item ID false - otherwise ",
							" PDS_GetPendingItemsCount Function ",
							" C uint8_t PDS_GetPendingItemsCount (void); ",
							" Description This routine returns no of items pending in the PDS write queue ",
							" Parameters None ",
							" Returns uint8_t value No of items waiting in the queue zero if no items are pending ",
							" PDS_Init Function ",
							" C void PDS_Init(PDS_MemId_t maxItems PDS_MemId_t maxDirectories); ",
							" Description This routine initializes Persistent Data Server ",
							" Parameters Param Description maxItems Total number of individual PDS items used in the entire system maxDirectories Total number of PDS directories used in the entire system ",
							" Returns None ",
							" PDS_InitItems Function ",
							" C void PDS_InitItems(uint16_t memIdStart uint16_t memIdEnd); ",
							" Description This routine initializes PDS items Initializes an item with default data if it doesn't exist yet or reads it when it does exist ",
							" Parameters Param Description memIdStart The start memory identifier memIdEnd The end memory identifier ",
							" Returns true if all expected files have been restored false - otherwise ",
							" PDS_IsAbleToRestore Function ",
							" C bool PDS_IsAbleToRestore(PDS_MemId_t memoryId); ",
							" Description This routine checks if the specified PDS file or directory can be restored from non-volatile memory ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be checked ",
							" Returns true if the specified memory can be restored; false - otherwise ",
							" PDS_RegisterUpdateMemoryCallback Function ",
							" C void PDS_RegisterUpdateMemoryCallback (bool (*callbackFn)(PDS_UpdateMemory_t *)); ",
							" Description This routine register the callback for the Item update memory Updates BC parameters after restoring taking into account possible size ",
							" Parameters Param Description PDS_UpdateMemory_t PDS_UpdateMemory_t callbackFn pointer to callback functions ",
							" Returns None ",
							" PDS_RegisterWriteCompleteCallback Function ",
							" C void PDS_RegisterWriteCompleteCallback (void (*callbackFn)(PDS_MemId_t)); ",
							" Description This routine registers the callback for the Item Write completion ",
							" Parameters Param Description callbackFn callback which gets called after write complete ",
							" Returns None ",
							" PDS_Restore Function ",
							" C bool PDS_Restore(PDS_MemId_t memoryId); ",
							" Description This routine restores data from non-volatile storage PDS files not included in the current build configuration will be ignored Restoring process will be performed only if all files expected for actual configuration are presented in NV storage ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be restored from non-volatile memory ",
							" Returns true if all expected files have been restored false - otherwise ",
							" PDS_Store Function ",
							" C bool PDS_Store(PDS_MemId_t memoryId); ",
							" Description This routine stores data in non-volatile memory in background not blocking other processes Make sure the item/file size is less than MAX_FILE_SIZE ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be stored from non-volatile memory ",
							" Returns True if storing process has begun false - otherwise ",
							" PDS_StoreItemTaskHandler Function ",
							" C void PDS_StoreItemTaskHandler(void); ",
							" Description This routine is the PDS store item handler Actual flash write operation of a particular Item ID Can be called when system is Idle or when necessary ",
							" Returns None ",
							" PIC32CX-BZ2 Bootloader Services Component Help  The PIC32CX-BZ2 Bootloader Services is a utility which helps in creating signed firmware image for OTA with the provided header and OTA header information Please follow MCC Project Graph and how to add Bootloader services component which is available in Device Resources - Libraries → Harmony → Wireless → Bootloader Services  Bootloader services utility functional activities with Harmony 3 code generation  Adds the autoload py script which gets loaded in the project (See Screenshot) for getting the required information from user for creating signed Firmware  Please find the description below on the labels        Label Name  Description      Sequence Number  Sequence Number in 64bit Hex format range from 0x00000001 to 0xFFFFFFFE    Manufacture ID  Identifier of the Manufacturer up to 4 ASCII characters    Auth Method  Authentication Method The supported authentication methods are None SHA256 and ECDSA256-SHA256    Firmware Revision  Revision of the firmware It is in the format of x x x x where x is value in range 0-255    Private Key File  Key used for ECDSA Authentication It is in PKCS#8 fromat This label is enabled only if Auth method is ECDSA256-SHA256     The complete image including firmware and meta header is signed by the below process  Bootloader services help in embedding OTA header information as part of the signed firmware binary image which can be done with OTA tab Output File Type as BLE OTA File Output File Type as Zigbee OTA File Output File Type as Combo OTA File   Please find the below table which includes the description of the label’s/parameter’s used        Label Name  Description      Output File Name  Output File Name for the OTA package in binary format    Output File Encryption  Option to choose whether to Encrypt the OTA package or not Unencrypted /encrypted    AES Key  This option is enabled only if Output File Encryption is set to encrypted 128bit AES key to encrypt the OTA package with AES-CBC-128    Init Vector  This option is enabled only if Output File Encryption is set to encrypted 128bit Initial Vector to encrypt the OTA package with AES-CBC-128    Output File Type  Output file types are among BLE Zigbee or Combo OTA operation    Flash Image ID  This option is enabled only if Output File file is set to BLE OTA File or Combo OTA File It is the 32bit Identification Number for App layer to confirm the new Flash Image is acceptable    Manufacture Code  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 16-bit manufacturer identifier used to match supported devices Defaults to 0xFFFF (match all)    Image Type  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 16-bit image type Defaults to 0xFFFF (match all)    File Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 32-bit integer representing the file version Can be in the recommended format (8-bit app release 8-bit app build 8 bit stack release 8-bit stack build) simple increasing version or an unsupported version format If in an unsupported version format the OTA Cluster will not be able to compare file versions Defaults to 0x0000    Stack Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 16-bit identifier of the zigbee stack version Defaults to 0x02 for zigbee Pro    Header String  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 32-byte string used by each manufacturer as they see fit but recommended to be human readable    Security Credential Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 8-bit identifier of the Security Credential Version Defaults to not included    Upgrade File Destination  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 64-bit extended address of the device to which this image is specific Defaults to not include image is available to all devices    Minimum Hardware Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 0/16-bit integer representing the earliest hardware platform this image can be used on    Maximum Hardware Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 16-bit integer representing the latest hardware platform this image can be used on     Bootloader services generates linker script with the below memory layout which lets the stack to store the image in Slot 1 during stack OTA process    ",
							" PIC32CX-BZ2 Standalone Bootloader Component Help  PIC32CX-BZ2 bootloader is a standalone harmony component Using it one can generate bootloader which is a program that is loaded on internal flash memory and gets executed every time the device powers up or resets  Bootloader can be used to upgrade firmware on a target device without the need for an external programmer or debugger It does not fully operate on the device but can perform various functions prior to starting the main application  Functionality of Bootloader  Loads firmware images to flash over the serial connection using a tool or python script known as Device Firmware Upgrade (DFU)  Provides application protection for firmware  Replaces application firmware  Starts the application  If the device wakes from deep sleep then bootloader directly jumps to the application    Memory Information and Layout of PIC32CXBZ2 device           Memory Area  Purpose      Boot Flash Size is 0x0 to 0x5E00 – (~24KB)  The memory where bootloader code runs    Slot 0 base address - 0x01000000  The memory where the application firmware runs and the memory where the bootloader copies the new application firmware    Slot 1 base address - 0x01080000  The memory where the received image(Either through DFU or any other way) gets stored and the memory where bootloader looks for the new image to copy into the Slot 0       The full memory layout can be found here    Boot Flash  In PIC32CXBZ2 24KB boot flash memory is separated from the main execution memory This boot flash is used for bootloader code  Metadata Header  Format of image meta-data header are described below Notice that some of the elements in the header is reserved for future expansion and they are not used in this version of bootloader implementation           Offset  Name  Description      Metadata Header    0x00:0x07  Filler  Set to all zero    0x08:0x0D  MANU_IDENTIFIER *  “MCHP” ASCII String Identifier    0x0C:0x0F  Filler  Set to all zero    0x10:0x13  SEQ_NUM *  Metadata Sequence Number of the image (little endian) Monotonically decreasing image index Values of 0 or 0xFFFFFFFF indicate that the image is invalid    0x14  MD_REV  Metadata Revision This field must be set to 0x02 for this version of metadata header    0x15  CONT_IDX   Container Index 1: Plain firmware image 2: Encrypted firmware image     0x16  MD_AUTH_MTHD *   Metadata authentication method 0: None 1: SHA-256 2: ECDSA p256 + SHA-256     0x17  MD_AUTH_KEY   Key index for authenticating metadata 0: IB Key 1: Key #2 Reserved for future use Not for MD_REV 0x01     0x18  PL_DEC_MTHD   Payload Decryption method 0: Plain 1: AES     0x19  PL_DEC_KEY   Key index for decrypting payload 0: Key #1 1: Key #2     0x1A:0x1B  PL_LEN  Metadata payload length The payload length for this version should be 0x55    Metadata Payload = Firmware Image Header    0x1C:0x1F  FW_IMG_REV *  Firmware Image revision (little endian)    0x20:0x23  FW_IMG_LEN  Firmware Image length    0x24  FW_IMG_AUTH_MTHD *   Firmware Image authentication method For Chimera the acceptable method are ECDSA p256 + SHA-256 0: None 1: SHA-256 2: ECDSA p256 + SHA-256     0x25  FW_IMG_AUTH_KEY   Firmware Image authentication key index 0: IB key 1: Key #2     0x26  FW_IMG_DEC_MTHD   Firmware Image decryption method 0: Plain 1: AES Reserved for future use Not for MD_REV 0x01     0x27  FW_IMG_DEC_KEY   Firmware Image decryption key index 0: Key #1 1: Key #2 Reserved for future use Not for MD_REV 0x01     0x28  FW_IMG_SIG_SZ  Firmware Image signature size    0x29:0x70  FW_IMG_SIG   Firmware Image Signature The concatenated R and S term of the ECDSA signature (P-256) of the SHA-256 hash of the firmware image     Metadata Footer    0x1B7  MD_SIG_SZ  Metadata payload signature size    0x1B8:0x1FF  MD_SIG   Metadata payload signature The concatenated R and S term of the ECDSA signature (P-256r1) of the SHA-256 hash of the metadata payload (firmware image header)        * Configurable by user  Working of Bootloader  when the application receives new image from a server or via a tool it will/should store in the Slot 1 location with meta data header firmware and it should trigger software reset so that bootloader code runs  Bootloader checks for valid image in Slot 1 by reading the meta data header and firmware and authenticating the same with the selected authentication method If valid image is found and successfully authenticated then  Erases Slot 0  Copies the Slot 1 image to Slot 0  Verifies the Copy  After that it checks for valid image in Slot 0 by validating it it jumps to the application if valid image is found  Bootloader usage with DFU  bootloader programmed to the MCU (in DFU mode) receives an application image from the host over serial interface and writes it to the internal flash in Slot 1 After loading new image on slot 1 if reset is triggered then bootloader erases the slot 0 copies the image from slot 1 to slot 0 verifies the copy procedure erases the slot 1 Then bootloader jumps to application which is the new application image  Bootloader stores information about the image in Meta Data Header This is basically size of 0x200 bytes and gets stored at the start of slot Bootloader reads this meta data header and does the authentication procedure based on the information in meta data header  Flow Diagram of Bootloader  The detailed flow diagram of bootloader with the optional DFU block can be found below   ",
							" Configuration Options  Default configuration options window for bootloader is shown below   Enable Console option  By enabling this option Information on bootloader activities will printed into console using SERCOM UART By Default this option is disabled When this option is enabled make sure to connect the UART dependency in the bootloader with the SERCOM UART  ECC Public Key  By default ECC Public key is 0xc2 0x81 0x8f 0xbb 0x28 0x61 0x47 0x8b 0xa2 0x53 0x37 0x79 0xd4 0x63 0x18 0x7c 0x8b 0x41 0x59 0xa9 0x5f 0x0b 0x6b 0x94 0x4e 0xb9 0x57 0xa1 0x03 0xfe 0x20 0xbf 0x2b 0xb8 0x14 0x2a 0x64 0xb5 0xae 0x4a 0x83 0x80 0xdd 0xe6 0xee 0x29 0x89 0xdd 0xa0 0x9a 0xc7 0xda 0x82 0xeb 0x56 0x62 0x90 0x5d 0x66 0xc5 0xbc 0x30 0x3c 0x84  User should be able to change this key by changing the text box  Supported Authentication Methods  Three methods of authentication is supported in the bootloader  None  SHA-256  ECDSA-256   By Default all these three modes are enabled If customer want to use a specific authentication alone for security aspect they can choose that alone  Enable Bootloader UART DFU option  By enabling this option UART DFU (Device Firmware Upgrade) functionality will be enabled in the bootloader DFU can be used to upgrade firmware on a target device through serially (UART) By Default this option is disabled When this option is enabled make sure to connect the UART dependency in the bootloader with the SERCOM UART  There are two UART DFU Modes  GPIO Trigger DFU Mode  Timer Based Trigger DFU Mode   DFU : GPIO Trigger DFU Mode Default Configuration   GPIO Trigger DFU Mode  In this mode DFU functionality is enabled when you hold the GPIO button and press reset button to put the bootloader into the DFU mode  Use GPIO Port and Pin option to change the port and pin based on the board With PIC32CXBZ2 Curiosity board GPIO PB4 is used as user button The above default settings are based on this User can change if different board is used   Timer based Trigger DFU Mode  In order to use timer-based trigger DFU Mode where bootloader will be in DFU Mode for the defined amount of time before jumping to the application select the DFU mode to Timer Based Trigger Change the DFU wait time if needed DFU wait time is the time (in milliseconds) where the bootloader will be in DFU mode before jumping to the application   ",
							" DFU Functionality - Serial image bootloader  DFU the device firmware upgrade in bootloader is used to load new image which is received from host over serial interface and writes into the flash(Slot 1) The host may be python script or pc tool  There are two possible ways the device bootloader can be put into DFU mode  GPIO trigger DFU Mode  By holding GPIO pin/button and resetting the board helps to enter DFU mode  Timer based trigger DFU Mode Upon boot bootloader enters into DFU mode and will be in DFU mode for the defined time for example: 600ms then upon timeout control jumps to application So the host application/script should be sending messages to load the new image very frequently so that when reset is triggered it loads the new image since the bootloader will be in DFU mode   ",
							" Bootloader API Usage  The following macros typedef functions defintions help for generic functions of bootloader  ",
							" FW_IMAGE_BLOCK_SIZE Macro ",
							" C #define FW_IMAGE_BLOCK_SIZE 4096 ",
							" Description Firmware Image Block Size ",
							" FW_IMAGE_EXPECTED_CONT_IDX Macro ",
							" C #define FW_IMAGE_EXPECTED_CONT_IDX 1 ",
							" Description Firmware Image Expected Continuous Index ",
							" FW_IMAGE_EXPECTED_PL_LEN Macro ",
							" C #define FW_IMAGE_EXPECTED_PL_LEN 0xE0 ",
							" Description Firmware Image Expected Payload Length ",
							" HEADER_SIZE Macro ",
							" C #define HEADER_SIZE 512 ",
							" Description The size of the reserved header block ",
							" IMG_MEM_TOPOLOGY_COUNT Macro ",
							" C /** Image Memory Topology Count - Number of Image memory slots */ #define IMG_MEM_TOPOLOGY_COUNT 1 //5 ",
							" Description Image Memory Topology Count - Number of Image memory slots ",
							" MAX_AUTH_KEY_LEN Macro ",
							" C #define MAX_AUTH_KEY_LEN 48 ",
							" Description Maximum Authentication Key Length ",
							" MAX_MEM_TOPOLOGIES Macro ",
							" C /** Maximum memory topologies on the device (one SRAM and one Flash)) */ #define MAX_MEM_TOPOLOGIES 2 ",
							" Description Maximum memory topologies on the device (one SRAM and one Flash)) ",
							" MAX_SLOTS Macro ",
							" C #define MAX_SLOTS 3 ",
							" Description The maximum possible number of slots (one SRAM slot and 2 Flash slots)) ",
							" METADATA_HEADER_SIZE Macro ",
							" C #define METADATA_HEADER_SIZE 0x200 ",
							" Description Size of the MetaData header ",
							" SLOT_PARAMS Struct ",
							" C typedef struct { // Header Offset uint32_t hdrOffset; // Slot Size uint32_t slotSize[2]; // Executable flag bool executable; }SLOT_PARAMS; ",
							" Description Defines the slot information ",
							" SLOT0_BASE_ADDR Macro ",
							" C #define SLOT0_BASE_ADDR 0x01000000 ",
							" Description Base Address of Slot 0 ",
							" SLOT0_FIRMWARE Macro ",
							" C #define SLOT0_FIRMWARE (SLOT0_BASE_ADDR + METADATA_HEADER_SIZE) ",
							" Description Slot 0 Firmware Start Address ",
							" SLOT0_HEADER Macro ",
							" C #define SLOT0_HEADER SLOT0_BASE_ADDR ",
							" Description Slot 0 Header Start Address ",
							" SLOT1_BASE_ADDR Macro ",
							" C #define SLOT1_BASE_ADDR 0x01080000 ",
							" Description Base Address of Slot 1 ",
							" SLOT1_FIRMWARE Macro ",
							" C #define SLOT1_FIRMWARE (SLOT1_BASE_ADDR + METADATA_HEADER_SIZE) ",
							" Description Slot 1 Firmware Start Address ",
							" SLOT1_HEADER Macro ",
							" C #define SLOT1_HEADER SLOT1_BASE_ADDR ",
							" Description Slot 1 Header Start Address ",
							" UNAUTH_FW_SIZE Macro ",
							" C #define UNAUTH_FW_SIZE 0xFFFFFFFF ",
							" Description Size of the UnAuthenticated Firmware Size - For Error purpose ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" DEVICE_CONTEXT Struct ",
							" C typedef struct { // Valid Toplogies const IMG_MEM_TOPOLOGY * validTops[MAX_MEM_TOPOLOGIES]; // Valid slots information VALID_SLOT validSlots[MAX_SLOTS]; // Number of Topologies uint8_t topologyCount; // Number of slots uint8_t slotCount; } DEVICE_CONTEXT; ",
							" Description Defines the device context information ie valid tops and valid slots ",
							" IMG_MEM_INTERFACE Struct ",
							" C typedef struct { //Memory Initialize IMG_MEM_INITIALIZE fInit; // Memory Write IMG_MEM_WRITE fWrite; // Memory Read IMG_MEM_READ fRead; // Memory Erase IMG_MEM_ERASE fErase; // Memory Read JEDEC Identifier IMG_MEM_READ_JEDEC_ID fReadId; } IMG_MEM_INTERFACE; ",
							" Description Defines the image memory interface functions for initialization read write erase and read id ",
							" IMG_MEM_TOPOLOGY Struct ",
							" C typedef struct { uint16_t u16ErasePageSz; // Erase page size uint16_t u16ProgRowSz; // Programming row size uint32_t u32UmmAddrStart; // Unified memory model address start uint32_t u32TotSize; // Total flash size uint8_t u8SlotCount; // Count of slots in memory const SLOT_PARAMS * pSlots; // Pointer to array of slot structs uint32_t u32CalIdx; // Index of calibration data const IMG_MEM_INTERFACE * ifFlash; // Flash interface uint8_t u8DevIdCount; // Count of valid device IDs const uint32_t * pDevIds; // Pointer to array of device IDs uint32_t u32DevIdMask; // Device ID negative mask uint32_t u32AddrPosMask; // UMM address positive mask uint32_t u32AddrNegMask; // UMM addr negative mask uint32_t u32BlankCheck; // UMM addr negative mask }IMG_MEM_TOPOLOGY; ",
							" Description Defines the image memory interface topology defintions ",
							" VALID_SLOT Struct ",
							" C typedef struct { // Firmware Image Header FW_IMG_HDR * pHdr; // Slot Information const SLOT_PARAMS * pSlot; // Topology Information const IMG_MEM_TOPOLOGY * pTop; } VALID_SLOT; ",
							" Description Defines the valid slot information like header slot number etc ",
							" FW_IMG_HDR Struct ",
							" C typedef struct { // Meta Data Sequence Number uint32_t MD_SEQ_NUM; // Meta Data Revision uint8_t MD_REV; // Meta Data Container Index uint8_t MD_CONT_IDX; // Meta Data Payload Length uint16_t MD_PL_LEN; // Meta Data Coherence uint32_t MD_COHERENCE; // Meta Data Authentication Method uint8_t MD_AUTH_METHOD; // Meta Data Authentication Key uint8_t MD_AUTH_KEY; // Meta Data Decryption Method uint8_t MD_DEC_METHOD; // Meta Data Decryption Key uint8_t MD_DEC_KEY; // Firmware Image Revision uint32_t FW_IMG_REV; // Firmware Image Source Address uint32_t FW_IMG_SRC_ADDR; // Firmware Image Destionation Address uint32_t FW_IMG_DST_ADDR; // Firmware Image Image Length uint32_t FW_IMG_LEN; // Firmware Image Authentication Method uint8_t FW_IMG_AUTH_METHOD; // Firmware Image Authentication Key uint8_t FW_IMG_AUTH_KEY; // Firmware Image Decryption Method uint8_t FW_IMG_DEC_METHOD; // Firmware Image Decryption Key uint8_t FW_IMG_DEC_KEY; // Firmware Image Signature uint8_t FW_IMG_SIG[96]; // PAT Image Source Address uint32_t PAT_IMG_SRC_ADDR; // PAT Image Destination Address uint32_t PAT_IMG_DST_ADDR; // PAT Image Length uint32_t PAT_IMG_LEN; // PAT Image Signature uint8_t PAT_IMG_SIG[96]; // MetaData Signature uint8_t MD_SIG[96]; } FW_IMG_HDR; ",
							" Description Defines the firmware image header information used in bootloader ",
							" IMG_MEM_AuthenticateHeaderStart Function ",
							" C bool IMG_MEM_AuthenticateHeaderStart(uint8_t * digest FW_IMG_HDR * hdr uint8_t * x uint8_t * y); ",
							" Description This function begin a header authentication operation Note: This function must not be called while the Public Key engine is in use ",
							" Parameters Param Description digest 48-byte buffer for the hash digest (maintain until authentication done) ctx A hash context (this must persist ) hdr Pointer to a firmware image header x The x term of an ECDSA P-384 public key y The y term of an ECDSA P-384 public key ",
							" Returns status of the authentication start ",
							" IMG_MEM_FindValidTopologies Function ",
							" C void IMG_MEM_FindValidTopologies(DEVICE_CONTEXT * ctx); ",
							" Description This function populate the DEVICE_CONTEXT structure with the valid topologies for the device and the count of valid topologies ",
							" Parameters Param Description ctx Device context ",
							" Returns None ",
							" IMG_MEM_SlotSort Function ",
							" C void IMG_MEM_SlotSort(DEVICE_CONTEXT * ctx); ",
							" Description This function sorts valid slots by priority ",
							" Parameters Param Description ctx A device context structure with cached and validated header pointers in the header slots ",
							" Returns None ",
							" IMG_MEM_ValidateHeader Function ",
							" C bool IMG_MEM_ValidateHeader(DEVICE_CONTEXT * ctx FW_IMG_HDR * fwHdr); ",
							" Description This function validate a header Criteria - Metadata revision Sequence number (not 0 or 0xFFFFFFFF) rollback counter image len % 4096 = 0 firmware and header auth method is ECDSA on P-384 encryption methods are None Firmware image header is 0xE0 bytes metadata container index is 1 ",
							" Parameters Param Description ctx A device context structure fwHdr Firmware image header pointer top Pointer to an image memory topology ",
							" Returns FW_IMG_HDR Firmware image header pointer ",
							" C IMG_MEM_TOPOLOGY* IMG_MEM_GetTopologyByAddress (DEVICE_CONTEXT * ctx ",
							" Description This function returns a topology based on a specific address Prerequisite: ctx initialized with FindValidTopologies ",
							" Parameters Param Description ctx A device context structure address address to get topology top Pointer to an image memory topology ",
							" Returns IMG_MEM_TOPOLOGY topology pointer or NULL ",
							" IMG_MEM_AuthenticateHeaderStatusGet Function ",
							" C AUTH_STATUS IMG_MEM_AuthenticateHeaderStatusGet(void); ",
							" Description This function check the status of a header authentication operation Prerequisite: Header authentication started with IMG_MEM_AuthenticateHeaderStart ",
							" Parameters None ",
							" Returns AUTH_STATUS Success failure or busy (no result available) ",
							" IMG_MEM_CacheAndValidateHeaders Function ",
							" C void IMG_MEM_CacheAndValidateHeaders(DEVICE_CONTEXT * ctx uint8_t * buffer); ",
							" Description This function cache validate and sort headers from all firmware image slots for valid topologies Prerequisite: ctx initialized with FindValidTopologies ",
							" Parameters Param Description ctx A device context structure buffer A buffer for cached headers (HEADER_SIZE MAX_SLOTS bytes) ",
							" Returns None ",
							" IMG_MEM_CacheHeader Function ",
							" C FW_IMG_HDR* IMG_MEM_CacheHeader(DEVICE_CONTEXT * ctx ",
							" Description This function cache a header from a firmware image slot ",
							" Parameters Param Description ctx A context structure top Pointer to an image memory topology pSlot The image header slot to cache the header from buffer Pointer to a buffer in which to cache the header bufSlot Offset in the buffer in HEADER_SIZE units If a header is cached the contents of this pointer will be incremented by 1 ",
							" Returns FW_IMG_HDR Firmware image header pointer ",
							" DFU API Usage  The following macros typedef functions defintions help to understand DFU functionality of bootloader  ",
							" dfu Function ",
							" C void dfu(const IMG_MEM_TOPOLOGY ** tops uint8_t count); ",
							" Description This routine will initiate the device firmware upgrade where it waits for commands and response for commands received from serial ",
							" Parameters Param Description IMG_MEM_TOPOLOGY tops valid toplogies list uint8_t count number of valid topologies ",
							" Returns None ",
							" program_exec_main Function ",
							" C int32_t program_exec_main(const IMG_MEM_TOPOLOGY ** tops uint8_t count); ",
							" Description This routine is the entry point for the programming executive It receives commands from the host dispatches the command and then sends response back to the host ",
							" Parameters Param Description IMG_MEM_TOPOLOGY tops valid toplogies list uint8_t count number of valid topologies ",
							" Returns None ",
							" Crc32Init Function ",
							" C void Crc32Init(uint16_t seed); ",
							" Description This routine initializes the CRC32 operation ",
							" Parameters Param Description uint16_t seed seed for CRC calculation ",
							" Returns None ",
							" Crc32Add Function ",
							" C void Crc32Add(uint8_t* pBuff uint32_t bSize); ",
							" Description This routine adds the given data into CRC32 caculation and calculates CRC ",
							" Parameters Param Description uint8_t pBuff pointer to the data to add uint32_t bSize size of the data to add ",
							" Returns None ",
							" Crc32Result Function ",
							" C uint32_t Crc32Result(void); ",
							" Description This routine gets/returns the calculated CRC ",
							" Parameters None ",
							" Returns uint32_t - Calculated CRC ",
							" UART_ERROR Enum ",
							" C typedef enum { // UART - No Error UART_ERROR_NONE = 0 // UART - Overrun error UART_ERROR_OVERRUN = 0x02 // UART - Framing error UART_ERROR_FRAMING = 0x04 // UART - Parity error UART_ERROR_PARITY = 0x08 } UART_ERROR; ",
							" UART_Init Function ",
							" C void UART_Init(void); ",
							" Description This function initializes UART for read notifcation and thershold setting ",
							" Parameters None ",
							" Returns None ",
							" UART_Read Function ",
							" C uint32_t UART_Read(uint8_t *rb const uint32_t len const int32_t wait); ",
							" Description This function reads the SERCOM UART for the given length ",
							" Parameters Param Description rb read buffer len length to read wait wait timeout ",
							" Returns None ",
							" UART_Write Function ",
							" C void UART_Write(int8_t *wb uint32_t len); ",
							" Description This function writes the given buffer in SERCOM UART for the given length ",
							" Parameters Param Description wb write buffer len length to write ",
							" Returns None ",
							" PIC32CX-BZ3 System Services  This page has the necessary supporting documentation to get started with application development on PIC32CX-BZ3 and WBZ35x Family of devices  ",
							" PIC32CX-BZ3 Secure Boot ROM Help  The Boot ROM allows to ensure the integrity of the device at boot  An immutable boot sequence (Secure Boot Code) is implemented into a ROM called the Secure Boot ROM The Secure Boot ROM manages Test mode entry firmware and data authentication firmware loading and necessary system configurations  For secure boot support on the PIC32CX-BZ3 a 64K ROM is dedicated to the secure boot firmware Keys and credentials required for code authentication are stored as a part of eFuses On every reset secure boot firmware authenticates the rest of the program image in the Flash  Features  Immutable boot support with ROM  Firmware code authentication (Only at Boot time)  Support for immutable keys  Microchip or customer programmable secure boot key  Support for secure execution environment  Supports Anti-roll back  Support for firmware readable life cycle counter  Defined system boot state   Boot ROM Flow   Boot ROM Flow    Once the device comes out of reset Boot ROM firmware checks if Test mode is triggered if not it continues with chip initialization After the completion of chip initialization the bootstrap code checks for a valid firmware image and executes If the device does not find any valid image it jumps to Secure Safe mode For validating the firmware image the bootstrap code uses the security library depending on the firmware images authentication scheme specified for that firmware  Firmware programming is handled by Device Firmware Update (DFU) using Device Service Unit (DSU) DSU supports the Debug mode also it implements a CoreSight Debug ROM that provides device identification as well as identification of other debug components within the system See Device Service Unit (DSU) from Related Links  The following options are valid images for a PIC32CX-BZ3 device:  An image with valid structure (defined in Table   1 ) and without using any authentication scheme  An image with a valid structure (defined in Table   1 ) with an authentication scheme supported by the device For supporting the authentication scheme using public key cryptography EFUSE must have a valid SECURE_BOOT_KEY  If the device is secured (with SECURE_BOOT_KEY = 0) the valid image must always use the ECDSA p384 + SHA 384 or ECDSA p256 + SHA 256 for authentication   Firmware Image Format  Firmware image comes with a metadata header metadata payload and metadata footer that gives the ROM firmware information about location of the firmware image security decryption/ authentication information sequence number and more Application (Firmware Image) can only be executed from Embedded Flash or Boot Flash  The following table provides details about the contents of each firmware image   Firmware Image Description        Offset  Name  Description      Metadata Header    0x00:0x03  SEQ_NUM   Metadata sequence number of the image in Little Endian  (LE) Monotonically decreasing image index Values of 0 or  0xFFFFFFFF indicate that the image is invalid Boot ROM  Image selection algorithm will prefer a valid image with lowest sequence number     0x04  MD_REV   Support Metadata Header Version  Note:  This field must be set to 0x01 for this version of metadata header     0x05  CONT_IDX  0x01 – Plain firmware image    0x06:0x09  IDENTIFIER  MCHP ASCII String Identifier    0x0A  MD_AUTH_MTHD   Metadata authentication method  0x00 – None  0x02 – ECDSA p256 + SHA256  0x03 – ECDSA p256 + SHA2-384     0x0B  MD_AUTH_KEY   Key index for authenticating metadata  0x00 – Secure boot Key     0x0C  PL_DEC_MTHD   Payload decryption method  0x00 – Plain     0x0D  PL_DEC_KEY  Not applicable    0x0E:0x0F  PL_LEN  Metadata payload length The payload length for this version must be 0x74    Metadata Payload = Firmware Image Header    0x10:0x13  FW_IMG_REV  Firmware image revision (little endian)    0x14:0x17  FW_IMG_SRC_ADDR   Firmware Image source address  The source address of the firmware image in persistent storage This field is not authenticated and the OTA or Bootloader can rewrite it based on the image storage location selected     0x18:0x1B  FW_IMG_DST_ADDR   Firmware image destination address  The destination address will be used as the jump address during the application transition As the ROM firmware must copy this header structure into executable memory the destination address must not be less than 0x200     0x1C:0x1F  FW_IMG_LEN   Firmware image length  The firmware image length must be a multiple of 4096 (Count) bytes     0x20  FW_IMG_AUTH_MTHD   Firmware image authentication method  0x00 – None  0x02 – ECDSA p256 + SHA-256  0x03 – ECDSA p384 + SHA2-384     0x21  FW_IMG_AUTH_KEY   Firmware image authentication key index  0x00 – Secure boot key     0x22  FW_IMG_DEC_MTHD   Firmware image decryption method  0x00 – Plain     0x23  FW_IMG_DEC_KEY  Not applicable    0x24:0x83  FW_IMG_SIG   The following are the options of firmware image signature: The concatenated R and S term of the ECDSA signature (P-256) of the SHA-256 hash of the firmware image specified by FW_IMG_SRC_ADDR and FW_IMG_LEN  (or)  The concatenated R and S term of the ECDSA signature (P-384) of the SHA-384 hash of the firmware image specified by FW_IMG_SRC_ADDR and FW_IMG_LEN     Metadata Footer     0x84:0xE3  MD_SIG   The following are the options of metadata payload signature: The concatenated R and S term of the ECDSA signature (P-256) of the SHA-256 hash of the firmware image specified by FW_IMG_SRC_ADDR and FW_IMG_LEN  (or)  The concatenated R and S term of the ECDSA signature (P-384) of the SHA-384 hash of the firmware image specified by FW_IMG_SRC_ADDR and FW_IMG_LEN        Firmware Images Lookup Table         Address  Size (bytes)      Image 0 metadata  0x0080_0000  512    Image 0  0x0080_0200  15872    Image 2 metadata  0x0100_0000  512    Image 2  0x0100_0200  Max: 523776    Image 3 metadata  0x0104_0000  512    Image 3  0x0104_0200  Max: 261632       Boot Flash image 0  Embedded Flash image 0  Embedded Flash image 1 in the second panel (only possible if the image is less than 256 KB; including headers)   For an embedded Flash only device the ROM firmware checks for a valid image in three memory locations see Table   2   DSU Mode Entry  Immediately after resetting the ROM firmware reads the condition of Code Protect and Device Secured State bits to determine the Device Security state Security state the ROM firmware needs to perform specific actions  Serial Debugging and Programming   The device is not code-protected and unsecured supports debugging and programming features  The device is code-protected and unsecured supports debugging erase and programming features  The device is not code-protected and secured does not support the debugging feature and supports the programming feature  The device is not code-protected and secured does not support the debugging feature erase and supports the programming feature   Chip Initialization  All the necessary hardware modules that the BOOT ROM program uses will be initialized – System clock Interrupts and more  Firmware Authentication and Loading  The firmware image validation block is the primary block that ensures the integrity/authenticity of the images that are run on a secured device  Firmware Image Validation – Secured Mode  The following are the main blocks in the process of image validation:   READ_CFG - Read device configuration (device id secure elements) Secure elements and device id information can be accessed from EFUSE memory  LOOKUP_METADATA - Search for valid firmware image metadata with the lowest sequence number  AUTHENTICATE_IMAGE - Authenticate the image based on the security configuration of the device (EFUSE) and as indicated by its metadata The firmware image header dictates the authentication scheme Secure Boot is done on successful authentication of the firmware  RUN_APPLICATION - If the valid image is in embedded flash and is available in its destination address space jump to the DST_ADDR as indicated by its metadata  SECURE_SAFE_MODE - Secure Safe mode is a while 1() loop in the firmware where the device is waiting for a valid application image to execute   Firmware Image Validation – Unsecured Mode  In the Unsecured mode the device is not checked for authentication scheme that needs SECURE_BOOT_KEY  If the device is unsecured (and SECURE_BOOT_KEY is invalid and the Device Secured state is not set) the bootstrap code looks for valid images (valid sequence number header and more ) Root of trust cannot be possible in this scenario  ",
							" PIC32CX-BZ3 Secure Boot ROM Usage PIC32CX-BZ3 Secure Boot ROM Library Usage  Configuring the library  There is no configuration of this library  Using the library  This is the start of your topic  ",
							" SX_symcrypt_API Enter a short description of your topic here (optional)  This is the start of your topic  ",
							" True Random Number Generator (TRNG) ",
							" TRNG_API_H Macro ",
							" C #define TRNG_API_H @file @copyright Copyright (c) 2020 Silex Insight All Rights reserved The TRNG uses the hardware to generate random number with a high level of entropy It's intended to feed entropy into a DRBG ",
							" Configuration parameters for the TRNG */ struct sx_trng_config { ",
							" FIFO level below which the module leaves the idle state to refill the FIFO In numbers of 128-bit blocks Set to 0 to use default unsigned int wakeup_level; ",
							" Number of clock cycles to wait before sampling data from the noise source Set to 0 to use default unsigned int init_wait; ",
							" Number of clock cycles to wait before stopping the rings after the FIFO is full Set to 0 to use default unsigned int off_time_delay; ",
							" Clock divider for the frequency at which the outputs of the rings are sampled Set to 0 to sample at APB interface clock frequency unsigned int sample_clock_div; }; ",
							" TRNG initialization ",
							" SX_TRNG_INIT Macro ",
							" C typedef int (FUNC_SX_TRNG_INIT)(struct sx_trng ctx const struct sx_trng_config config); #define SX_TRNG_INIT ((FUNC_SX_TRNG_INIT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_TRNG_INIT))) ",
							" Parameters ctx TRNG context to be used in other operations ",
							" Parameters config pointer to optional configuration NULL to use default @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW ",
							" Get random bytes When this function returns ::SX_OK p size random bytes have been written to the p dst memory location If not enough random bytes are available the function does not write any data to p dst and returns ::SX_ERR_INSUFFICIENT ",
							" Parameters ctx TRNG context to be used in other operations ",
							" Parameters dst Destination in memory to copy p size bytes to ",
							" Parameters size length in bytes @return ::SX_OK @return ::SX_ERR_INSUFFICIENT @return ::SX_ERR_HARDWARE_FAILURE ",
							" Status/error codes of sxsymcrypt functions ",
							" STATUSCODES_API_FILE Macro ",
							" C #define STATUSCODES_API_FILE @file @copyright Copyright (c) 2019 Silex Insight All Rights reserved ",
							" The function or operation succeeded */ ",
							" Waiting on the hardware to process this operation */ ",
							" SX_ERR_HW_PROCESSING Macro ",
							" C #define SX_ERR_HW_PROCESSING -1 ",
							" No hardware available for a new operation Retry later */ ",
							" No compatible hardware for this operation ",
							" SX_ERR_INCOMPATIBLE_HW Macro ",
							" C #define SX_ERR_INCOMPATIBLE_HW -3 This error occurs if the dedicated hardware to execute the operation is not present or hardware is present and operation not supported by it ",
							" Invalid authentication tag in authenticated decryption */ ",
							" Hardware DMA error ",
							" SX_ERR_DMA_FAILED Macro ",
							" C #define SX_ERR_DMA_FAILED -32 Fatal error that should never happen Can be caused by invalid or wrong addresses RAM corruption a hardware or software bug or system corruption ",
							" Fatal error trying to call a function with an uninitialized object ",
							" SX_ERR_UNITIALIZED_OBJ Macro ",
							" C #define SX_ERR_UNITIALIZED_OBJ -33 For example calling sx_aead_decrypt() with an sxaead object which has not been created yet with sx_aead_create_() function ",
							" Fatal error trying to call an AEAD or block cipher create function with an ",
							" SX_ERR_INVALID_KEYREF Macro ",
							" C #define SX_ERR_INVALID_KEYREF -34 uninitialized or invalid key reference Examples: calling sx_blkcipher_create_aesecb() with a key reference which has not been initialized yet with sx_keyref_load_material() or sx_keyref_load_by_id() function sx_keyref_load_material() was called with key NULL or size 0 or sx_keyref_load_by_id() was called with an invalid index ID ",
							" Fatal error trying to create instance with not enough memory */ ",
							" Input or output buffer size too large */ ",
							" SX_ERR_TOO_BIG Macro ",
							" C #define SX_ERR_TOO_BIG -64 ",
							" Input or output buffer size too small */ ",
							" The given key size is not supported by the algorithm or the hardware */ ",
							" SX_ERR_INVALID_KEY_SZ Macro ",
							" C #define SX_ERR_INVALID_KEY_SZ -66 ",
							" Input tag size is invalid */ ",
							" Input nonce size is invalid */ ",
							" SX_ERR_INVALID_NONCE_SIZE Macro ",
							" C #define SX_ERR_INVALID_NONCE_SIZE -68 ",
							" Too many feeds were inputed */ ",
							" Input data size granularity is incorrect */ ",
							" SX_ERR_WRONG_SIZE_GRANULARITY Macro ",
							" C #define SX_ERR_WRONG_SIZE_GRANULARITY -70 ",
							" Attempt to use HW keys with a mode that does not support HW keys */ ",
							" Attempt to use a mode or engine that does not support context saving */ ",
							" SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED Macro ",
							" C #define SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED -72 ",
							" Attempt to feed AAD after input data was fed */ ",
							" Hardware cannot work anymore To recover reset the hardware ",
							" Cryptographic message hashing SM3 ",
							" SXSYMCRYPT_SM3_API_FILE Macro ",
							" C #define SXSYMCRYPT_SM3_API_FILE @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved ",
							" GM/T 0004-2012: SM3 cryptographic hash algorithm */ extern const struct sxhashalg SXHASHALG_SM3; This function initializes the user allocated object p c with a new hash operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions ",
							" Parameters c hash operation context ",
							" Parameters csz size of the hash operation context @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | SM3 digest size is 32 bytes int SX_HASH_CREATE_SM3(struct sxhash c size_t csz); ",
							" Cryptographic message hashing SHA-2 ",
							" SXSYMCRYPT_SHA2_API_FILE Macro ",
							" C #define SXSYMCRYPT_SHA2_API_FILE @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved ",
							" Hash algorithm SHA-2 224 ",
							" SXHASHALG_SHA2_224 Macro ",
							" C #define SXHASHALG_SHA2_224 ((const struct sxhashalg )((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SXHASHALG_SHA2_224))) Has only 32 bit capacity against length extension attacks ",
							" Hash algorithm SHA-2 256 ",
							" SXHASHALG_SHA2_256 Macro ",
							" C #define SXHASHALG_SHA2_256 ((const struct sxhashalg )((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SXHASHALG_SHA2_256))) Has no resistance against length extension attacks ",
							" Hash algorithm SHA-2 384 ",
							" SXHASHALG_SHA2_384 Macro ",
							" C #define SXHASHALG_SHA2_384 ((const struct sxhashalg )((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SXHASHALG_SHA2_384))) Has 128 bit capacity against length extension attacks ",
							" Hash algorithm SHA-2 512 ",
							" SXHASHALG_SHA2_512 Macro ",
							" C #define SXHASHALG_SHA2_512 ((const struct sxhashalg )((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SXHASHALG_SHA2_512))) Has no resistance against length extension attacks ",
							" Prepares a SHA256 hash operation context ",
							" SX_HASH_CREATE_SHA256 Macro ",
							" C typedef int (FUNC_SX_HASH_CREATE_SHA256)(struct sxhash c size_t csz); #define SX_HASH_CREATE_SHA256 ((FUNC_SX_HASH_CREATE_SHA256)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_CREATE_SHA256))) This function initializes the user allocated object p c with a new hash operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions ",
							" Parameters c hash operation context ",
							" Parameters csz size of the hash operation context @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | SHA256 digest size is 32 bytes ",
							" Prepares a SHA384 hash operation context ",
							" SX_HASH_CREATE_SHA384 Macro ",
							" C typedef int (FUNC_SX_HASH_CREATE_SHA384)(struct sxhash c size_t csz); #define SX_HASH_CREATE_SHA384 ((FUNC_SX_HASH_CREATE_SHA384)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_CREATE_SHA384))) This function initializes the user allocated object p c with a new hash operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions ",
							" Parameters c hash operation context ",
							" Parameters csz size of the hash operation context @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | SHA384 digest size is 48 bytes ",
							" Prepares a SHA512 hash operation context ",
							" SX_HASH_CREATE_SHA512 Macro ",
							" C typedef int (FUNC_SX_HASH_CREATE_SHA512)(struct sxhash c size_t csz); #define SX_HASH_CREATE_SHA512 ((FUNC_SX_HASH_CREATE_SHA512)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_CREATE_SHA512))) This function initializes the user allocated object p c with a new hash operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions ",
							" Parameters c hash operation context ",
							" Parameters csz size of the hash operation context @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | SHA512 digest size is 64 bytes ",
							" Prepares a SHA224 hash operation context This function initializes the user allocated object p c with a new hash operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions ",
							" Parameters c hash operation context ",
							" Parameters csz size of the hash operation context @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | SHA224 digest size is 28 bytes ",
							" Cryptographic message hashing SHA-1 ",
							" SXSYMCRYPT_SHA1_API_FILE Macro ",
							" C #define SXSYMCRYPT_SHA1_API_FILE @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved ",
							" Hash algorithm SHA-1 (Secure Hash Algorithm 1) ",
							" SXHASHALG_SHA1 Macro ",
							" C #define SXHASHALG_SHA1 ((const struct sxhashalg )((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SXHASHALG_SHA1))) Deprecated algorithm NIST formally deprecated use of SHA-1 in 2011 and disallowed its use for digital signatures in 2013 SHA-3 or SHA-2 are recommended instead ",
							" Prepares a SHA1 hash operation context This function initializes the user allocated object p c with a new hash operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions ",
							" Parameters c hash operation context ",
							" Parameters csz size of the hash operation context @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | SHA1 digest size is 20 bytes ",
							" Common functions used for generation a MAC (message authentication code) ",
							" MAC_API_FILE Macro ",
							" C #define MAC_API_FILE @file @copyright Copyright (c) 2020 Silex Insight All Rights reserved ",
							" Feeds data to be used for MAC generation ",
							" SX_MAC_FEED Macro ",
							" C typedef int (FUNC_SX_MAC_FEED)(struct sxmac c const char datain size_t sz); #define SX_MAC_FEED ((FUNC_SX_MAC_FEED)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_FEED))) The function will return immediately In order to start the operation SX_MAC_GENERATE() must be called ",
							" Parameters c MAC operation context ",
							" Parameters datain data to be processed with size p sz ",
							" Parameters sz size in bytes of data to be processed @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_BIG @return ::SX_ERR_FEED_COUNT_EXCEEDED | Param | Description | |:----- |:----------- | | @pre | sx_mac_create_() function must be called first | @remark | this function can be called even if data size p sz is 0 | | @remark | this function can be called multiple times to feed multiple chunks scattered in memory ",
							" Starts MAC generation operation ",
							" SX_MAC_GENERATE Macro ",
							" C typedef int (FUNC_SX_MAC_GENERATE)(struct sxmac c char mac); #define SX_MAC_GENERATE ((FUNC_SX_MAC_GENERATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_GENERATE))) This function is used to start MAC generation The function will return immediately The result will be transfered only after the operation is successfully completed The user shall check operation status with SX_MAC_STATUS() or SX_MAC_WAIT() ",
							" Parameters c MAC operation context ",
							" Parameters mac generated MAC @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_SMALL | Param | Description | |:----- |:----------- | | @pre | SX_MAC_FEED() function must be called first | @remark | if used with context saving(last chunk) the fed data size for the last chunk can not be 0 ",
							" Resumes MAC operation in context-saving ",
							" SX_MAC_RESUME_STATE Macro ",
							" C typedef int (FUNC_SX_MAC_RESUME_STATE)(struct sxmac c); #define SX_MAC_RESUME_STATE ((FUNC_SX_MAC_RESUME_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_RESUME_STATE))) This function shall be called when using context-saving to load the state that was previously saved by SX_MAC_SAVE_STATE() in the sxmac operation context p c It must be called with the same sxmac operation context p c that was used with SX_MAC_SAVE_STATE() It will reserve all hardware resources required to run the partial MAC operation After successful execution of this function the context p c can be passed to any of the block cipher functions except the sx_mac_create_() functions ",
							" Parameters c block cipher operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | sx_mac_create_() and SX_MAC_SAVE_STATE() functions must be called before for first part of the message | | @pre | must be called for each part of the message(besides first) before sx_mac_crypt() or SX_MAC_SAVE_STATE() | @remark | the user must not change the key until all parts of the message to be encrypted/decrypted are processed ",
							" Starts a partial MAC operation ",
							" SX_MAC_SAVE_STATE Macro ",
							" C typedef int (FUNC_SX_MAC_SAVE_STATE)(struct sxmac c); #define SX_MAC_SAVE_STATE ((FUNC_SX_MAC_SAVE_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_SAVE_STATE))) This function is used to start a partial MAC operation on data fed using SX_MAC_FEED() The function will return immediately The partial result will be transfered only after the operation is successfully completed The user shall check operation status with SX_MAC_STATUS() or SX_MAC_WAIT() ",
							" Parameters c block cipher operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED @return ::SX_ERR_TOO_SMALL @return ::SX_ERR_WRONG_SIZE_GRANULARITY | Param | Description | |:----- |:----------- | | @pre | sx_mac_crypt() should be called first | @remark | the user must not change the key until all parts of the message to be encrypted/decrypted are processed ",
							" Waits until the given MAC generation operation has finished ",
							" SX_MAC_WAIT Macro ",
							" C typedef int (FUNC_SX_MAC_WAIT)(struct sxmac c); #define SX_MAC_WAIT ((FUNC_SX_MAC_WAIT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_WAIT))) This function returns when the MAC generation operation was successfully completed or when an error has occurred that caused the operation to terminate The return value of this function is the operation status After this call all resources have been released and p c cannot be used again unless sx_mac_create_() is used ",
							" Parameters c MAC generation operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_DMA_FAILED @return ::SX_ERR_INVALID_TAG @see SX_MAC_STATUS() | Param | Description | |:----- |:----------- | | @remark | this function is blocking until operation finishes ",
							" Returns the MAC generation operation status If the operation is still ongoing return ::SX_ERR_HW_PROCESSING In that case the user can retry later When this function returns with a code different than ::SX_ERR_HW_PROCESSING the MAC generation operation has ended and all resources used by MAC generation operation context p c have been released In this case p c cannot be used for a new operation until one of the sx_mac_create_() functions is called again ",
							" Parameters c MAC operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_HW_PROCESSING @return ::SX_ERR_DMA_FAILED @return ::SX_ERR_INVALID_TAG | Param | Description | |:----- |:----------- | | @pre | SX_MAC_FEED() and SX_MAC_GENERATE() functions must be called first ",
							" Common function definitions for keys ",
							" KEYREF_API_FILE Macro ",
							" C #define KEYREF_API_FILE @file Copyright (c) 2020 Silex Insight All Rights reserved ",
							" Returns a reference to a key whose key material is in user memory ",
							" SX_KEYREF_LOAD_MATERIAL Macro ",
							" C typedef struct sxkeyref (FUNC_SX_KEYREF_LOAD_MATERIAL)(size_t keysz const char keymaterial); #define SX_KEYREF_LOAD_MATERIAL ((FUNC_SX_KEYREF_LOAD_MATERIAL)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_KEYREF_LOAD_MATERIAL))) This function loads the user provided key data and returns an initialized sxkeyref object The returned object can be passed to any of the sx_aead_create_() or sx_blkcipher_create_() functions ",
							" Parameters keysz size of the key to be loaded ",
							" Parameters keymaterial key to be loaded with size p keysz @return sxkeyref initialized object with provided inputs | Param | Description | |:----- |:----------- | | @remark | p keymaterial buffer should not be changed until the operation is completed ",
							" Returns a reference to a key selected by an index This function initializes a sxkeyref object to use predefined hardware keys Currently predefined hardware keys can be used with AES(BA411) and SM4(BA419) The returned object can be passed to any of the sx_aead_create_() or sx_blkcipher_create_() functions ",
							" Parameters keyindex index of the hardware key must be 0 or 1 @return sxkeyref initialized object with configuration of the hardware key index provided ",
							" Hardware interrupts ",
							" INTERRUPTS_API_FILE Macro ",
							" C #define INTERRUPTS_API_FILE @file @copyright Copyright (c) 2020 Silex Insight All Rights reserved ",
							" Prepares the hardware to use hardware interrupts ",
							" (FUNC_SX_INTERRUPTS_ENABLE)(void); Typedef ",
							" C typedef int (FUNC_SX_INTERRUPTS_ENABLE)(void); ",
							" SX_INTERRUPTS_ENABLE Macro ",
							" C #define SX_INTERRUPTS_ENABLE ((FUNC_SX_INTERRUPTS_ENABLE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_INTERRUPTS_ENABLE))) This function may be called only once before any function that starts an aead blkcipher or hash operation @return ::SX_OK @remark - hardware interrupts are not available for cmmask ",
							" Disables all hardware interrupts ",
							" (FUNC_SX_INTERRUPTS_DISABLE)(void); Typedef ",
							" C typedef int (FUNC_SX_INTERRUPTS_DISABLE)(void); This function may be called only when there is no ongoing hardware processing @return ::SX_OK ",
							" INTERNAL_HEADER_FILE Macro ",
							" C #define INTERNAL_HEADER_FILE ",
							" SX_EXTRA_IN_DESCS Macro ",
							" C #define SX_EXTRA_IN_DESCS 0 ",
							" SX_HASH_PRIV_SZ Macro ",
							" C #define SX_HASH_PRIV_SZ 344 ",
							" SX_BLKCIPHER_PRIV_SZ Macro ",
							" C #define SX_BLKCIPHER_PRIV_SZ 16 ",
							" A cryptomaster DMA descriptor */ struct sxdesc { char addr; struct sxdesc next; uint32_t sz; uint32_t dmatag; }; ",
							" Input and output descriptors and related state for cmdma */ struct sx_dmaslot { uint32_t cfg; struct sxdesc outdescs ; }; ",
							" DMA controller For internal use only Don't access directly struct sx_dmactl { struct sx_regs regs; struct sxdesc d; struct sxdesc out; char mapped; struct sx_dmaslot dmamem; }; ",
							" Key reference Used for making a reference to a key stored in memory or to a key selected by an identifier Created by SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() Used by blkcipher and aead creation functions All members should be considered INTERNAL and may not be accessed directly struct sxkeyref { const char key; size_t sz; uint32_t cfg; }; ",
							" An AEAD operation To be used with sx_aead_() functions All members should be considered INTERNAL and may not be accessed directly struct sxaead { const struct sx_aead_cmdma_cfg cfg; const char expectedtag; uint8_t tagsz; uint8_t headersz; uint32_t discardaadsz; uint32_t datainsz; uint64_t dataintotalsz; uint64_t totalaadsz; uint8_t granularity; int is_in_ctx; size_t ctxsz; unsigned int compatible; const struct sxkeyref key; struct sx_dmactl dma; struct sxdesc allindescs ; uint8_t extramem ; }; ",
							" A simple block cipher operation To be used with sx_blkcipher_() functions All members should be considered INTERNAL and may not be accessed directly struct sxblkcipher { const struct sx_blkcipher_cmdma_cfg cfg; size_t inminsz; size_t granularity; uint32_t mode; unsigned int compatible; const struct sxkeyref key; struct sx_dmactl dma; struct sxdesc allindescs ; char extramem ; }; ",
							" A hash operation To be used with sx_hash_() functions All members should be considered INTERNAL and may not be accessed directly struct sxhash { const struct sxhashalg algo; const struct sx_digesttags dmatags; uint32_t cntindescs; size_t totalsz; uint32_t feedsz; void(digest)(struct sxhash c char digest); struct sx_dmactl dma; struct sxdesc allindescs ; uint8_t extramem ; }; ",
							" A operation to load a countermeasures mask into the hardware To be used with sx_cm_() functions All members should be considered INTERNAL and may not be accessed directly struct sxcmmask { struct sx_dmactl dma; struct sxdesc allindescs ; }; To be used with sx_mac_() functions All members should be considered INTERNAL and may not be accessed directly struct sxmac { const struct sx_mac_cmdma_cfg cfg; uint32_t cntindescs; uint32_t feedsz; int macsz; unsigned int compatible; const struct sxkeyref key; struct sx_dmactl dma; struct sxdesc allindescs ; uint8_t extramem ; }; ",
							" Cryptographic HMAC(Keyed-Hash Message Authentication Code) ",
							" HMAC_API_FILE Macro ",
							" C #define HMAC_API_FILE The \"create operation\" functions are specific to HMAC For the rest the HMAC computation is done by using the following MAC API functions: SX_MAC_FEED() SX_MAC_GENERATE() SX_MAC_STATUS() and SX_MAC_WAIT() The current implementation of HMAC does not support context-saving @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved Examples: The following example shows typical sequence of function calls for computing the HMAC of a message @code SX_MAC_CREATE_HMAC_SHA256(ctx key) SX_MAC_FEED(ctx 'chunk 1') SX_MAC_FEED(ctx 'chunk 2') SX_MAC_GENERATE(ctx) SX_MAC_WAIT(ctx) @endcode ",
							" Prepares a HMAC SHA256 MAC operation ",
							" SX_MAC_CREATE_HMAC_SHA2_256 Macro ",
							" C typedef int (FUNC_SX_MAC_CREATE_HMAC_SHA256)(struct sxmac c struct sxkeyref keyref); #define SX_MAC_CREATE_HMAC_SHA2_256 ((FUNC_SX_MAC_CREATE_HMAC_SHA256)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_CREATE_HMAC_SHA2_256))) This function initializes the user allocated object p c with a new MAC operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions (except the ones that are specific to context-saving) ",
							" Parameters c MAC operation context ",
							" Parameters hmackey HMAC key ",
							" Parameters ksz size in bytes of the HMAC key can be any size @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY ",
							" Prepares a HMAC SHA384 MAC operation ",
							" SX_MAC_CREATE_HMAC_SHA2_384 Macro ",
							" C typedef int (FUNC_SX_MAC_CREATE_HMAC_SHA384)(struct sxmac c struct sxkeyref keyref); #define SX_MAC_CREATE_HMAC_SHA2_384 ((FUNC_SX_MAC_CREATE_HMAC_SHA384)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_CREATE_HMAC_SHA2_384))) This function initializes the user allocated object p c with a new MAC operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions (except the ones that are specific to context-saving) ",
							" Parameters c MAC operation context ",
							" Parameters hmackey HMAC key ",
							" Parameters ksz size in bytes of the HMAC key can be any size @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | p hmackey buffer should not be changed until the operation is completed ",
							" Prepares a HMAC SHA512 MAC operation ",
							" SX_MAC_CREATE_HMAC_SHA2_512 Macro ",
							" C typedef int (FUNC_SX_MAC_CREATE_HMAC_SHA2_512)(struct sxmac c struct sxkeyref keyref); #define SX_MAC_CREATE_HMAC_SHA2_512 ((FUNC_SX_MAC_CREATE_HMAC_SHA2_512)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_CREATE_HMAC_SHA2_512))) This function initializes the user allocated object p c with a new MAC operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions (except the ones that are specific to context-saving) ",
							" Parameters c MAC operation context ",
							" Parameters hmackey HMAC key ",
							" Parameters ksz size in bytes of the HMAC key can be any size @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | p hmackey buffer should not be changed until the operation is completed ",
							" Prepares a HMAC SHA1 MAC operation ",
							" SX_MAC_CREATE_HMAC_SHA1 Macro ",
							" C typedef int (FUNC_SX_MAC_CREATE_HMAC_SHA1)(struct sxmac c struct sxkeyref keyref); #define SX_MAC_CREATE_HMAC_SHA1 ((FUNC_SX_MAC_CREATE_HMAC_SHA1)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_MAC_CREATE_HMAC_SHA1))) This function initializes the user allocated object p c with a new MAC operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions (except the ones that are specific to context-saving) ",
							" Parameters c MAC operation context ",
							" Parameters hmackey HMAC key ",
							" Parameters ksz size in bytes of the HMAC key can be any size @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | p hmackey buffer should not be changed until the operation is completed ",
							" Prepares a HMAC SHA224 MAC operation This function initializes the user allocated object p c with a new MAC operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions (except the ones that are specific to context-saving) ",
							" Parameters c MAC operation context ",
							" Parameters hmackey HMAC key ",
							" Parameters ksz size in bytes of the HMAC key can be any size @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | p hmackey buffer should not be changed until the operation is completed ",
							" Cryptographic message hashing ",
							" HASH_API_FILE Macro ",
							" C #define HASH_API_FILE @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved Examples: The following examples show typical sequences of function calls for hashing a message @code Single-call hash computation SX_HASH_CREATE(ctx sxhashalg_sha2_256 ctxsize) SX_HASH_FEED(ctx 'chunk 1') SX_HASH_FEED(ctx 'chunk 2') SX_HASH_DIGEST(ctx) SX_HASH_WAIT(ctx) Context-saving hash computation First round: SX_HASH_CREATE(ctx sxhashalg_sha2_256 ctxsize) SX_HASH_FEED(ctx 'chunk 1 of first round') SX_HASH_FEED(ctx 'chunk 2 of first round') SX_HASH_SAVE_STATE(ctx) SX_HASH_WAIT(ctx) Intermediary rounds: SX_HASH_RESUME_STATE(ctx) SX_HASH_FEED(ctx 'chunk 1 of round i') SX_HASH_FEED(ctx 'chunk 2 of round i') SX_HASH_FEED(ctx 'chunk 3 of round i') SX_HASH_SAVE_STATE(ctx) SX_HASH_WAIT(ctx) Last round: SX_HASH_RESUME_STATE(ctx) SX_HASH_FEED(ctx 'chunk 1 of last round') SX_HASH_FEED(ctx 'chunk 2 of last round') SX_HASH_DIGEST(ctx) SX_HASH_WAIT(ctx) @endcode ",
							" Creates a hash operation context ",
							" SX_HASH_CREATE Macro ",
							" C typedef int (FUNC_SX_HASH_CREATE)(struct sxhash c const struct sxhashalg alg size_t csz); #define SX_HASH_CREATE ((FUNC_SX_HASH_CREATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_CREATE))) This function initializes the user allocated object p c with a new hash operation context and reserves the HW resource After successful execution of this function the context p c can be passed to any of the hashing functions ",
							" Parameters c hash operation context ",
							" Parameters alg hash algorithm ",
							" Parameters csz size of the hash operation context @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY ",
							" Return the digest size produced by the given hash algorithm */ ",
							" Return the block size used by the given hash algorithm */ ",
							" SX_HASH_GET_ALG_BLOCKSZ Macro ",
							" C typedef size_t (FUNC_SX_HASH_GET_ALG_BLOCKSZ)(const struct sxhashalg alg); #define SX_HASH_GET_ALG_BLOCKSZ ((FUNC_SX_HASH_GET_ALG_BLOCKSZ)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_GET_ALG_BLOCKSZ))) ",
							" Resume hashing in context-saving (partial hashing) ",
							" SX_HASH_RESUME_STATE Macro ",
							" C typedef int (FUNC_SX_HASH_RESUME_STATE)(struct sxhash c); #define SX_HASH_RESUME_STATE ((FUNC_SX_HASH_RESUME_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_RESUME_STATE))) This function shall be called when using context-saving to load the state that was previously saved by SX_HASH_SAVE_STATE() in the sxhash operation context p c It must be called with the same sxhash operation context p c that was used with SX_HASH_SAVE_STATE() It will reserve all hardware resources required to run the partial hashing ",
							" Parameters c hash operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ | Param | Description | |:----- |:----------- | | @pre | SX_HASH_SAVE_STATE() function must be called before | | @pre | must be called before SX_HASH_FEED() for the next partial message ",
							" Assign data to be hashed ",
							" SX_HASH_FEED Macro ",
							" C typedef int (FUNC_SX_HASH_FEED)(struct sxhash c const char chunk size_t sz); #define SX_HASH_FEED ((FUNC_SX_HASH_FEED)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_FEED))) This function adds a chunk of data to be hashed It can be called multiple times to assemble pieces of the message scattered in memory In context-saving the sum of the sizes of the chunks fed must be multiple of the block size of the algorithm used If this condition is not met before calling SX_HASH_SAVE_STATE() SX_HASH_SAVE_STATE() will return ::SX_ERR_WRONG_SIZE_GRANULARITY ",
							" Parameters c hash operation context ",
							" Parameters msg message to be hashed ",
							" Parameters sz size in bytes of p msg maximum value is 2^24-1 bytes @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_FEED_COUNT_EXCEEDED @return ::SX_ERR_TOO_BIG | Param | Description | |:----- |:----------- | | @pre | one of the SX_HASH_CREATE_() functions must be called first | | @pre | if in context-saving SX_HASH_RESUME_STATE() must be called first | @remark | if return value is ::SX_ERR_FEED_COUNT_EXCEEDED or ::SX_ERR_TOO_BIG p c cannot be used anymore | | @remark | if this function is called with p sz equal to 0 no data will be assigned to be hashed ::SX_OK will be returned | | @remark | default maximum number of feeds for single-call digest is 6 and for context-saving is 4 | | @remark | maximum sum of the chunk sizes fed is 2^32-1 bytes ",
							" Starts the partial hashing operation ",
							" SX_HASH_SAVE_STATE Macro ",
							" C typedef int (FUNC_SX_HASH_SAVE_STATE)(struct sxhash c); #define SX_HASH_SAVE_STATE ((FUNC_SX_HASH_SAVE_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_SAVE_STATE))) This function updates the partial hashing based on the data chunks fed since the last call to SX_HASH_RESUME_STATE() In order to export the state of partial hashing the total size of data fed in the current resume-save step must be multiple of block size of the algorithm used For SHA1/224/256/SM3 block size is 64 bytes and for SHA384/512 block size is 128 bytes The function will return immediately The hash state will be saved in the sxhash structure after the operation successfully completed The user shall check operation status with SX_HASH_STATUS() or SX_HASH_WAIT() ",
							" Parameters c hash operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_WRONG_SIZE_GRANULARITY | Param | Description | |:----- |:----------- | | @pre | one of the SX_HASH_CREATE_() functions or SX_HASH_RESUME_STATE() must be called first | @remark | if return value is ::SX_ERR_WRONG_SIZE_GRANULARITY p c cannot be used anymore | | @remark | the content of the input data buffers provided with previous calls to SX_HASH_FEED() should not be changed until the operation is completed Checking the completion of an operation is done by using SX_HASH_WAIT() or SX_HASH_STATUS() ",
							" Starts the hashing operation ",
							" SX_HASH_DIGEST Macro ",
							" C typedef int ( FUNC_SX_HASH_DIGEST)(struct sxhash c char digest); #define SX_HASH_DIGEST ((FUNC_SX_HASH_DIGEST)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_DIGEST))) This function is used to start the computation of the digest If used in context-saving approach this function will compute the digest based on last computed state and last chunks of the message The function will return immediately The result will be transfered to p digest only after the operation is successfully completed The user shall check operation status with SX_HASH_STATUS() or SX_HASH_WAIT() ",
							" Parameters c hash operation context ",
							" Parameters digest result of the hash operation user must allocate enough memory for it In order to get the amount of memory needed for the digest the user can use SX_HASH_GET_DIGESTSZ() or check the corresponding SX_HASH_CREATE_() function @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ | Param | Description | |:----- |:----------- | | @pre | one of the SX_HASH_CREATE_() functions must be called first | @remark | the content of the input data buffers provided with previous calls to SX_HASH_FEED() should not be changed until the operation is completed Checking the completion of an operation is done by using SX_HASH_WAIT() or SX_HASH_STATUS() ",
							" Waits until the given hash operation has finished ",
							" SX_HASH_WAIT Macro ",
							" C typedef int (FUNC_SX_HASH_WAIT)(struct sxhash c); #define SX_HASH_WAIT ((FUNC_SX_HASH_WAIT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_WAIT))) This function returns when the hash operation was successfully completed or when an error has occurred that caused the operation to terminate The return value of this function is the operation status After this call all resources have been released and p c cannot be used again unless SX_HASH_CREATE_() is used ",
							" Parameters c hash operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_HW_PROCESSING @return ::SX_ERR_DMA_FAILED | Param | Description | |:----- |:----------- | | @pre | SX_HASH_DIGEST() functions must be called first | | @pre | if in context-saving SX_HASH_SAVE_STATE() must be called first @see SX_HASH_STATUS() | @remark | this function is blocking until operation finishes | | @remark | this function calls SX_HASH_STATUS() in loop until operation is completed ",
							" Returns the status of the given hash operation context ",
							" SX_HASH_STATUS Macro ",
							" C typedef int (FUNC_SX_HASH_STATUS)(struct sxhash c); #define SX_HASH_STATUS ((FUNC_SX_HASH_STATUS)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_STATUS))) If the operation is still ongoing return ::SX_ERR_HW_PROCESSING In that case the user can retry later When this function returns with a code different than ::SX_ERR_HW_PROCESSING the hash operation has ended and all associated hardware resources used by hash operation context p c have been released If SX_HASH_DIGEST() was used p c cannot be used for a new operation until one of the SX_HASH_CREATE_() functions is called again If SX_HASH_SAVE_STATE() was used then p c shall be reused with sx_hash_resume() ",
							" Parameters c hash operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_HW_PROCESSING @return ::SX_ERR_DMA_FAILED | Param | Description | |:----- |:----------- | | @pre | SX_HASH_DIGEST() functions must be called first | | @pre | if in context-saving SX_HASH_SAVE_STATE() must be called first ",
							" Returns digest size in bytes for the hash operation context ",
							" SX_HASH_GET_DIGESTSZ Macro ",
							" C typedef size_t (FUNC_SX_HASH_GET_DIGESTSZ)(struct sxhash c); #define SX_HASH_GET_DIGESTSZ ((FUNC_SX_HASH_GET_DIGESTSZ)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_GET_DIGESTSZ))) ",
							" Parameters c hash operation context @return digest size in bytes of the algorithm specified by p c | Param | Description | |:----- |:----------- | | @pre | one of the SX_HASH_CREATE_() functions must be called first ",
							" Returns block size in bytes for the hash operation context ",
							" SX_HASH_GET_BLOCKSZ Macro ",
							" C typedef size_t (FUNC_SX_HASH_GET_BLOCKSZ)(struct sxhash c); #define SX_HASH_GET_BLOCKSZ ((FUNC_SX_HASH_GET_BLOCKSZ)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_HASH_GET_BLOCKSZ))) ",
							" Parameters c hash operation context @return block size in bytes of the algorithm specified by p c | Param | Description | |:----- |:----------- | | @pre | one of the SX_HASH_CREATE_() functions must be called first ",
							" Abandon a created hash operation context A created hash operation context can have reserved hardware and software resources Those are free-ed automatically on error or when the operation finishes as reported by SX_HASH_STATUS() or SX_HASH_WAIT() If for some reason the hash operation will not be started it can be abandoned which will release all reserved resources Can only be called after a call to one of the SX_HASH_CREATE_() or after sx_hash_resume() It must be called BEFORE starting to run the operation with SX_HASH_DIGEST() or SX_HASH_SAVE_STATE() ",
							" Parameters c hash operation context ",
							" AES counter-measures mask load ",
							" CMMASK_API_FILE Macro ",
							" C #define CMMASK_API_FILE @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved Examples: The following example shows typical sequence of function calls for loading the counter-measure mask @code SX_CM_LOAD_MASK(ctx value) SX_CM_LOAD_MASK_WAIT(ctx) @endcode ",
							" Loads random used in the AES counter-measures ",
							" SX_CM_LOAD_MASK Macro ",
							" C typedef int (FUNC_SX_CM_LOAD_MASK)(struct sxcmmask c uint32_t value); #define SX_CM_LOAD_MASK ((FUNC_SX_CM_LOAD_MASK)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_CM_LOAD_MASK))) Counter-measures are available for the AES if enabled in HW This function initializes the user allocated object p c with a new counter-measures mask load operation context and reserves the HW resource After the initialization of p c this function starts the load of the counter-measure cryptographically secure random p value The function will return immediately No data will be received for the load operation The operation is considered successful if the status returned by SX_CM_LOAD_MASK_WAIT() or SX_CM_LOAD_MASK_STATUS() is ::SX_OK ",
							" Parameters c counter-measures mask load operation context ",
							" Parameters value counter-measures random value to be loaded @return ::SX_OK @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @remark | it is under the user responsibility to call it after system boot (not automatically called) | | @remark | for more details see the technical report: \"Secure and Efficient | | Masking of AES | A Mission Impossible \" June 2004) ",
							" Waits until the given AES counter-measures load operation has finished ",
							" SX_CM_LOAD_MASK_WAIT Macro ",
							" C typedef int (FUNC_SX_CM_LOAD_MASK_WAIT)(struct sxcmmask c); #define SX_CM_LOAD_MASK_WAIT ((FUNC_SX_CM_LOAD_MASK_WAIT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_CM_LOAD_MASK_WAIT))) This function returns when the counter-measures load operation was successfully completed or when an error has occurred that caused the operation to terminate The return value of this function is the operation status After this call all resources have been released and p c cannot be used again unless SX_CM_LOAD_MASK() is used ",
							" Parameters c counter-measures mask load operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_DMA_FAILED | Param | Description | |:----- |:----------- | | @pre | SX_CM_LOAD_MASK() function must be called first @see SX_CM_LOAD_MASK_STATUS() | @remark | this function is blocking until operation finishes ",
							" Returns the status of the given AES counter-measures load operation context If the operation is still ongoing return ::SX_ERR_HW_PROCESSING In that case the user can retry later When this function returns with a code different than ::SX_ERR_HW_PROCESSING the counter-measures mask load operation has ended and all resources used by counter-measures mask load operation context p c have been released In this case p c cannot be used for a new operation until SX_CM_LOAD_MASK() is called again ",
							" Parameters c counter-measures mask load operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_HW_PROCESSING @return ::SX_ERR_DMA_FAILED | Param | Description | |:----- |:----------- | | @pre | SX_CM_LOAD_MASK() function must be called first ",
							" Message Authentication Code AES CMAC ",
							" CMAC_API_FILE Macro ",
							" C #define CMAC_API_FILE @file @copyright Copyright (c) 2020 Silex Insight All Rights reserved Examples: The following examples show typical sequences of function calls for generating a mac @code One-shot operation MAC generation SX_MAC_CREATE_AESCMAC(ctx ) SX_MAC_FEED(ctx ) SX_MAC_GENERATE(ctx) SX_MAC_WAIT(ctx) @endcode ",
							" Prepares an AES CMAC generation This function initializes the user allocated object p c with a new AES CMAC operation context needed to run the CMAC generation After successful execution of this function the context p c can be passed to any of the CMAC functions ",
							" Parameters c CMAC operation context ",
							" Parameters key key used for the CMAC generation operation expected size 16 24 or 32 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Common simple block cipher modes ",
							" BLKCIPHER_API_FILE Macro ",
							" C #define BLKCIPHER_API_FILE All block cipher modes here perform simple encryption and decryption without any authentication @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved Examples: The following examples show typical sequences of function calls for encryption and decryption of a message @code One-shot operation a Encryption sx_blkcipher_create_aescbc_enc(ctx ) SX_BLKCIPHER_CRYPT(ctx ) SX_BLKCIPHER_RUN(ctx) SX_BLKCIPHER_WAIT(ctx) b Decryption sx_blkcipher_create_aescbc_dec(ctx ) SX_BLKCIPHER_CRYPT(ctx ) SX_BLKCIPHER_RUN(ctx) SX_BLKCIPHER_WAIT(ctx) Context-saving operation a Encryption First round: sx_blkcipher_create_aescbc_enc(ctx) SX_BLKCIPHER_CRYPT(ctx 'first chunk') sx_blkcipher_save_state(ctx) SX_BLKCIPHER_WAIT(ctx) Intermediary rounds: sx_blkcipher_resume_state(ctx) SX_BLKCIPHER_CRYPT(ctx 'n-th chunk') sx_blkcipher_save_state(ctx) SX_BLKCIPHER_WAIT(ctx) Last round: sx_blkcipher_resume_state(ctx) SX_BLKCIPHER_CRYPT(ctx 'last chunk') SX_BLKCIPHER_RUN(ctx) SX_BLKCIPHER_WAIT(ctx) b Decryption First round: sx_blkcipher_create_aescbc_dec(ctx) SX_BLKCIPHER_CRYPT(ctx 'first chunk') sx_blkcipher_save_state(ctx) SX_BLKCIPHER_WAIT(ctx) Intermediary rounds: sx_blkcipher_resume_state(ctx) SX_BLKCIPHER_CRYPT(ctx 'n-th chunk') sx_blkcipher_save_state(ctx) SX_BLKCIPHER_WAIT(ctx) Last round: sx_blkcipher_resume_state(ctx) SX_BLKCIPHER_CRYPT(ctx 'last chunk') SX_BLKCIPHER_RUN(ctx) SX_BLKCIPHER_WAIT(ctx) @endcode ",
							" Prepares an AES XTS block cipher encryption ",
							" SX_BLKCIPHER_CREATE_AESXTS_ENC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESXTS_ENC)(struct sxblkcipher c const struct sxkeyref key1 const struct sxkeyref key2 const char iv); #define SX_BLKCIPHER_CREATE_AESXTS_ENC ((FUNC_SX_BLKCIPHER_CREATE_AESXTS_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESXTS_ENC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES XTS encryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key1 first key used for the block cipher operation expected size 16 24 or 32 bytes must be equal to p key2 size ",
							" Parameters key2 second key used for the block cipher operation expected size 16 24 or 32 bytes must be equal to p key1 size ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_HW_KEY_NOT_SUPPORTED @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key references provided by p key1 and p key2 must be initialized using SX_KEYREF_LOAD_MATERIAL() ",
							" Prepares an AES XTS block cipher decryption ",
							" SX_BLKCIPHER_CREATE_AESXTS_DEC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESXTS_DEC)(struct sxblkcipher c const struct sxkeyref key1 const struct sxkeyref key2 const char iv); #define SX_BLKCIPHER_CREATE_AESXTS_DEC ((FUNC_SX_BLKCIPHER_CREATE_AESXTS_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESXTS_DEC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES XTS decryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key1 first key used for the block cipher operation expected size 16 24 or 32 bytes must be equal to p key2 size ",
							" Parameters key2 second key used for the block cipher operation expected size 16 24 or 32 bytes must be equal to p key1 size ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_HW_KEY_NOT_SUPPORTED @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key references provided by p key1 and p key2 must be initialized using SX_KEYREF_LOAD_MATERIAL() ",
							" Prepares an AES CTR block cipher encryption ",
							" SX_BLKCIPHER_CREATE_AESCTR_ENC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESCTR_ENC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESCTR_ENC ((FUNC_SX_BLKCIPHER_CREATE_AESCTR_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESCTR_ENC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES CTR encryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Prepares an AES CTR block cipher decryption ",
							" SX_BLKCIPHER_CREATE_AESCTR_DEC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESCTR_DEC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESCTR_DEC ((FUNC_SX_BLKCIPHER_CREATE_AESCTR_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESCTR_DEC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES CTR decryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Prepares an AES ECB block cipher encryption ",
							" SX_BLKCIPHER_CREATE_AESECB_ENC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESECB_ENC)(struct sxblkcipher c const struct sxkeyref key); #define SX_BLKCIPHER_CREATE_AESECB_ENC ((FUNC_SX_BLKCIPHER_CREATE_AESECB_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESECB_ENC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES ECB encryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size is 16 24 or 32 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() | @remark | AES ECB does not support context saving ",
							" Prepares an AES ECB block cipher decryption ",
							" SX_BLKCIPHER_CREATE_AESECB_DEC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESECB_DEC)(struct sxblkcipher c const struct sxkeyref key); #define SX_BLKCIPHER_CREATE_AESECB_DEC ((FUNC_SX_BLKCIPHER_CREATE_AESECB_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESECB_DEC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES ECB decryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() | @remark | AES ECB does not support context saving ",
							" Prepares an AES CBC block cipher encryption ",
							" SX_BLKCIPHER_CREATE_AESCBC_ENC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESCBC_ENC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESCBC_ENC ((FUNC_SX_BLKCIPHER_CREATE_AESCBC_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESCBC_ENC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES CBC encryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Prepares an AES CBC block cipher decryption ",
							" SX_BLKCIPHER_CREATE_AESCBC_DEC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESCBC_DEC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESCBC_DEC ((FUNC_SX_BLKCIPHER_CREATE_AESCBC_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESCBC_DEC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES CBC decryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Prepares an AES CFB block cipher encryption ",
							" SX_BLKCIPHER_CREATE_AESCFB_ENC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESCFB_ENC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESCFB_ENC ((FUNC_SX_BLKCIPHER_CREATE_AESCFB_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESCFB_ENC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES CFB encryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Prepares an AES CFB block cipher decryption ",
							" SX_BLKCIPHER_CREATE_AESCFB_DEC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESCFB_DEC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESCFB_DEC ((FUNC_SX_BLKCIPHER_CREATE_AESCFB_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESCFB_DEC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES CFB decryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Prepares an AES OFB block cipher encryption ",
							" SX_BLKCIPHER_CREATE_AESOFB_ENC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESOFB_ENC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESOFB_ENC ((FUNC_SX_BLKCIPHER_CREATE_AESOFB_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESOFB_ENC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES OFB encryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Prepares an AES OFB block cipher decryption ",
							" SX_BLKCIPHER_CREATE_AESOFB_DEC Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CREATE_AESOFB_DEC)(struct sxblkcipher c const struct sxkeyref key const char iv); #define SX_BLKCIPHER_CREATE_AESOFB_DEC ((FUNC_SX_BLKCIPHER_CREATE_AESOFB_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CREATE_AESOFB_DEC))) This function initializes the user allocated object p c with a new block cipher operation context needed to run the AES OFB decryption and reserves the HW resource After successful execution of this function the context p c can be passed to any of the block cipher functions ",
							" Parameters c block cipher operation context ",
							" Parameters key key used for the block cipher operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 16 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() ",
							" Adds data to be encrypted/decrypted ",
							" SX_BLKCIPHER_CRYPT Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_CRYPT)(struct sxblkcipher c const char datain size_t sz char dataout); #define SX_BLKCIPHER_CRYPT ((FUNC_SX_BLKCIPHER_CRYPT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_CRYPT))) The function will return immediately In order to start the operation SX_BLKCIPHER_RUN() must be called p sz must ensure the following restrictions based on the mode used: ##Remarks Algorithm | p sz | --------: | :----------: | :----------- ECB | N 16 bytes | N 0 CBC | N 16 bytes | N 0 CFB | N 16 bytes | N 0 OFB | N 16 bytes | N 0 XTS | = 16 bytes | none CTR | 0 bytes | none The restrictions above are applicable ONLY for the last chunk of the data to be processed when doing a partial operation p sz must be a multiple of block size(16 bytes) when doing a partial operation(besides last chunk) ",
							" Parameters c block cipher operation context ",
							" Parameters datain data to be encrypted or decrypted with size p sz ",
							" Parameters sz size in bytes of data to be decrypted ",
							" Parameters dataout encrypted or decrypted data must have p sz bytes @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_BIG | Param | Description | |:----- |:----------- | | @pre | one of the sx_blkcipher_create_() functions must be called first ",
							" Starts a block cipher operation ",
							" SX_BLKCIPHER_RUN Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_RUN)(struct sxblkcipher c); #define SX_BLKCIPHER_RUN ((FUNC_SX_BLKCIPHER_RUN)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_RUN))) This function is used to start an encryption or a decryption based on what create function was used sx_blkcipher_create__enc() or sx_blkcipher_create__dec() The function will return immediately The result will be transfered only after the operation is successfully completed The user shall check operation status with sx_blkcipher_status() or SX_BLKCIPHER_WAIT() ",
							" Parameters c block cipher operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_SMALL @return ::SX_ERR_WRONG_SIZE_GRANULARITY | Param | Description | |:----- |:----------- | | @pre | SX_BLKCIPHER_CRYPT() function must be called first ",
							" Resumes AES operation in context-saving ",
							" SX_BLKCIPHER_RESUME_STATE Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_RESUME_STATE)(struct sxblkcipher c); #define SX_BLKCIPHER_RESUME_STATE ((FUNC_SX_BLKCIPHER_RESUME_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_RESUME_STATE))) This function shall be called when using context-saving to load the state that was previously saved by sx_blkcipher_save_state() in the sxblkcipher operation context p c It must be called with the same sxblkcipher operation context p c that was used with sx_sxblkcipher_save_state() It will reserve all hardware resources required to run the partial AES operation Previously used mode and direction are already stored in sxblkcipher p c After successful execution of this function the context p c can be passed to any of the block cipher functions except the sx_blkcipher_create_() functions ",
							" Parameters c block cipher operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | sx_blkcipher_create_aes() and sx_blkcipher_save_state() functions must be called before for first part of the message | | @pre | must be called for each part of the message(besides first) before sx_blkchiper_crypt() or sx_blkcipher_save_state() | @remark | the user must not change the key until all parts of the message to be encrypted/decrypted are processed | | @remark | AES ECB does not support context saving ",
							" Starts a partial block cipher operation ",
							" SX_BLKCIPHER_SAVE_STATE Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_SAVE_STATE)(struct sxblkcipher c); #define SX_BLKCIPHER_SAVE_STATE ((FUNC_SX_BLKCIPHER_SAVE_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_SAVE_STATE))) This function is used to start a partial encryption or decryption of p datain The function will return immediately The partial result will be transfered to p dataout only after the operation is successfully completed The user shall check operation status with sx_blkcipher_status() or SX_BLKCIPHER_WAIT() ",
							" Parameters c block cipher operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED | Param | Description | |:----- |:----------- | | @pre | SX_BLKCIPHER_CRYPT() should be called first | @remark | the user must not change the key until all parts of the message to be encrypted/decrypted are processed ",
							" Waits until the given block cipher operation has finished ",
							" SX_BLKCIPHER_WAIT Macro ",
							" C typedef int (FUNC_SX_BLKCIPHER_WAIT)(struct sxblkcipher c); #define SX_BLKCIPHER_WAIT ((FUNC_SX_BLKCIPHER_WAIT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_BLKCIPHER_WAIT))) This function returns when the block cipher operation was successfully completed or when an error has occurred that caused the operation to terminate The return value of this function is the operation status After this call all resources have been released and p c cannot be used again unless sx_blkcipher_create_() is used ",
							" Parameters c block cipher operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_DMA_FAILED @see sx_blkcipher_status() | Param | Description | |:----- |:----------- | | @remark | this function is blocking until operation finishes ",
							" Returns the block cipher operation status If the operation is still ongoing return ::SX_ERR_HW_PROCESSING In that case the user can retry later When this function returns with a code different than ::SX_ERR_HW_PROCESSING the block cipher operation has ended and all resources used by block cipher operation context p c have been released In this case p c cannot be used for a new operation until one of the sx_blkcipher_create_() functions is called again ",
							" Parameters c block cipher operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_HW_PROCESSING @return ::SX_ERR_DMA_FAILED | Param | Description | |:----- |:----------- | | @pre | SX_BLKCIPHER_CRYPT and SX_BLKCIPHER_RUN() functions must be called first ",
							" Authenticated encryption with associated data(AEAD) ",
							" AEAD_API_FILE Macro ",
							" C #define AEAD_API_FILE @file @copyright Copyright (c) 2019-2020 Silex Insight All Rights reserved Examples: The following examples show typical sequences of function calls for encryption and decryption a message @code One-shot operation a Encryption SX_AEAD_CREATE_AESGCM_ENC(ctx ) SX_AEAD_FEED_AAD(ctx aad aadsz) SX_AEAD_CRYPT(ctx datain datainz dataout) SX_AEAD_PRODUCE_TAG(ctx tag) SX_AEAD_WAIT(ctx) b Decryption SX_AEAD_CREATE_AESGCM_DEC(ctx ) SX_AEAD_FEED_AAD(ctx aad aadsz) SX_AEAD_CRYPT(ctx datain datainz dataout) SX_AEAD_VERIFY_TAG(ctx tag) SX_AEAD_WAIT(ctx) Context-saving operation a Encryption First round: SX_AEAD_CREATE_AESGCM_ENC(ctx) SX_AEAD_FEED_AAD(ctx aad aadsz) SX_AEAD_CRYPT(ctx 'first chunk') SX_AEAD_SAVE_STATE(ctx) SX_AEAD_WAIT(ctx) Intermediary rounds: SX_AEAD_RESUME_STATE(ctx) SX_AEAD_CRYPT(ctx 'n-th chunk') SX_AEAD_SAVE_STATE(ctx) SX_AEAD_WAIT(ctx) Last round: SX_AEAD_RESUME_STATE(ctx) SX_AEAD_CRYPT(ctx 'last chunk') SX_AEAD_PRODUCE_TAG(ctx tag) SX_AEAD_WAIT(ctx) b Decryption First round: SX_AEAD_CREATE_AESGCM_DEC(ctx) SX_AEAD_FEED_AAD(ctx aad aadsz) SX_AEAD_CRYPT(ctx 'first chunk') SX_AEAD_SAVE_STATE(ctx) SX_AEAD_WAIT(ctx) Intermediary rounds: SX_AEAD_RESUME_STATE(ctx) SX_AEAD_CRYPT(ctx 'n-th chunk') SX_AEAD_SAVE_STATE(ctx) SX_AEAD_WAIT(ctx) Last round: SX_AEAD_RESUME_STATE(ctx) SX_AEAD_CRYPT(ctx 'last chunk') SX_AEAD_VERIFY_TAG(ctx tag) SX_AEAD_WAIT(ctx) @endcode ",
							" Initialization vector (IV) size in bytes for GCM encryption/decryption */ ",
							" Size in bytes of GCM authentication tag */ ",
							" SX_GCM_TAG_SZ Macro ",
							" C #define SX_GCM_TAG_SZ 16u ",
							" Maximum size in bytes of CCM authentication tag */ ",
							" Prepares an AES GCM AEAD encryption operation ",
							" SX_AEAD_CREATE_AESGCM_ENC Macro ",
							" C typedef int (FUNC_SX_AEAD_CREATE_AESGCM_ENC)(struct sxaead c const struct sxkeyref key const char iv); #define SX_AEAD_CREATE_AESGCM_ENC ((FUNC_SX_AEAD_CREATE_AESGCM_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_CREATE_AESGCM_ENC))) This function initializes the user allocated object p c with a new AEAD encryption operation context needed to run the AES GCM operation and reserves the HW resource After successful execution of this function the context p c can be passed to any of the AEAD functions ",
							" Parameters c AEAD operation context ",
							" Parameters key key used for the AEAD operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 12 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() | @remark | p key and p iv buffers should not be changed until the operation is completed | | @remark | GMAC is supported by using GCM with plaintext with size 0 | | @remark | GCM and GMAC support AAD split in multiple chunks using context saving ",
							" Prepares an AES GCM AEAD decryption operation ",
							" SX_AEAD_CREATE_AESGCM_DEC Macro ",
							" C typedef int (FUNC_SX_AEAD_CREATE_AESGCM_DEC)(struct sxaead c const struct sxkeyref key const char iv); #define SX_AEAD_CREATE_AESGCM_DEC ((FUNC_SX_AEAD_CREATE_AESGCM_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_CREATE_AESGCM_DEC))) This function initializes the user allocated object p c with a new AEAD decryption operation context needed to run the AES GCM operation and reserves the HW resource After successful execution of this function the context p c can be passed to any of the AEAD functions ",
							" Parameters c AEAD operation context ",
							" Parameters key key used for the AEAD operation expected size 16 24 or 32 bytes ",
							" Parameters iv initialization vector size must be 12 bytes @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() | @remark | p key and p iv buffers should not be changed until the operation is completed | | @remark | GMAC is supported by using GCM with ciphertext with size 0 | | @remark | GCM and GMAC support AAD split in multiple chunks using context saving ",
							" Prepares an AES CCM AEAD encryption operation ",
							" SX_AEAD_CREATE_AESCCM_ENC Macro ",
							" C typedef int (FUNC_SX_AEAD_CREATE_AESCCM_ENC)(struct sxaead c const struct sxkeyref key const char nonce size_t noncesz size_t tagsz size_t aadsz size_t datasz); #define SX_AEAD_CREATE_AESCCM_ENC ((FUNC_SX_AEAD_CREATE_AESCCM_ENC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_CREATE_AESCCM_ENC))) This function initializes the user allocated object p c with a new AEAD encryption operation context needed to run the AES GCM operation and reserves the HW resource After successful execution of this function the context p c can be passed to any of the AEAD functions ",
							" Parameters c AEAD operation context ",
							" Parameters key key used for the AEAD operation expected size 16 24 or 32 bytes ",
							" Parameters noncesz size in bytes of the nonce between 7 and 13 bytes ",
							" Parameters nonce nonce used for the AEAD operation with size p noncesz ",
							" Parameters tagsz size in bytes of the tag used for the AEAD operation must be a value in {4 6 8 10 12 14 16} ",
							" Parameters aadsz size in bytes of the additional authenticated data(AAD) ",
							" Parameters datasz size in bytes of the data to be processed @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() | @remark | the same aadsz and datasz must be provided to sx_aead_encrypt() or sx_aead_decrypt() functions | | @remark | p key and p nonce buffers should not be changed until the operation is completed | | @remark | CCM DOES NOT support AAD split in multiple chunks ",
							" Prepares an AES CCM AEAD decryption operation ",
							" SX_AEAD_CREATE_AESCCM_DEC Macro ",
							" C typedef int (FUNC_SX_AEAD_CREATE_AESCCM_DEC)(struct sxaead c const struct sxkeyref key const char nonce size_t noncesz size_t tagsz size_t aadsz size_t datasz); #define SX_AEAD_CREATE_AESCCM_DEC ((FUNC_SX_AEAD_CREATE_AESCCM_DEC)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_CREATE_AESCCM_DEC))) This function initializes the user allocated object p c with a new AEAD decryption operation context needed to run the AES GCM operation and reserves the HW resource After successful execution of this function the context p c can be passed to any of the AEAD functions ",
							" Parameters c AEAD operation context ",
							" Parameters key key used for the AEAD operation expected size 16 24 or 32 bytes ",
							" Parameters noncesz size in bytes of the nonce between 7 and 13 bytes ",
							" Parameters nonce nonce used for the AEAD operation with size p noncesz ",
							" Parameters tagsz size in bytes of the tag used for the AEAD operation must be a value in {4 6 8 10 12 14 16} ",
							" Parameters aadsz size in bytes of the additional authenticated data(AAD) ",
							" Parameters datasz size in bytes of the data to be processed @return ::SX_OK @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | key reference provided by p key must be initialized using SX_KEYREF_LOAD_MATERIAL() or SX_KEYREF_LOAD_BY_ID() | @remark | the same aadsz and datasz must be provided to sx_aead_encrypt() or sx_aead_decrypt() functions | | @remark | p key and p nonce buffers should not be changed until the operation is completed | | @remark | CCM DOES NOT support AAD split in multiple chunks ",
							" Adds AAD chunks ",
							" SX_AEAD_FEED_AAD Macro ",
							" C typedef int (FUNC_SX_AEAD_FEED_AAD)(struct sxaead c const char aad size_t aadsz); #define SX_AEAD_FEED_AAD ((FUNC_SX_AEAD_FEED_AAD)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_FEED_AAD))) This function is used for adding AAD buffer given by p aad The function will return immediately ",
							" Parameters c AEAD operation context ",
							" Parameters aad additional authentication data(AAD) with size p aadsz ",
							" Parameters aadsz size in bytes of the additional authenticated data(AAD) can be 0 if p aad is empty @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_BIG | Param | Description | |:----- |:----------- | | @pre | one of the sx_aead_create_() functions must be called first | @remark | the additional authentication data can be empty( p aadsz = 0) | | @remark | p aad buffer should not be changed until the operation is completed ",
							" Adds data to be encrypted or decrypted ",
							" SX_AEAD_CRYPT Macro ",
							" C typedef int (FUNC_SX_AEAD_CRYPT)(struct sxaead c const char datain size_t datainsz char dataout); #define SX_AEAD_CRYPT ((FUNC_SX_AEAD_CRYPT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_CRYPT))) This function is used for adding data to be processed The function will return immediately The result of the operation will be transfered to p dataout after the operation is successfully completed For context saving p datain size( p datainsz) must be a multiple of 16 bytes for AES GCM and CCM and a multiple of 64 bytes for ChaCha20Poly1305 except the last buffer ",
							" Parameters c AEAD operation context ",
							" Parameters datain data to be encrypted or decryoted with size p datainsz ",
							" Parameters datainsz size in bytes of the data to be encrypted or decrypted ",
							" Parameters dataout encrypted or decrypted data must have p datainsz bytes @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_BIG | Param | Description | |:----- |:----------- | | @pre | one of the sx_aead_create_() functions must be called first | @remark | p datain buffer should not be changed until the operation is completed ",
							" Starts an AEAD encryption and tag computation ",
							" SX_AEAD_PRODUCE_TAG Macro ",
							" C typedef int (FUNC_SX_AEAD_PRODUCE_TAG)(struct sxaead c char tagout); #define SX_AEAD_PRODUCE_TAG ((FUNC_SX_AEAD_PRODUCE_TAG)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_PRODUCE_TAG))) The function will return immediately The computed tag will be transfered to p tag only after the operation is successfully completed The user shall check operation status with sx_aead_status() or SX_AEAD_WAIT() ",
							" Parameters c AEAD operation context ",
							" Parameters tag authentication tag @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_BIG | Param | Description | |:----- |:----------- | | @pre | one of the SX_AEAD_FEED_AAD() or SX_AEAD_CRYPT() functions must be called first | @remark | if used with context saving(last chunk) the fed data size for the last chunk can not be 0 ",
							" Starts an AEAD decryption and tag validation ",
							" SX_AEAD_VERIFY_TAG Macro ",
							" C typedef int (FUNC_SX_AEAD_VERIFY_TAG)(struct sxaead c const char tagin); #define SX_AEAD_VERIFY_TAG ((FUNC_SX_AEAD_VERIFY_TAG)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_VERIFY_TAG))) The function will return immediately The user shall check operation status with sx_aead_status() or SX_AEAD_WAIT() ",
							" Parameters c AEAD operation context ",
							" Parameters tag authentication tag @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_TOO_BIG | Param | Description | |:----- |:----------- | | @pre | one of the SX_AEAD_FEED_AAD() or SX_AEAD_CRYPT() functions must be called first | @remark | p tag buffer should not be changed until the operation is completed | | @remark | if used with context saving(last chunk) the fed data size for the last chunk can not be 0 ",
							" Resumes AEAD operation in context-saving ",
							" SX_AEAD_RESUME_STATE Macro ",
							" C typedef int (FUNC_SX_AEAD_RESUME_STATE)(struct sxaead c); #define SX_AEAD_RESUME_STATE ((FUNC_SX_AEAD_RESUME_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_RESUME_STATE))) This function shall be called when using context-saving to load the state that was previously saved by sx_aead_save_state() in the sxaead operation context p c It must be called with the same sxaead operation context p c that was used with sx_aead_save_state() It will reserve all hardware resources required to run the partial AEAD operation Previously used mode and direction are already stored in sxaead p c After successful execution of this function the context p c can be passed to any of the AEAD functions except the sx_aead_create_() functions ",
							" Parameters c AEAD operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED @return ::SX_ERR_INVALID_KEYREF @return ::SX_ERR_INVALID_KEY_SZ @return ::SX_ERR_INCOMPATIBLE_HW @return ::SX_ERR_RETRY | Param | Description | |:----- |:----------- | | @pre | sx_aead_create_aes() and sx_aead_save_state() functions must be called before for first part of the message | | @pre | must be called for each part of the message(besides first) before SX_AEAD_CRYPT() or sx_aead_save_state() | @remark | the user must not change the key until all parts of the message to be encrypted/decrypted are processed ",
							" Starts a partial AEAD operation ",
							" SX_AEAD_SAVE_STATE Macro ",
							" C typedef int (FUNC_SX_AEAD_SAVE_STATE)(struct sxaead c); #define SX_AEAD_SAVE_STATE ((FUNC_SX_AEAD_SAVE_STATE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_SAVE_STATE))) This function is used to start a partial encryption or decryption of p datain The function will return immediately The partial result will be transfered to p dataout only after the operation is successfully completed The user shall check operation status with sx_aead_status() or SX_AEAD_WAIT() ",
							" Parameters c AEAD operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_CONTEXT_SAVING_NOT_SUPPORTED @return ::SX_ERR_WRONG_SIZE_GRANULARITY | Param | Description | |:----- |:----------- | | @pre | SX_AEAD_CRYPT() should be called first | @remark | the user must not change the key until all parts of the message to be encrypted/decrypted are processed | | @remark | when in context saving the sizes of the chunks fed must be multiple of 16 bytes besides the last chunk that can be any size but not 0 ",
							" Waits until the given AEAD operation has finished ",
							" SX_AEAD_WAIT Macro ",
							" C typedef int (FUNC_SX_AEAD_WAIT)(struct sxaead c); #define SX_AEAD_WAIT ((FUNC_SX_AEAD_WAIT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_WAIT))) This function returns when the AEAD operation was successfully completed or when an error has occurred that caused the operation to terminate The return value of this function is the operation status After this call all resources have been released and p c cannot be used again unless sx_aead_create_() is used making p c unusable for a new operation without calling first one of the sx_aead_create_() functions ",
							" Parameters c AEAD operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_DMA_FAILED @return ::SX_ERR_INVALID_TAG | Param | Description | |:----- |:----------- | | @pre | sx_aead_encrypt or sx_aead_decrypt() function must be called first @see sx_aead_status() | @remark | this function is blocking until operation finishes ",
							" Returns the AEAD operation status If the operation is still ongoing return ::SX_ERR_HW_PROCESSING In that case the user can retry later When this function returns with a code different than ::SX_ERR_HW_PROCESSING the AEAD operation has ended and all resources used by the AEAD operation context p c have been released In this case p c cannot be used for a new operation until one of the sx_aead_create_() functions is called again ",
							" Parameters c AEAD operation context @return ::SX_OK @return ::SX_ERR_UNITIALIZED_OBJ @return ::SX_ERR_HW_PROCESSING @return ::SX_ERR_DMA_FAILED @return ::SX_ERR_INVALID_TAG | Param | Description | |:----- |:----------- | | @pre | sx_aead_encrypt or sx_aead_decrypt() function must be called first | @remark | if authentication fails during decryption ::SX_ERR_INVALID_TAG will be returned In this case the decrypted text is not valid and shall not be used ",
							" Silex_PK_API Enter a short description of your topic here (optional)  This is the start of your topic  ",
							" \"sxops\" interface to read write operands from/to memory @file ",
							" ADAPTER_HEADER_FILE Macro ",
							" C #define ADAPTER_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Write the operand into memory filling 'sz' bytes 0-pading if needed ",
							" (FUNC_SX_PK_OP2MEM_LE)(const Typedef ",
							" C typedef void (FUNC_SX_PK_OP2MEM_LE)(const sx_op op char mem int sz); ",
							" SX_PK_OP2MEM_LE Macro ",
							" C #define SX_PK_OP2MEM_LE ((FUNC_SX_PK_OP2MEM_LE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_OP2MEM_LE))) in little endian format ",
							" Parameters op Operand written to memory Data should have a size smaller or equal to 'sz' ",
							" Parameters mem Memory address to write the operand to ",
							" Parameters sz Size in bytes of the operand ",
							" Write the operand into memory filling 'sz' bytes 0-pading if needed ",
							" (FUNC_SX_PK_OP2MEM_BE)(const Typedef ",
							" C typedef void (FUNC_SX_PK_OP2MEM_BE)(const sx_op op char mem int sz); ",
							" SX_PK_OP2MEM_BE Macro ",
							" C #define SX_PK_OP2MEM_BE ((FUNC_SX_PK_OP2MEM_BE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_OP2MEM_BE))) in big endian format ",
							" Parameters op Operand written to memory Data should have a size smaller or equal to 'sz' ",
							" Parameters mem Memory address to write the operand to ",
							" Parameters sz Size in bytes of the operand ",
							" Write the operand into memory filling 'sz' bytes 0-pading if needed ",
							" (FUNC_SX_PK_OP2MEM)(const Typedef ",
							" C typedef void (FUNC_SX_PK_OP2MEM)(const sx_op op char mem int sz); ",
							" SX_PK_OP2MEM Macro ",
							" C #define SX_PK_OP2MEM ((FUNC_SX_PK_OP2MEM)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_OP2MEM))) ",
							" Parameters op Operand written to memory Data should have a size smaller or equal to 'sz' ",
							" Parameters mem Memory address to write the operand to ",
							" Parameters sz Size in bytes of the operand ",
							" Write the operand into memory which has the exact size needed ",
							" (FUNC_SX_PK_OP2VMEM_LE)(const Typedef ",
							" C typedef void (FUNC_SX_PK_OP2VMEM_LE)(const sx_op op char mem); ",
							" SX_PK_OP2VMEM_LE Macro ",
							" C #define SX_PK_OP2VMEM_LE ((FUNC_SX_PK_OP2VMEM_LE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_OP2VMEM_LE))) in little endian format ",
							" Parameters op Operand written to memory ",
							" Parameters mem Memory address to write the operand to ",
							" Write the operand into memory which has the exact size needed ",
							" (FUNC_SX_PK_OP2VMEM_BE)(const Typedef ",
							" C typedef void (FUNC_SX_PK_OP2VMEM_BE)(const sx_op op char mem); ",
							" SX_PK_OP2VMEM_BE Macro ",
							" C #define SX_PK_OP2VMEM_BE ((FUNC_SX_PK_OP2VMEM_BE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_OP2VMEM_BE))) in big endian format ",
							" Parameters op Operand written to memory ",
							" Parameters mem Memory address to write the operand to ",
							" Write the operand into memory which has the exact size needed ",
							" (FUNC_SX_PK_OP2VMEM)(const Typedef ",
							" C typedef void (FUNC_SX_PK_OP2VMEM)(const sx_op op char mem); ",
							" SX_PK_OP2VMEM Macro ",
							" C #define SX_PK_OP2VMEM ((FUNC_SX_PK_OP2VMEM)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_OP2VMEM))) ",
							" Parameters op Operand written to memory Data should be in big endian ",
							" Parameters mem Memory address to write the operand to ",
							" Convert raw little endian bytes format to operand ",
							" (FUNC_SX_PK_MEM2OP_LE)(const Typedef ",
							" C typedef void (FUNC_SX_PK_MEM2OP_LE)(const char mem int sz sx_op op); ",
							" SX_PK_MEM2OP_LE Macro ",
							" C #define SX_PK_MEM2OP_LE ((FUNC_SX_PK_MEM2OP_LE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_MEM2OP_LE))) ",
							" Parameters mem Memory address to read the operand from ",
							" Parameters sz Size in bytes of the memory to read ",
							" Parameters op Operand in which the raw little endian bytes are written Its size should be bigger or equal to 'sz' ",
							" Convert raw big endian bytes format to operand ",
							" (FUNC_SX_PK_MEM2OP_BE)(const Typedef ",
							" C typedef void (FUNC_SX_PK_MEM2OP_BE)(const char mem int sz sx_op op); ",
							" SX_PK_MEM2OP_BE Macro ",
							" C #define SX_PK_MEM2OP_BE ((FUNC_SX_PK_MEM2OP_BE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_MEM2OP_BE))) ",
							" Parameters mem Memory address to read the operand from ",
							" Parameters sz Size in bytes of the memory to read ",
							" Parameters op Operand in which the raw little endian bytes are written Its size should be bigger or equal to 'sz' ",
							" Convert raw bytes to operand ",
							" (FUNC_SX_PK_MEM2OP)(const Typedef ",
							" C typedef void (FUNC_SX_PK_MEM2OP)(const char mem int sz sx_op op); ",
							" SX_PK_MEM2OP Macro ",
							" C #define SX_PK_MEM2OP ((FUNC_SX_PK_MEM2OP)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_MEM2OP))) ",
							" Parameters mem Memory address to read the operand from ",
							" Parameters sz Size in bytes of the memory to read ",
							" Parameters op Operand in which the raw little endian bytes are written Its size should be bigger or equal to 'sz' ",
							" Return the size in bytes of the operand ",
							" (FUNC_SX_OP_SIZE)(const Typedef ",
							" C typedef int (FUNC_SX_OP_SIZE)(const sx_op op); ",
							" Parameters op Operand @return Operand size in bytes ",
							" Asymmetric cryptographic command definitions @file ",
							" CMDDEFS_HEADER_FILE Macro ",
							" C #define CMDDEFS_HEADER_FILE ",
							" SX_PK_CMD_MOD_ADD Macro ",
							" C typedef const struct sx_pk_cmd_def const SX_CMD_PTR; / @addtogroup SX_PK_CMDS @{ / Modular addition of operands A and B / #define SX_PK_CMD_MOD_ADD ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_MOD_ADD)) / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2014-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Modular substraction of operands A and B */ ",
							" Modular multiplication of operands A and B with odd modulo */ ",
							" SX_PK_CMD_ODD_MOD_MULT Macro ",
							" C #define SX_PK_CMD_ODD_MOD_MULT ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_ODD_MOD_MULT)) ",
							" Modular inversion of an operand with even modulo */ ",
							" Modular inversion of an operand with even modulo */ ",
							" SX_PK_CMD_EVEN_MOD_REDUCE Macro ",
							" C #define SX_PK_CMD_EVEN_MOD_REDUCE ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_EVEN_MOD_REDUCE)) ",
							" Modular reduction of an operand with odd modulo */ ",
							" Modular division of operands A and B with odd modulo */ ",
							" SX_PK_CMD_ODD_MOD_DIV Macro ",
							" C #define SX_PK_CMD_ODD_MOD_DIV ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_ODD_MOD_DIV)) ",
							" Modular inversion of an operand with odd modulo */ ",
							" Modular square root **/ ",
							" SX_PK_CMD_MOD_SQRT Macro ",
							" C #define SX_PK_CMD_MOD_SQRT ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_MOD_SQRT)) ",
							" Multiplication **/ ",
							" Modular exponentiation operation */ ",
							" SX_PK_CMD_MOD_EXP Macro ",
							" C #define SX_PK_CMD_MOD_EXP ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_MOD_EXP)) ",
							" Diffie Hellman modular exponentiation operation with countermeasures ",
							" SX_PK_CMD_DH_MOD_EXP_CM Macro ",
							" C #define SX_PK_CMD_DH_MOD_EXP_CM ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_DH_MOD_EXP_CM)) The modulus must be a prime number ",
							" RSA modular exponentiation operation with countermeasures*/ ",
							" Modular exponentiation operation (for RSA) with Chinese Remainder Theorem */ ",
							" SX_PK_CMD_MOD_EXP_CRT Macro ",
							" C #define SX_PK_CMD_MOD_EXP_CRT ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_MOD_EXP_CRT)) ",
							" Modular exponentiation operation (for RSA) with Chinese Remainder Theorem ",
							" SX_PK_CMD_MOD_EXP_CRT_CM Macro ",
							" C #define SX_PK_CMD_MOD_EXP_CRT_CM ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_MOD_EXP_CRT_CM)) With blinding factor for countermeasures ",
							" RSA private key including lambda(n) computation from primes ",
							" SX_PK_CMD_RSA_KEYGEN Macro ",
							" C #define SX_PK_CMD_RSA_KEYGEN ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_RSA_KEYGEN)) Lambda(n) is also called the Carmichael's totient function or Carmichael function ",
							" RSA CRT private key parameters computation */ ",
							" Montgomery point multiplication for X25519 and X448 ",
							" SX_PK_CMD_MONTGOMERY_PTMUL Macro ",
							" C #define SX_PK_CMD_MONTGOMERY_PTMUL ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_MONTGOMERY_PTMUL)) All operands for this command use a little endian representation Operands should be decoded and clamped as defined in specifications for X25519 and X448 ",
							" Elliptic curve ECDSA signature verification operation */ ",
							" Elliptic curve ECDSA signature generation operation */ ",
							" SX_PK_CMD_ECDSA_GEN Macro ",
							" C #define SX_PK_CMD_ECDSA_GEN ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_ECDSA_GEN)) ",
							" Elliptic curve point addition operation */ ",
							" Elliptic curve point multiplication operation */ ",
							" SX_PK_CMD_ECC_PTMUL Macro ",
							" C #define SX_PK_CMD_ECC_PTMUL ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_ECC_PTMUL)) ",
							" Elliptic curve point multiplication operation with countermeasures */ ",
							" Elliptic curve point decompression operation */ ",
							" SX_PK_CMD_ECC_PT_DECOMP Macro ",
							" C #define SX_PK_CMD_ECC_PT_DECOMP ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_ECC_PT_DECOMP)) ",
							" Elliptic curve check parameters a b */ ",
							" Elliptic curve check parameter n = p */ ",
							" SX_PK_CMD_CHECK_PARAM_N Macro ",
							" C #define SX_PK_CMD_CHECK_PARAM_N ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_CHECK_PARAM_N)) ",
							" Elliptic curve check x y point p */ ",
							" Elliptic curve point doubling */ ",
							" SX_PK_CMD_ECC_PT_DOUBLE Macro ",
							" C #define SX_PK_CMD_ECC_PT_DOUBLE ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_ECC_PT_DOUBLE)) ",
							" Elliptic curve point on curve check */ ",
							" EDDSA point multiplication operation ",
							" SX_PK_CMD_EDDSA_PTMUL Macro ",
							" C #define SX_PK_CMD_EDDSA_PTMUL ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_EDDSA_PTMUL)) All operands for this command use a little endian representation Operands should be decoded and clamped as defined in specifications for ED25519 ",
							" EDDSA 2nd part of signature operation ",
							" SX_PK_CMD_EDDSA_SIGN Macro ",
							" C #define SX_PK_CMD_EDDSA_SIGN ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_EDDSA_SIGN)) All operands for this command use a little endian representation Operands should be decoded and clamped as defined in specifications for ED25519 ",
							" EDDSA signature verification operation ",
							" SX_PK_CMD_EDDSA_VER Macro ",
							" C #define SX_PK_CMD_EDDSA_VER ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_EDDSA_VER)) All operands for this command use a little endian representation Operands should be decoded and clamped as defined in specifications for ED25519 ",
							" DSA signature generation */ ",
							" DSA signature verification */ ",
							" SX_PK_CMD_DSA_VER Macro ",
							" C #define SX_PK_CMD_DSA_VER ((SX_CMD_PTR)(uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CMD_DSA_VER)) } ",
							" Asymmetric cryptographic acceleration core interface @file ",
							" CORE_HEADER_FILE Macro ",
							" C #define CORE_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2014-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Default operand endianness ",
							" SX_PK_OP_DEFAULT_ENDIANNESS Macro ",
							" C #define SX_PK_OP_DEFAULT_ENDIANNESS 1 0: little endian 1: big endian ",
							" struct Function ",
							" C typedef struct sx_pk_accel sx_pk_accel; @addtogroup SX_PK_CORE @{ ",
							" Acceleration request ",
							" Struct ",
							" C typedef struct sx_pk_accel sx_pk_accel; / SilexPK and hardware constraints / struct sx_pk_constraints { / Maximum simultaneous requests any application can configure / int maxpending; }; A public key operation for offload on a hardware accelerator ",
							" Return SilexPK constraints ",
							" SX_PK_LIST_CONSTRAINTS Macro ",
							" C typedef struct sx_pk_constraints (FUNC_SX_PK_LIST_CONSTRAINTS)(int index int usermemsz); #define SX_PK_LIST_CONSTRAINTS ((FUNC_SX_PK_LIST_CONSTRAINTS)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_LIST_CONSTRAINTS))) If maxpending in sx_pk_constraints is 0 than SilexPK cannot be used with the given environment ",
							" Parameters index Index should always be 0 ",
							" Parameters usermemsz User memory size provided in bytes Should be non zero for BA414 AHBMaster and BA414 baremetal with no static memory @return Constraints of SilexPK ",
							" Description of the (hardware) accelerator capabilities and features */ struct sx_pk_capabilities { ",
							" Maximum pending requests at any time */ int maxpending; ",
							" Maximum operand size for prime field operands 0 when not supported */ int max_gfp_opsz; ",
							" Maximum operand size for elliptic curve operands 0 when not supported */ int max_ecc_opsz; ",
							" Maximum operand size for binary field operands 0 when not supported */ int max_gfb_opsz; ",
							" Operand size for IK operands 0 when not supported */ int ik_opsz; }; ",
							" Opaque structure for offload with SilexPK library */ struct sx_pk_cnx; ",
							" Return the crypto acceleration capabilities and features ",
							" SX_PK_FETCH_CAPABILITIES Macro ",
							" C typedef const struct sx_pk_capabilities (FUNC_SX_PK_FETCH_CAPABILITIES)(struct sx_pk_cnx cnx); #define SX_PK_FETCH_CAPABILITIES ((FUNC_SX_PK_FETCH_CAPABILITIES)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_FETCH_CAPABILITIES))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return NULL on failure @return Capabilities of the accelerator on success ",
							" Library configuration for SX_PK_OPEN() */ struct sx_pk_config { ",
							" Maximum simultaneous requests the application will start Set to 0 to use library default int maxpending; ",
							" Device index to use For special use cases with multiple independent hardware accelerators In case of doubt leave to 0 int devidx; ",
							" User memory */ long long usrmem; ",
							" Size of user provided memory */ size_t usrmemsz; ",
							" Personalization string for IK */ uint32_t personalization; ",
							" Personalization string size in 32 bit words If the size is 0 the personalization string is considered NULL and will not be used int personalization_sz; }; ",
							" Open SilexPK and related hardware and allocate internal resources ",
							" SX_PK_OPEN Macro ",
							" C typedef struct sx_pk_cnx (FUNC_SX_PK_OPEN)(struct sx_pk_config cfg); #define SX_PK_OPEN ((FUNC_SX_PK_OPEN)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_OPEN))) ",
							" Parameters cfg Configuration to customize SilexPK to application specific needs @return NULL on failure @return Connection structure for future SilexPK calls on success Can be used with SilexPK functions to run operations @see SX_PK_CLOSE() ",
							" Finish using any public key acceleration ",
							" SX_PK_CLOSE Macro ",
							" C typedef void (FUNC_SX_PK_CLOSE)(struct sx_pk_cnx cnx); #define SX_PK_CLOSE ((FUNC_SX_PK_CLOSE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CLOSE))) No other hardware acceleration function can be called after this ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Encapsulated acceleration request This structure is used by SX_PK_ACQUIRE_REQ() and _go() functions as a return value struct sx_pk_dreq { ",
							" The acquired acceleration request **/ sx_pk_accel req; ",
							" The status of SX_PK_ACQUIRE_REQ() **/ int status; }; ",
							" Get a SilexPK request instance locked to perform the given operation ",
							" SX_PK_ACQUIRE_REQ Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_PK_ACQUIRE_REQ)(struct sx_pk_cnx cnx const struct sx_pk_cmd_def cmd); #define SX_PK_ACQUIRE_REQ ((FUNC_SX_PK_ACQUIRE_REQ)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_ACQUIRE_REQ))) The returned sx_pk_dreq structure contains a status and a pointer to a reserved hardware accelerator instance That pointer is only valid and usable if status is non-zero ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters cmd The command definition (for example ::SX_PK_CMD_MOD_EXP) @return The acquired acceleration request for this operation @see SX_PK_RELEASE_REQ() ",
							" Least significant bit of Ax is 1 (flag A) */ ",
							" Least significant bit of Rx is 1 (flag B) */ ",
							" PK_OP_FLAGS_EDDSA_RX_LSB Macro ",
							" C #define PK_OP_FLAGS_EDDSA_RX_LSB (1 30) ",
							" Return the instance number of the hardware accelerator for this request ",
							" int Typedef ",
							" C typedef unsigned int (FUNC_SX_PK_GET_REQ_ID)(sx_pk_accel req); ",
							" SX_PK_GET_REQ_ID Macro ",
							" C #define SX_PK_GET_REQ_ID ((FUNC_SX_PK_GET_REQ_ID)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_REQ_ID))) ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() @return instance number of the hardware accelerator for this request ",
							" Add the context pointer to an acceleration request ",
							" (FUNC_SX_PK_SET_USER_CONTEXT)(sx_pk_accel Typedef ",
							" C typedef void (FUNC_SX_PK_SET_USER_CONTEXT)(sx_pk_accel req void context); ",
							" SX_PK_SET_USER_CONTEXT Macro ",
							" C #define SX_PK_SET_USER_CONTEXT ((FUNC_SX_PK_SET_USER_CONTEXT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_SET_USER_CONTEXT))) The attached pointer can be retrieved by SX_PK_GET_USER_CONTEXT() After SX_PK_RELEASE_REQ() the context pointer is not available anymore The context can represent any content the user may associate with the PK request ",
							" Parameters req The acquired acceleration request ",
							" Parameters context Pointer to context @see SX_PK_GET_USER_CONTEXT() ",
							" Get the context pointer from an acceleration request ",
							" (FUNC_SX_PK_GET_USER_CONTEXT)(sx_pk_accel Typedef ",
							" C typedef void (FUNC_SX_PK_GET_USER_CONTEXT)(sx_pk_accel req); ",
							" SX_PK_GET_USER_CONTEXT Macro ",
							" C #define SX_PK_GET_USER_CONTEXT ((FUNC_SX_PK_GET_USER_CONTEXT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_USER_CONTEXT))) ",
							" Parameters req The acquired acceleration request @return Context pointer from an acceleration request @see SX_PK_SET_USER_CONTEXT() ",
							" Return the global operands size detected for the request ",
							" (FUNC_SX_PK_GET_OPSIZE)(sx_pk_accel Typedef ",
							" C typedef int (FUNC_SX_PK_GET_OPSIZE)(sx_pk_accel req); ",
							" SX_PK_GET_OPSIZE Macro ",
							" C #define SX_PK_GET_OPSIZE ((FUNC_SX_PK_GET_OPSIZE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_OPSIZE))) ",
							" Parameters req The acquired acceleration request @return Operand size for the request ",
							" Operand slot structure */ struct sx_pk_slot { ",
							" Memory address of the operand slot **/ char addr; }; ",
							" Pair of slots Used to store large values struct sx_pk_dblslot { ",
							" First slot **/ struct sx_pk_slot a; ",
							" Second slot **/ struct sx_pk_slot b; }; ",
							" List slots for input operands for an ECC operation ",
							" SX_PK_LIST_ECC_INSLOTS Macro ",
							" C typedef int (FUNC_SX_PK_LIST_ECC_INSLOTS)(sx_pk_accel req const struct sx_pk_ecurve curve int flags struct sx_pk_slot inputs); #define SX_PK_LIST_ECC_INSLOTS ((FUNC_SX_PK_LIST_ECC_INSLOTS)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_LIST_ECC_INSLOTS))) Once the function completes with ::SX_OK write each operand to the address found in the corresponding slot That applies to all ECC operations ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() ",
							" Parameters curve The curve used for that ECC operation ",
							" Parameters flags Operation specific flags ",
							" Parameters inputs List of input slots that will be filled in See inputslots h for predefined lists of input slots per operation @return ::SX_OK @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_BUSY ",
							" List slots for input operands for a GF(p) modular operation ",
							" SX_PK_LIST_GFP_INSLOTS Macro ",
							" C typedef int (FUNC_SX_PK_LIST_GFP_INSLOTS)(sx_pk_accel req const int opsizes struct sx_pk_slot inputs); #define SX_PK_LIST_GFP_INSLOTS ((FUNC_SX_PK_LIST_GFP_INSLOTS)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_LIST_GFP_INSLOTS))) Once the function completes with ::SX_OK write each operands to the address found in the corresponding slot That applies to all operations except ECC ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() ",
							" Parameters opsizes List of operand sizes in bytes ",
							" Parameters inputs List of input slots that will be filled in See inputslots h for predefined lists of input slots per operation @return ::SX_OK @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_BUSY ",
							" Run the operation request in hardware ",
							" (FUNC_SX_PK_RUN)(sx_pk_accel Typedef ",
							" C typedef void (FUNC_SX_PK_RUN)(sx_pk_accel req); ",
							" SX_PK_RUN Macro ",
							" C #define SX_PK_RUN ((FUNC_SX_PK_RUN)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_RUN))) @pre To be called after all operands have been written in the slots obtainded with SX_PK_LIST_ECC_INSLOTS() or SX_PK_LIST_GFP_INSLOTS() After that the acceleration request is pending @post The caller should wait until the operation finishes with SX_PK_WAIT() or do polling by using sx_pk_has_finished() ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() ",
							" Check if the current operation is still ongoing or finished ",
							" (FUNC_SX_PK_GET_STATUS)(sx_pk_accel Typedef ",
							" C typedef int (FUNC_SX_PK_GET_STATUS)(sx_pk_accel req); ",
							" SX_PK_GET_STATUS Macro ",
							" C #define SX_PK_GET_STATUS ((FUNC_SX_PK_GET_STATUS)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_STATUS))) Read the status of a request When the accelerator is still busy return ::SX_ERR_BUSY When the accelerator finished return ::SX_OK May only be called after SX_PK_RUN() May not be called after sx_pk_has_finished() or other functions like SX_PK_WAIT() reported that the operation finished ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() @return Any ref SX_PK_STATUS \"status code\" ",
							" Legacy name of SX_PK_GET_STATUS() **/ ",
							" Wait until the current operation finishes ",
							" (FUNC_SX_PK_WAIT)(sx_pk_accel Typedef ",
							" C typedef int (FUNC_SX_PK_WAIT)(sx_pk_accel req); ",
							" SX_PK_WAIT Macro ",
							" C #define SX_PK_WAIT ((FUNC_SX_PK_WAIT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_WAIT))) After the operation finishes return the operation status code ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() @return Any ref SX_PK_STATUS \"status code\" ",
							" Clear the interrupt request signal ",
							" (FUNC_SX_PK_CLEAR_IRQ)(void); Typedef ",
							" C typedef void (FUNC_SX_PK_CLEAR_IRQ)(void); ",
							" SX_PK_CLEARIRQ Macro ",
							" C #define SX_PK_CLEARIRQ ((FUNC_SX_PK_CLEAR_IRQ)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CLEARIRQ))) Clear the IRQ request signal ",
							" Return the public key acceleration request which finished its operation ",
							" SX_PK_POP_FINISHED_REQ Macro ",
							" C typedef sx_pk_accel (FUNC_SX_PK_POP_FINISHED_REQ)(struct sx_pk_cnx cnx); #define SX_PK_POP_FINISHED_REQ ((FUNC_SX_PK_POP_FINISHED_REQ)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_POP_FINISHED_REQ))) If no public key accelerator finished or none has an operation return NULL The results from the returned sx_pk_accel should be used as soon as possible and the instances given back with SX_PK_RELEASE_REQ() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return NULL when no public key accelerator finished or none has an operation @return The acceleration request which finished its operation ",
							" Return a platform notification that notifies when a request completed ",
							" SX_PK_GET_GLOBAL_NOTIFICATION_ID Macro ",
							" C typedef int (FUNC_SX_PK_GET_GLOBAL_NOTIFICATION_ID)(struct sx_pk_cnx cnx); #define SX_PK_GET_GLOBAL_NOTIFICATION_ID ((FUNC_SX_PK_GET_GLOBAL_NOTIFICATION_ID)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_GLOBAL_NOTIFICATION_ID))) The platform notification id is: -1 if not available a fd on POSIX systems an interrupt line number When a request completes the notification will activate The fd will become readable and the interrupt line will generate an interrupt The returned platform notification can be used once After the platform notification or after SX_PK_POP_FINISHED_REQ() the notification id shall not be used anymore May not be used in combination with SX_PK_WAIT() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return platform notification id ",
							" Legacy name of SX_PK_GET_GLOBAL_NOTIFICATION_ID() **/ ",
							" Return a platform notification id of completion of this request ",
							" (FUNC_SX_PK_GET_REQ_COMPLETION_ID)(sx_pk_accel Typedef ",
							" C typedef int (FUNC_SX_PK_GET_REQ_COMPLETION_ID)(sx_pk_accel req); ",
							" SX_PK_GET_REQ_COMPLETION_ID Macro ",
							" C #define SX_PK_GET_REQ_COMPLETION_ID ((FUNC_SX_PK_GET_REQ_COMPLETION_ID)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_REQ_COMPLETION_ID))) The platform notification id is: -1 if not available a fd on POSIX systems an interrupt line number When the request completes the notification will activate The fd will become readable and the interrupt line will generate an interrupt After it was used or after SX_PK_POP_FINISHED_REQ() the fd or interrupt line shall not be used anymore May not be used in combination with SX_PK_WAIT() ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() @return platform notification id ",
							" Fetch array of addresses to output operands ",
							" char Typedef ",
							" C typedef const char (FUNC_SX_PK_GET_OUTPUT_OPS)(sx_pk_accel req); ",
							" SX_PK_GET_OUTPUT_OPS Macro ",
							" C #define SX_PK_GET_OUTPUT_OPS ((FUNC_SX_PK_GET_OUTPUT_OPS)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_OUTPUT_OPS))) ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() @return Array of addresses to output operands ",
							" Give back the public key acceleration request ",
							" (FUNC_SX_PK_RELEASE_REQ)(sx_pk_accel Typedef ",
							" C typedef void (FUNC_SX_PK_RELEASE_REQ)(sx_pk_accel req); ",
							" SX_PK_RELEASE_REQ Macro ",
							" C #define SX_PK_RELEASE_REQ ((FUNC_SX_PK_RELEASE_REQ)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_RELEASE_REQ))) Release the reserved resources @pre SX_PK_ACQUIRE_REQ() should have been called before this function is called and not being in use by the hardware ",
							" Parameters req The acceleration request obtained through SX_PK_ACQUIRE_REQ() operation has finished ",
							" Elliptic curve configuration and parameters To be used only via the functions in ec_curves h The internal members of the structure should not be accessed directly struct sx_pk_ecurve { uint32_t curveflags; int sz; const char params; int offset; struct sx_pk_cnx cnx; }; } ",
							" \"sxops\" interface for DSA cryptographic computations Simpler functions to perform public key crypto operations Included directly in some interfaces (like sxbuf or OpenSSL engine) The functions take input operands (large integers) and output operands which will get the computed results Operands have the \"sx_op\" type The specific interfaces (like sxbuf) define the \"sx_op\" type @file ",
							" DSA_HEADER_FILE Macro ",
							" C #define DSA_HEADER_FILE / Copyright (c) 2020 Silex Insight sa SPDX-License-Identifier: BSD-3-Clause ",
							" Make sure the application is compatible with SilexPK API version **/ SX_PK_API_ASSERT_COMPATIBLE(1 1); struct sx_pk_cmd_def; @addtogroup SX_PK_SXOPS_DSA @{ ",
							" Asynchronous (non-blocking) DSA signature generation Start an DSA signature generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_finish_pair() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime modulus p ",
							" Parameters q Prime divisor of p-1 ",
							" Parameters g Generator of order q mod p ",
							" Parameters k Random value ",
							" Parameters privkey Private key ",
							" Parameters h Hash digest of message reduced by means of Secure Hash Algorithm specified in FIPS 180-3 @return Acquired acceleration request for this operation @see sx_dsa_sign() for a synchronous version static inline struct sx_pk_dreq sx_async_dsa_sign_go(struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op g const sx_op k const sx_op privkey const sx_op h) { struct sx_pk_dreq pkreq; struct sx_pk_inops_dsa_sign inputs; pkreq = SX_PK_ACQUIRE_REQ(cnx SX_PK_CMD_DSA_SIGN); if (pkreq status) return pkreq; // convert and transfer operands int sizes = { SX_OP_SIZE(p) SX_OP_SIZE(q) SX_OP_SIZE(g) SX_OP_SIZE(k) SX_OP_SIZE(privkey) SX_OP_SIZE(h) }; pkreq status = SX_PK_LIST_GFP_INSLOTS(pkreq req sizes (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; SX_PK_OP2VMEM(p inputs p addr); SX_PK_OP2VMEM(q inputs q addr); SX_PK_OP2VMEM(g inputs g addr); SX_PK_OP2VMEM(k inputs k addr); SX_PK_OP2VMEM(privkey inputs privkey addr); SX_PK_OP2VMEM(h inputs h addr); SX_PK_RUN(pkreq req); return pkreq; } ",
							" DSA signature generation Computes the following: 1 X = g k mod p 2 r = X mod q 3 if r == 0 the return ::SX_ERR_INVALID_SIGNATURE 4 else w = k (-1) mod q 5 s = w (h + x r) mod q 6 if s == 0 then return ::SX_ERR_INVALID_SIGNATURE 7 (r s) is the signature ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime modulus p ",
							" Parameters q Prime divisor of p-1 ",
							" Parameters g Generator of order q mod p ",
							" Parameters k Random value ",
							" Parameters privkey Private key ",
							" Parameters h Hash digest of message reduced by means of Secure Hash Algorithm specified in FIPS 180-3 ",
							" Parameters r First part of signature ",
							" Parameters s Second part of signature @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_dsa_sign_go() for an asynchronous version int sx_dsa_sign(struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op g const sx_op k const sx_op privkey const sx_op h sx_op r sx_op s) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_dsa_sign_go(cnx p q g k privkey h); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_finish_pair(pkreq req r s); return status; } ",
							" Asynchronous (non-blocking) DSA signature verification Start an DSA signature verification on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_PK_RELEASE_REQ() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime modulus p ",
							" Parameters q Prime divisor of p-1 ",
							" Parameters g Generator of order q mod p ",
							" Parameters pubkey Public key ",
							" Parameters h Hash digest of message reduced by means of Secure Hash Algorithm specified in FIPS 180-3 ",
							" Parameters r First part of the signature to verify ",
							" Parameters s Second part of the signature to verify @return Acquired acceleration request for this operation @see sx_dsa_ver() for a synchronous version static inline struct sx_pk_dreq sx_async_dsa_ver_go(struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op g const sx_op pubkey const sx_op h const sx_op r const sx_op s) { struct sx_pk_dreq pkreq; struct sx_pk_inops_dsa_ver inputs; pkreq = SX_PK_ACQUIRE_REQ(cnx SX_PK_CMD_DSA_VER); if (pkreq status) return pkreq; // convert and transfer operands int sizes = { SX_OP_SIZE(p) SX_OP_SIZE(q) SX_OP_SIZE(g) SX_OP_SIZE(pubkey) SX_OP_SIZE(h) SX_OP_SIZE(r) SX_OP_SIZE(s) }; pkreq status = SX_PK_LIST_GFP_INSLOTS(pkreq req sizes (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; SX_PK_OP2VMEM(p inputs p addr); SX_PK_OP2VMEM(q inputs q addr); SX_PK_OP2VMEM(g inputs g addr); SX_PK_OP2VMEM(pubkey inputs pubkey addr); SX_PK_OP2VMEM(h inputs h addr); SX_PK_OP2VMEM(r inputs r addr); SX_PK_OP2VMEM(s inputs s addr); SX_PK_RUN(pkreq req); return pkreq; } ",
							" DSA signature verification Checks if a signature is valid: 1 w = s (-1) mod q 2 u1 = h w mod q 3 u2 = r w mod q 4 X = g (u1) y (u2) mod p 5 v = X mod q 6 if v == r then signature is valid (::SX_OK) 7 else return ::SX_ERR_INVALID_SIGNATURE Before launching the operation verify the domain D(p q g) by checking: 1 2 1023 p 2 1024 b or 2 2047 p 2 2048 2 2 159 q 2 160 b or 2 223 q 2 224 b or 2 255 q 2^256 3 1 g p ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime modulus p ",
							" Parameters q Prime divisor of p-1 ",
							" Parameters g Generator of order q mod p ",
							" Parameters pubkey Public key ",
							" Parameters h Hash digest of message reduced by means of Secure Hash Algorithm specified in FIPS 180-3 ",
							" Parameters r First part of the signature to verify ",
							" Parameters s Second part of the signature to verify @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_dsa_ver_go() for an asynchronous version int sx_dsa_ver(struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op g const sx_op pubkey const sx_op h const sx_op r const sx_op s) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_dsa_ver_go(cnx p q g pubkey h r s); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); SX_PK_RELEASE_REQ(pkreq req); return status; } } ",
							" Predefined and custom elliptic curve definitions @file ",
							" EC_CURVES_HEADER_FILE Macro ",
							" C #define EC_CURVES_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" int Function ",
							" C typedef int (*FUNC_SX_PK_CURVE_OPSIZE)(const struct sx_pk_ecurve *curve); @addtogroup SX_PK_CURVES @{ ",
							" Slots to write custom curve parameters into */ struct sx_curve_slots { struct sx_pk_slot p; / Field size of curve / struct sx_pk_slot n; / Order of curve / struct sx_pk_slot gx; / x-coordinate of generator point of curve / struct sx_pk_slot gy; / y-coordinate of generator point of curve / struct sx_pk_slot a; / Curve parameter a / struct sx_pk_slot b; / Curve parameter b / }; ",
							" Create a prime elliptic curve ",
							" SX_PK_CREATE_ECP_CURVE Macro ",
							" C typedef void (FUNC_SX_PK_CREATE_ECP_CURVE)( struct sx_pk_cnx cnx struct sx_pk_ecurve curve char mem int sz struct sx_curve_slots slots); #define SX_PK_CREATE_ECP_CURVE ((FUNC_SX_PK_CREATE_ECP_CURVE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CREATE_ECP_CURVE))) @remark When this function returns copy the paramters of the curve into the slots returned in 'slots' After that you can use the prime elliptic curve ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters curve Curve to initialise as a prime elliptic curve ",
							" Parameters mem Memory for the parameters of the curve The size of the memory should be 6 time sz as there are 6 curve parameters of size sz ",
							" Parameters sz Size of the curve in bytes ",
							" Parameters slots Slots for the curve parameters @see SX_PK_CREATE_ECB_CURVE() and SX_PK_DESTROY_EC_CURVE() ",
							" Create a binary elliptic curve ",
							" SX_PK_CREATE_ECB_CURVE Macro ",
							" C typedef void (FUNC_SX_PK_CREATE_ECB_CURVE)(struct sx_pk_cnx cnx struct sx_pk_ecurve curve char mem int sz struct sx_curve_slots slots); #define SX_PK_CREATE_ECB_CURVE ((FUNC_SX_PK_CREATE_ECB_CURVE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CREATE_ECB_CURVE))) @remark When this function returns copy the paramters of the curve into the slots returned in 'slots' After that you can use the binary elliptic curve ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters curve Curve to initialise as a binary elliptic curve ",
							" Parameters mem Memory for the parameters of the curve The size of the memory should be 6 time sz as there are 6 curve parameters of size sz ",
							" Parameters sz Size of the curve in bytes ",
							" Parameters slots Slots for the curve parameters @see SX_PK_CREATE_ECP_CURVE() and SX_PK_DESTROY_EC_CURVE() ",
							" Destroy a custom ecp or ecb curve ",
							" SX_PK_DESTROY_EC_CURVE Macro ",
							" C typedef void (FUNC_SX_PK_DESTROY_EC_CURVE)(struct sx_pk_ecurve curve); #define SX_PK_DESTROY_EC_CURVE ((FUNC_SX_PK_DESTROY_EC_CURVE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_DESTROY_EC_CURVE))) Destroy a curve created previously by SX_PK_CREATE_ECP_CURVE() or SX_PK_CREATE_ECB_CURVE() ",
							" Parameters curve Initialised curve to destroy ",
							" Get a reference to the predefined NIST P192 elliptic curve ",
							" SX_PK_GET_CURVE_NISTP192 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_NISTP192)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_NISTP192 ((FUNC_SX_PK_GET_CURVE_NISTP192)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_NISTP192))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for P192 curve ",
							" Get a reference to the predefined NIST P256 elliptic curve ",
							" SX_PK_GET_CURVE_NISTP256 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_NISTP256)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_NISTP256 ((FUNC_SX_PK_GET_CURVE_NISTP256)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_NISTP256))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for P256 curve ",
							" Get a reference to the predefined NIST P384 elliptic curve ",
							" SX_PK_GET_CURVE_NISTP384 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_NISTP384)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_NISTP384 ((FUNC_SX_PK_GET_CURVE_NISTP384)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_NISTP384))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for P384 curve ",
							" Get a reference to the predefined NIST P521 elliptic curve ",
							" SX_PK_GET_CURVE_NISTP521 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_NISTP521)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_NISTP521 ((FUNC_SX_PK_GET_CURVE_NISTP521)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_NISTP521))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for P521 curve ",
							" Get a reference to the predefined ED25519 elliptic curve ",
							" SX_PK_GET_CURVE_ED25519 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_ED25519)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_ED25519 ((FUNC_SX_PK_GET_CURVE_ED25519)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_ED25519))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for ED25519 curve ",
							" Get a reference to the predefined ED448 elliptic curve ",
							" SX_PK_GET_CURVE_ED448 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_ED448)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_ED448 ((FUNC_SX_PK_GET_CURVE_ED448)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_ED448))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for ED448 curve ",
							" Get a reference to the predefined X25519 elliptic curve ",
							" SX_PK_GET_CURVE_X25519 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_X25519)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_X25519 ((FUNC_SX_PK_GET_CURVE_X25519)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_X25519))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for X25519 curve ",
							" Get a reference to the predefined X448 elliptic curve ",
							" SX_PK_GET_CURVE_X448 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_X448)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_X448 ((FUNC_SX_PK_GET_CURVE_X448)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_X448))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for X448 curve ",
							" Get a reference to the predefined SEC p256k1 elliptic curve ",
							" SX_PK_GET_CURVE_SECP256K1 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_SECP256K1)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_SECP256K1 ((FUNC_SX_PK_GET_CURVE_SECP256K1)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_SECP256K1))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for SEC p256k1 curve ",
							" Get a reference to the predefined fp256 elliptic curve ",
							" SX_PK_GET_CURVE_FP256 Macro ",
							" C typedef struct sx_pk_ecurve (FUNC_SX_PK_GET_CURVE_FP256)(struct sx_pk_cnx cnx); #define SX_PK_GET_CURVE_FP256 ((FUNC_SX_PK_GET_CURVE_FP256)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_GET_CURVE_FP256))) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup @return Curve structure for fp256 curve (used in SM2) ",
							" Write the generator point of the curve into the slots (internal) ",
							" SX_PK_WRITE_CURVE_GEN Macro ",
							" C typedef void (FUNC_SX_PK_WRITE_CURVE_GEN)(sx_pk_accel pk const struct sx_pk_ecurve curve struct sx_pk_slot px struct sx_pk_slot py); #define SX_PK_WRITE_CURVE_GEN ((FUNC_SX_PK_WRITE_CURVE_GEN)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_AEAD_CREATE_AESGCM_ENC))) Write the parameter gx gy from curve to px addr py addr respectively ",
							" Parameters pk The accelerator request ",
							" Parameters curve Initialised curve to get generator point from ",
							" Parameters px x-coordinate slot of generator point The curve generator (x-coordinate) will be written to this address ",
							" Parameters py y-coordinate slot of generator point The curve generator (y-coordinate) will be written to this address ",
							" Return the operand size in bytes for the given curve ",
							" SX_PK_CURVE_OPSIZE Macro ",
							" C typedef int (FUNC_SX_PK_CURVE_OPSIZE)(const struct sx_pk_ecurve curve); #define SX_PK_CURVE_OPSIZE ((FUNC_SX_PK_CURVE_OPSIZE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_CURVE_OPSIZE))) ",
							" Parameters curve Initialised curve to get operand size from @return Operand size in bytes for the given curve } ",
							" \"sxops\" interface for Weierstrass elliptic curve computations Simpler functions to perform public key crypto operations Included directly in some interfaces (like sxbuf or OpenSSL engine) The functions take input operands (large integers) and output operands which will get the computed results Operands have the \"sx_op\" type The specific interfaces (like sxbuf) define the \"sx_op\" type @file ",
							" ECCWEIERSTRASS_HEADER_FILE Macro ",
							" C #define ECCWEIERSTRASS_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Make sure the application is compatible with SilexPK API version **/ SX_PK_API_ASSERT_COMPATIBLE(1 3); struct sx_pk_ecurve; ",
							" inline Function ",
							" C static inline @addtogroup SX_PK_SXOPS_ECC @{ ",
							" Curve generator point for sx_ecp_ptmult() or sx_async_ecp_mult_go() */ ",
							" SX_PTMULT_CURVE_GENERATOR Macro ",
							" C #define SX_PTMULT_CURVE_GENERATOR NULL ",
							" inline Function ",
							" C static inline @addtogroup SX_PK_SXOPS_ECDSA @{ ",
							" Asynchronous ECDSA signature generation Start an ECDSA signature generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_ecdsa_generate_end() ",
							" Parameters curve Elliptic curve on which to perform ECDSA signature ",
							" Parameters d Private key ",
							" Parameters k Random value ",
							" Parameters h Formatted hash digest of message to be signed Truncation or padding should be done by user application @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_ecdsa_generate_go( const struct sx_pk_ecurve curve const sx_op d const sx_op k const sx_op h) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecdsa_generate inputs; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECDSA_GEN); if (pkreq status) return pkreq; // convert and transfer operands pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(d inputs d addr opsz); SX_PK_OP2MEM(k inputs k addr opsz); SX_PK_OP2MEM(h inputs h addr opsz); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) ECDSA generation Get the output operands of the ECDSA signature generation and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters r First part of signature ",
							" Parameters s Second part of signature static inline void sx_async_ecdsa_generate_end(sx_pk_accel req sx_op r sx_op s) { sx_async_finish_pair(req r s); } ",
							" Generate an ECDSA signature on an elliptic curve The signature generation has the following steps : 1 P(x1 y1) = k G 2 r = x1 mod n 3 if r == 0 then report failure 4 w = k -1 mod n 5 s = k -1 (h + d r) mod n 6 if s == 0 then report failure 7 signature is the r and s ",
							" Parameters curve Elliptic curve on which to perform ECDSA signature ",
							" Parameters d Private key ",
							" Parameters k Random value ",
							" Parameters h Digest of message to be signed Truncation or padding should be done by user application ",
							" Parameters r First part of signature ",
							" Parameters s Second part of signature @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecdsa_generate_go() sx_async_ecdsa_generate_end() for an asynchronous version static inline int sx_ecdsa_generate( const struct sx_pk_ecurve curve const sx_op d const sx_op k const sx_op h sx_op r sx_op s) { uint32_t status; struct sx_pk_dreq pkreq; pkreq = sx_async_ecdsa_generate_go(curve d k h); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_ecdsa_generate_end(pkreq req r s); return status; } ",
							" Asynchronous (non-blocking) ECDSA verification Start an ECDSA signature verification on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_PK_RELEASE_REQ() ",
							" Parameters curve Elliptic curve on which to perform ECDSA verification ",
							" Parameters qx x-coordinate of public key Point (qx qy) should be on the curve ",
							" Parameters qy y-coordinate of public key Point (qx qy) should be on the curve ",
							" Parameters r First part of signature to verify ",
							" Parameters s Second part of signature to verify ",
							" Parameters h Digest of message to be signed @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_ecdsa_verify_go( const struct sx_pk_ecurve curve const sx_op qx const sx_op qy const sx_op r const sx_op s const sx_op h) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecdsa_verify inputs; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECDSA_VER); if (pkreq status) return pkreq; // convert and transfer operands pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(qx inputs qx addr opsz); SX_PK_OP2MEM(qy inputs qy addr opsz); SX_PK_OP2MEM(r inputs r addr opsz); SX_PK_OP2MEM(s inputs s addr opsz); SX_PK_OP2MEM(h inputs h addr opsz); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Verify ECDSA signature on an elliptic curve The verification has the following steps: 1 check qx and qy are smaller than q from the domain 2 Check that Q lies on the elliptic curve from the domain 3 Check that r and s are smaller than n 4 w = s ^ -1 mod n 5 u1 = h w mod n 6 u2 = r w mod n 7 X(x1 y1) = u1 G + u2 Q 8 If X is invalid then the signature is invalid 9 v = x1 mod n 10 Accept signature if and only if v == r ",
							" Parameters curve Elliptic curve on which to perform ECDSA verification ",
							" Parameters qx x-coordinate of public key Point (qx qy) should be on the curve ",
							" Parameters qy y-coordinate of public key Point (qx qy) should be on the curve ",
							" Parameters r First part of signature to verify ",
							" Parameters s Second part of signature to verify ",
							" Parameters h Digest of message to be signed @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecdsa_verify_go() for an asynchronous version static inline int sx_ecdsa_verify( const struct sx_pk_ecurve curve const sx_op qx const sx_op qy const sx_op r const sx_op s const sx_op h) { uint32_t status; struct sx_pk_dreq pkreq; pkreq = sx_async_ecdsa_verify_go(curve qx qy r s h); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); SX_PK_RELEASE_REQ(pkreq req); return status; } ",
							" @} */ ",
							" inline Function ",
							" C static inline @addtogroup SX_PK_SXOPS_ECOPS @{ ",
							" Asynchronous EC point multiplication Starts an EC point multiplication on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_ecp_mult_end() ",
							" Parameters curve Elliptic curve used to perform point multiplication ",
							" Parameters k Scalar that multiplies point P ",
							" Parameters Py x-coordinate of point P ",
							" Parameters Px y-coordinate of point P @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_ecp_mult_go( const struct sx_pk_ecurve curve const sx_op k const sx_op Px const sx_op Py) { struct sx_pk_dreq pkreq; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECC_PTMUL); if (pkreq status) return pkreq; struct sx_pk_inops_ecp_mult inputs; pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(k inputs k addr opsz); if (Px == SX_PTMULT_CURVE_GENERATOR) { SX_PK_WRITE_CURVE_GEN(pkreq req curve inputs px inputs py); } else { SX_PK_OP2MEM(Px inputs px addr opsz); SX_PK_OP2MEM(Py inputs py addr opsz); } SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous EC point multiplication Get the output operands of the EC point multiplication and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters Rx x-coordinate of resulting point R ",
							" Parameters Ry y-coordinate of resulting point R static inline void sx_async_ecp_mult_end( sx_pk_accel req sx_op Rx sx_op Ry) { sx_async_finish_pair(req Rx Ry); } ",
							" Compute point multiplication on an elliptic curve (Rx Ry) = k (Px Py) ",
							" Parameters curve Elliptic curve used to perform point multiplication ",
							" Parameters k Scalar that multiplies point P ",
							" Parameters Py x-coordinate of point P ",
							" Parameters Px y-coordinate of point P ",
							" Parameters Rx x-coordinate of resulting point R ",
							" Parameters Ry y-coordinate of resulting point R @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecp_mult_go() sx_async_ecp_mult_end() for an asynchronous versions static inline int sx_ecp_ptmult( const struct sx_pk_ecurve curve const sx_op k const sx_op Px const sx_op Py sx_op Rx sx_op Ry) { int status; struct sx_pk_dreq pkreq; pkreq = sx_async_ecp_mult_go(curve k Px Py); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_ecp_mult_end(pkreq req Rx Ry); return status; } ",
							" Asynchronous EC point doubling Starts an EC point doubling on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_ecp_double_end() ",
							" Parameters curve Elliptic curve used to perform point doubling ",
							" Parameters py x-coordinate of point P ",
							" Parameters px y-coordinate of point P @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_ecp_double_go( const struct sx_pk_ecurve curve const sx_op px const sx_op py) { struct sx_pk_dreq pkreq; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECC_PT_DOUBLE); if (pkreq status) return pkreq; struct sx_pk_inops_ecp_double inputs; pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(px inputs px addr opsz); SX_PK_OP2MEM(py inputs py addr opsz); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous EC point doubling Get the output operands of the EC point doubling and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters rx x-coordinate of resulting point R ",
							" Parameters ry y-coordinate of resulting point R static inline void sx_async_ecp_double_end( sx_pk_accel req sx_op rx sx_op ry) { sx_async_finish_pair(req rx ry); } ",
							" Compute point doubling on an elliptic curve (Rx Ry) = 2 (Px Py) ",
							" Parameters curve Elliptic curve used to perform point doubling ",
							" Parameters py x-coordinate of point P ",
							" Parameters px y-coordinate of point P ",
							" Parameters rx x-coordinate of resulting point R ",
							" Parameters ry y-coordinate of resulting point R @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecp_double_go() sx_async_ecp_double_end() for an asynchronous verion static inline int sx_ecp_double( const struct sx_pk_ecurve curve const sx_op px const sx_op py sx_op rx sx_op ry) { int status; struct sx_pk_dreq pkreq; pkreq = sx_async_ecp_double_go(curve px py); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_ecp_double_end(pkreq req rx ry); return status; } ",
							" Asynchronous (non-blocking) EC point on curve check Starts an EC point on curve check on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_PK_RELEASE_REQ() ",
							" Parameters curve Elliptic curve used to validate point ",
							" Parameters px x-coordinate of point P ",
							" Parameters py y-coordinate of point P @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_ec_ptoncurve_go( const struct sx_pk_ecurve curve const sx_op px const sx_op py) { struct sx_pk_dreq pkreq; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECC_PTONCURVE); if (pkreq status) return pkreq; struct sx_pk_inops_ec_ptoncurve inputs; pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(px inputs px addr opsz); SX_PK_OP2MEM(py inputs py addr opsz); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Check if the given point is on the given elliptic curve It succeeds if the following checks pass: For GF(p): 1 px p 2 py p 3 py 2 == px 3 + a px + b mod p For GF(2 m) where q = 2 m 1 px q 2 py q 3 py 2 + px py == px 3 + a px^2 + b mod q ",
							" Parameters curve Elliptic curve used to validate point ",
							" Parameters px x-coordinate of point P ",
							" Parameters py y-coordinate of point P @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED static inline int sx_ec_ptoncurve( const struct sx_pk_ecurve curve const sx_op px const sx_op py) { int status; struct sx_pk_dreq pkreq; pkreq = sx_async_ec_ptoncurve_go(curve px py); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); SX_PK_RELEASE_REQ(pkreq req); return status; } ",
							" Asynchronous (non-blocking) EC point decompression Starts an EC point decompression on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_ec_pt_decompression_end() ",
							" Parameters curve Elliptic curve used to validate point ",
							" Parameters x x-coordinate of point to decompress ",
							" Parameters y_lsb Least Significant Bit of y-coordinate @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_ec_pt_decompression_go( const struct sx_pk_ecurve curve const sx_op x const int y_lsb) { struct sx_pk_dreq pkreq; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECC_PT_DECOMP); if (pkreq status) return pkreq; struct sx_pk_inops_ec_pt_decompression inputs; pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve ((y_lsb 1) 29) (struct sx_pk_slot) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(x inputs x addr opsz); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) EC point decompression Get the output operand of the EC point decompression and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters y y-coordinate of decompressed point static inline void sx_async_ec_pt_decompression_end( sx_pk_accel req sx_op y) { sx_async_finish_single(req y); } ",
							" ECC point decompression Recover the y coordinate of a point using x value and LSB of y: 1 y = sqrt(x^3 + a x + b) | Param | Description | |:----- |:----------- | | 2 if (y 1) = y_lsb then y = p | y with a and p the curve parameters 3 else return ::SX_ERR_NOT_QUADRATIC_RESIDUE @remark: Point decompression is supported for GF(p) only ",
							" Parameters curve Elliptic curve used to validate point ",
							" Parameters x x-coordinate of point to decompress ",
							" Parameters y_lsb Least Significant Bit of y-coordinate ",
							" Parameters y y-coordinate of decompressed point @return ::SX_OK @return ::SX_ERR_NOT_QUADRATIC_RESIDUE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED static inline int sx_ec_pt_decompression( const struct sx_pk_ecurve curve const sx_op x const int y_lsb sx_op y) { int status; struct sx_pk_dreq pkreq; pkreq = sx_async_ec_pt_decompression_go(curve x y_lsb); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_ec_pt_decompression_end(pkreq req y); return status; } ",
							" @addtogroup SX_PK_SXOPS_ECOPS @{ ",
							" Asynchronous (non-blocking) EC point addition Start an EC point addition on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_ecp_add_end() ",
							" Parameters curve Elliptic curve to perform EC point addition ",
							" Parameters p1x x-coordinate of first point ",
							" Parameters p1y y-coordinate of first point ",
							" Parameters p2x x-coordinate of second point ",
							" Parameters p2y y-coordinate of second point @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_ecp_add_go( const struct sx_pk_ecurve curve const sx_op p1x const sx_op p1y const sx_op p2x const sx_op p2y) { struct sx_pk_dreq pkreq; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECC_PT_ADD); if (pkreq status) return pkreq; struct sx_pk_inops_ecp_add inputs; pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(p1x inputs p1x addr opsz); SX_PK_OP2MEM(p1y inputs p1y addr opsz); SX_PK_OP2MEM(p2x inputs p2x addr opsz); SX_PK_OP2MEM(p2y inputs p2y addr opsz); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) EC point addition Get the output operands of the EC point addition and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters rx x-coordinate of resulting addition point ",
							" Parameters ry y-coordinate of resulting addition point static inline void sx_async_ecp_add_end( sx_pk_accel req sx_op rx sx_op ry) { sx_async_finish_pair(req rx ry); } ",
							" Compute point addition on an elliptic curve (Rx Ry) = P1 + P2 If P1 == P2 returns an SX_ERR_NOT_INVERTIBLE error @remark Use point doubling operation for the addition of equal points ",
							" Parameters curve Elliptic curve to do point addition ",
							" Parameters p1x x-coordinate of point P1 ",
							" Parameters p1y y-coordinate of point P1 ",
							" Parameters p2x x-coordinate of point P2 ",
							" Parameters p2y y-coordinate of point P2 ",
							" Parameters rx x-coordinate of resulting point R ",
							" Parameters ry y-coordinate of resulting point R @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @remark Use point doubling operation for the addition of equal points @see sx_ecp_double() static inline int sx_ecp_ptadd( const struct sx_pk_ecurve curve const sx_op p1x const sx_op p1y const sx_op p2x const sx_op p2y sx_op rx sx_op ry) { int status; struct sx_pk_dreq pkreq; pkreq = sx_async_ecp_add_go(curve p1x p1y p2x p2y); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_ecp_add_end(pkreq req rx ry); return status; } } ",
							" \"sxops\" interface for EC J-PAKE computations Simpler functions to perform public key crypto operations Included directly in some interfaces (like sxbuf or OpenSSL engine) The functions take input operands (large integers) and output operands which will receive the computed results Operands have the \"sx_op\" type The specific interfaces (like sxbuf) define the \"sx_op\" type @file ",
							" ECJPAKE_HEADER_FILE Macro ",
							" C #define ECJPAKE_HEADER_FILE / Copyright (c) 2020 Silex Insight sa SPDX-License-Identifier: BSD-3-Clause ",
							" Make sure the application is compatible with SilexPK API version **/ SX_PK_API_ASSERT_COMPATIBLE(1 3); struct sx_pk_ecurve; ",
							" sx_pk_point Function ",
							" C struct sx_pk_point { @addtogroup SX_PK_SXOPS_ECJPAKE @{ ",
							" Curve generator point for sx_ecjpake_verify_zkp() or sx_ecjpake_verify_zkp_go() */ ",
							" Affine point parameter group This structure is used for point values which are stored in two consecutive locations (x and y) struct sx_pk_point { sx_op x; / x-coordinate / sx_op y; / y-coordinate / }; ",
							" Asynchronous EC J-PAKE proof generation Start a EC J-PAKE proof generation operation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_generate_zkp_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters v Random input ( n) ",
							" Parameters x Exponent ",
							" Parameters h Hash digest Truncation or padding should be done by user application @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_generate_zkp_go( const struct sx_pk_ecurve curve const sx_op v const sx_op x const sx_op h) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_generate_zkp inputs; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECJPAKE_GENERATE_ZKP); if (pkreq status) return pkreq; pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); SX_PK_OP2MEM(v inputs v addr opsz); SX_PK_OP2MEM(x inputs x addr opsz); SX_PK_OP2MEM(h inputs h addr opsz); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) EC J-PAKE proof generation Get the output operands of the EC J-PAKE proof generation and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters r The resulting value static inline void sx_ecjpake_generate_zkp_end( sx_pk_accel req sx_op r) { sx_async_finish_single(req r); } ",
							" Perform an EC J-PAKE proof generation The proof generation has the following steps: | Param | Description | |:----- |:----------- | | 1 r = (v | (x h)) % n ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters v Random input ( n) ",
							" Parameters x Exponent ",
							" Parameters h Hash digest Truncation or padding should be done by user application ",
							" Parameters r The result @return ::SX_OK @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecjpake_generate_zkp_go() sx_async_ecjpake_generate_zkp_end() for an asynchronous version static inline int sx_ecjpake_generate_zkp( const struct sx_pk_ecurve curve const sx_op v const sx_op x const sx_op h sx_op r ) { uint32_t status; struct sx_pk_dreq pkreq; pkreq = sx_ecjpake_generate_zkp_go(curve v x h); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_ecjpake_generate_zkp_end(pkreq req r); return status; } ",
							" Asynchronous EC J-PAKE proof verification Start an EC J-PAKE proof verification operation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_ecjpake_verify_zkp_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters v Point on the curve ",
							" Parameters x Point on the curve ",
							" Parameters r Proof to be verified ",
							" Parameters h Hash digest ",
							" Parameters g Point on the curve (Optional pass SX_PT_CURVE_GENERATOR to use the curve generator point) Truncation or padding should be done by user application @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_verify_zkp_go( const struct sx_pk_ecurve curve const struct sx_pk_point v const struct sx_pk_point x const sx_op r const sx_op h const struct sx_pk_point g) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_verify_zkp inputs; pkreq = SX_PK_ACQUIRE_REQ(curve- cnx SX_PK_CMD_ECJPAKE_VERIFY_ZKP); if (pkreq status) return pkreq; pkreq status = SX_PK_LIST_ECC_INSLOTS(pkreq req curve 0 (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; int opsz = SX_PK_GET_OPSIZE(pkreq req); sx_pk_op2mem(v- x inputs xv addr opsz); sx_pk_op2mem(v- y inputs yv addr opsz); sx_pk_op2mem(x- x inputs xx addr opsz); sx_pk_op2mem(x- y inputs yx addr opsz); sx_pk_op2mem(r inputs r addr opsz); sx_pk_op2mem(h inputs h addr opsz); if (g = SX_PT_CURVE_GENERATOR) { sx_pk_op2mem(g- x inputs xg2 addr opsz); sx_pk_op2mem(g- y inputs yg2 addr opsz); } else { sx_pk_write_curve_gen(pkreq req curve inputs xg2 inputs yg2); } SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) EC J-PAKE proof verification Finishes the EC J-PAKE proof verification and releases the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation static inline void sx_ecjpake_verify_zkp_end( sx_pk_accel req ) { sx_pk_release_req(req); } ",
							" Synchronous EC J-PAKE proof verification Start an EC J-PAKE proof verification operation on the accelerator and return immediately The proof verification has the following steps: 1 ( (G r) + (X h) ) = V In case of a comparison failure SX_ERR_INVALID_SIGNATURE shall be returned @remark When the operation finishes on the accelerator call sx_ecjpake_verify_zkp_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters v Point on the curve ",
							" Parameters x Point on the curve ",
							" Parameters r Proof to be verified ",
							" Parameters h Hash digest ",
							" Parameters g Point on the curve (Optional pass SX_PT_CURVE_GENERATOR to use the curve generator point) Truncation or padding should be done by user application @return ::SX_OK @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecjpake_verify_zkp_go() sx_async_ecjpake_verify_zkp_end() for an asynchronous version static inline int sx_ecjpake_verify_zkp( const struct sx_pk_ecurve curve const struct sx_pk_point v const struct sx_pk_point x const sx_op r const sx_op h const struct sx_pk_point g ) { uint32_t status; struct sx_pk_dreq pkreq; pkreq = sx_ecjpake_verify_zkp_go(curve v x r h g); if (pkreq status) return pkreq status; status = sx_pk_wait(pkreq req); sx_ecjpake_verify_zkp_end(pkreq req); return status; } ",
							" Asynchronous EC J-PAKE 3 point addition Start a EC J-PAKE 3 point addition operation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_ecjpake_3pt_add_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters a Point on the curve ",
							" Parameters b Point on the curve ",
							" Parameters c Point on the curve Truncation or padding should be done by user application @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_3pt_add_go( const struct sx_pk_ecurve curve const struct sx_pk_point a const struct sx_pk_point b const struct sx_pk_point c) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_3pt_add inputs; pkreq = sx_pk_acquire_req(curve- cnx SX_PK_CMD_ECJPAKE_3PT_ADD); if (pkreq status) return pkreq; pkreq status = sx_pk_list_ecc_inslots(pkreq req curve 0 (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; int opsz = sx_pk_get_opsize(pkreq req); sx_pk_op2mem(b- x inputs x2_1 addr opsz); sx_pk_op2mem(b- y inputs x2_2 addr opsz); sx_pk_op2mem(c- x inputs x3_1 addr opsz); sx_pk_op2mem(c- y inputs x3_2 addr opsz); sx_pk_op2mem(a- x inputs x1_1 addr opsz); sx_pk_op2mem(a- y inputs x1_2 addr opsz); sx_pk_run(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) EC J-PAKE 3 point addition Finishes the EC J-PAKE 3 point addition and releases the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters gb The addition result static inline void sx_ecjpake_3pt_add_end( sx_pk_accel req struct sx_pk_point gb ) { sx_async_finish_pair(req gb- x gb- y); } ",
							" Synchronous EC J-PAKE 3 point addition Start a EC J-PAKE 3 point addition operation on the accelerator and return immediately The 3 point addition operation has the following steps: 1 gb = a + b + c @remark When the operation finishes on the accelerator call sx_ecjpake_3pt_add_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters a Point on the curve ",
							" Parameters b Point on the curve ",
							" Parameters c Point on the curve ",
							" Parameters gb The addition result Truncation or padding should be done by user application @return ::SX_OK @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecjpake_verify_zkp_go() sx_async_ecjpake_verify_zkp_end() for an asynchronous version static inline int sx_ecjpake_3pt_add( const struct sx_pk_ecurve curve const struct sx_pk_point a const struct sx_pk_point b const struct sx_pk_point c struct sx_pk_point gb ) { uint32_t status; struct sx_pk_dreq pkreq; pkreq = sx_ecjpake_3pt_add_go(curve a b c); if (pkreq status) return pkreq status; status = sx_pk_wait(pkreq req); sx_ecjpake_3pt_add_end(pkreq req gb); return status; } ",
							" Asynchronous EC J-PAKE session key generation Start a EC J-PAKE session key generation operation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_ecjpake_gen_sess_key_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters x4 Point on the curve ",
							" Parameters b Point on the curve ",
							" Parameters x2 Generated random number ",
							" Parameters x2s (x2 s) % n Truncation or padding should be done by user application @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_gen_sess_key_go( const struct sx_pk_ecurve curve const struct sx_pk_point x4 const struct sx_pk_point b const sx_op x2 const sx_op x2s) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_gen_sess_key inputs; pkreq = sx_pk_acquire_req(curve- cnx SX_PK_CMD_ECJPAKE_GEN_SESS_KEY); if (pkreq status) return pkreq; pkreq status = sx_pk_list_ecc_inslots(pkreq req curve 0 (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; int opsz = sx_pk_get_opsize(pkreq req); sx_pk_op2mem(x4- x inputs x4_1 addr opsz); sx_pk_op2mem(x4- y inputs x4_2 addr opsz); sx_pk_op2mem(b- x inputs b_1 addr opsz); sx_pk_op2mem(b- y inputs b_2 addr opsz); sx_pk_op2mem(x2 inputs x2 addr opsz); sx_pk_op2mem(x2s inputs x2s addr opsz); sx_pk_run(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) EC J-PAKE session key generation Finishes the EC J-PAKE session key generation operation and releases the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters t The result static inline void sx_ecjpake_gen_sess_key_end( sx_pk_accel req struct sx_pk_point t) { sx_async_finish_pair(req t- x t- y); } ",
							" Synchronous EC J-PAKE session key generation Start a EC J-PAKE session key generation operation on the accelerator and return immediately The session key generation has the following steps: | Param | Description | |:----- |:----------- | | 1 T = (b | (x4 x2s)) x2 @remark When the operation finishes on the accelerator call sx_ecjpake_gen_sess_key_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters x4 Point on the curve ",
							" Parameters b Point on the curve ",
							" Parameters x2 Generated random number ",
							" Parameters x2s x2 password ",
							" Parameters t result Truncation or padding should be done by user application @return ::SX_OK @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecjpake_gen_sess_key_go() sx_async_ecjpake_gen_sess_key_end() for an asynchronous version static inline int sx_ecjpake_gen_sess_key( const struct sx_pk_ecurve curve const struct sx_pk_point x4 const struct sx_pk_point b const sx_op x2 const sx_op x2s struct sx_pk_point t ) { uint32_t status; struct sx_pk_dreq pkreq; pkreq = sx_ecjpake_gen_sess_key_go(curve x4 b x2 x2s); if (pkreq status) return pkreq status; status = sx_pk_wait(pkreq req); sx_ecjpake_gen_sess_key_end(pkreq req t); return status; } ",
							" Asynchronous EC J-PAKE step 2 calculation Start an EC J-PAKE step 2 calculation operation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_ecjpake_gen_step_2_end() ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters x4 Point on the curve ",
							" Parameters x3 Point on the curve ",
							" Parameters x1 Point on the curve ",
							" Parameters x2s (x2 s) % n ",
							" Parameters s password Truncation or padding should be done by user application @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_ecjpake_gen_step_2_go( const struct sx_pk_ecurve curve const struct sx_pk_point x4 const struct sx_pk_point x3 const struct sx_pk_point x1 const sx_op x2s const sx_op s) { struct sx_pk_dreq pkreq; struct sx_pk_inops_ecjpake_gen_step_2 inputs; pkreq = sx_pk_acquire_req(curve- cnx SX_PK_CMD_ECJPAKE_GEN_STEP_2); if (pkreq status) return pkreq; pkreq status = sx_pk_list_ecc_inslots(pkreq req curve 0 (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; int opsz = sx_pk_get_opsize(pkreq req); sx_pk_op2mem(x4- x inputs x4_1 addr opsz); sx_pk_op2mem(x4- y inputs x4_2 addr opsz); sx_pk_op2mem(x3- x inputs x3_1 addr opsz); sx_pk_op2mem(x3- y inputs x3_2 addr opsz); sx_pk_op2mem(x1- x inputs x1_1 addr opsz); sx_pk_op2mem(x1- y inputs x1_2 addr opsz); sx_pk_op2mem(x2s inputs x2s addr opsz); sx_pk_op2mem(s inputs s addr opsz); sx_pk_run(pkreq req); return pkreq; } ",
							" Finish an asynchronous (non-blocking) EC J-PAKE step 2 calculation Finishes the EC J-PAKE step 2 calculation operation and releases the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters a Point on the curve ",
							" Parameters x2s Generated random password ",
							" Parameters ga Point on the curve static inline void sx_ecjpake_gen_step_2_end( sx_pk_accel req struct sx_pk_point a sx_op x2s struct sx_pk_point ga) { sx_op results = { a- x a- y x2s ga- x ga- y }; sx_async_finish_any(req results 5); } ",
							" Synchronous EC J-PAKE step 2 calculation Start an EC J-PAKE step 2 calculation operation on the accelerator and return immediately The step 2 calculation has the following steps: 1 ga = x1 + x3 + x4 2 rx2s = (x2s s) % curve n 3 a = ga rx2s ",
							" Parameters curve Elliptic curve on which to perform the operation ",
							" Parameters x4 Point on the curve ",
							" Parameters x3 Point on the curve ",
							" Parameters x1 Point on the curve ",
							" Parameters x2s Generated random password ",
							" Parameters s Password ",
							" Parameters a Point on the curve ",
							" Parameters rx2s Generated random password ",
							" Parameters ga Point on the curve Truncation or padding should be done by user application @return ::SX_OK @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ecjpake_gen_step_2_go() sx_async_ecjpake_gen_step_2_end() for an asynchronous version static inline int sx_ecjpake_gen_step_2( const struct sx_pk_ecurve curve const struct sx_pk_point x4 const struct sx_pk_point x3 const struct sx_pk_point x1 const sx_op x2s const sx_op s struct sx_pk_point a sx_op rx2s struct sx_pk_point ga ) { uint32_t status; struct sx_pk_dreq pkreq; pkreq = sx_ecjpake_gen_step_2_go(curve x4 x3 x1 x2s s); if (pkreq status) return pkreq status; status = sx_pk_wait(pkreq req); sx_ecjpake_gen_step_2_end(pkreq req a rx2s ga); return status; } } ",
							" Simpler functions for base ED25519 operations @file ",
							" ED25519_HEADER_FILE Macro ",
							" C #define ED25519_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Size in bytes of a reduced value in ED25519 operations */ ",
							" Size in bytes of an encoded ED25519 point */ ",
							" SX_ED25519_PT_SZ Macro ",
							" C #define SX_ED25519_PT_SZ 32 ",
							" Size in bytes of a digest in ED25519 operations */ ",
							" SX_ED25519_DGST_SZ Macro ",
							" C #define SX_ED25519_DGST_SZ (32 2) @addtogroup SX_PK_ED25519 @{ ",
							" An encoded ED25519 point */ struct sx_ed25519_pt { ",
							" Bytes array representing encoded point for ED25519 **/ char encoded ; }; ",
							" A ED25519 scalar value */ struct sx_ed25519_v { ",
							" Bytes array representing scalar for ED25519 **/ char bytes ; }; ",
							" A hash digest used in the ED25519 protocol */ struct sx_ed25519_dgst { ",
							" Bytes array of hash digest **/ char bytes ; }; ",
							" EDDSA point multiplication (ED25519) ",
							" SX_ED25519_PTMULT Macro ",
							" C typedef int (FUNC_SX_ED25519_PTMULT)(struct sx_pk_cnx cnx const struct sx_ed25519_dgst r struct sx_ed25519_pt pt); #define SX_ED25519_PTMULT ((FUNC_SX_ED25519_PTMULT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ED25519_PTMULT))) Compute R = r G where r is a scalar which can be up to twice the size of the other operands G is the generator point for the curve The point R is encoded in pt When computing the public key the scalar 'r' is the secret scalar based on the clamped hash digest of the private key ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters r Secret scalar based on the clamped hash digest of the private key ",
							" Parameters pt Encoded resulting R point @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see SX_ASYNC_ED25519_PTMULT_GO() and SX_ASYNC_ED25519_PTMULT_END() for an asynchronous version ",
							" Asynchronous EDDSA point multiplication (ED25519) ",
							" SX_ASYNC_ED25519_PTMULT_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_ASYNC_ED25519_PTMULT_GO)(struct sx_pk_cnx cnx const struct sx_ed25519_dgst r); #define SX_ASYNC_ED25519_PTMULT_GO ((FUNC_SX_ASYNC_ED25519_PTMULT_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED25519_PTMULT_GO))) Start an EDDSA point multiplication on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_ASYNC_ED25519_PTMULT_END() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters r Secret scalar based on the clamped hash digest of the private key @return Acquired acceleration request for this operation @see SX_ASYNC_ED25519_PTMULT_END() and SX_ED25519_PTMULT() ",
							" Collect the result of asynchronous EDDSA point multiplication (ED25519) ",
							" SX_ASYNC_ED25519_PTMULT_END Macro ",
							" C typedef void (FUNC_SX_ASYNC_ED25519_PTMULT_END)(sx_pk_accel req struct sx_ed25519_pt pt); #define SX_ASYNC_ED25519_PTMULT_END ((FUNC_SX_ASYNC_ED25519_PTMULT_END)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED25519_PTMULT_END))) Get the output operands of the EDDSA point multiplication and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters pt Encoded resulting R point @see SX_ASYNC_ED25519_PTMULT_GO() and SX_ED25519_PTMULT() ",
							" Compute signature scalar s for pure EDDSA (ED25519) ",
							" SX_ED25519_SIGN Macro ",
							" C typedef int (FUNC_SX_ED25519_SIGN)(struct sx_pk_cnx cnx const struct sx_ed25519_dgst k const struct sx_ed25519_dgst r const struct sx_ed25519_v s struct sx_ed25519_v sig_s); #define SX_ED25519_SIGN ((FUNC_SX_ED25519_SIGN)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ED25519_SIGN))) This represents the second step in computing an EDDSA signature This step computes sig_s : sig_s = (r + k s) % l ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters r Secret nonce already used in the first signature step ",
							" Parameters s Secret scalar derived from the private key ",
							" Parameters sig_s Second part of the EDDSA signature @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ed25519_sign_go() and SX_ASYNC_ED25519_SIGN_END() for an asynchronous version ",
							" Asynchronous second part signature generation for pure EDDSA (ED25519) ",
							" SX_PK_ASYNC_ED25519_SIGN_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_PK_ASYNC_ED25519_SIGN_GO)(struct sx_pk_cnx cnx const struct sx_ed25519_dgst k const struct sx_ed25519_dgst r const struct sx_ed25519_v s); #define SX_PK_ASYNC_ED25519_SIGN_GO ((FUNC_SX_PK_ASYNC_ED25519_SIGN_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_ASYNC_ED25519_SIGN_GO))) Start an ED25519 signature generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_ASYNC_ED25519_SIGN_END() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters r Secret nonce already used in the first signature step ",
							" Parameters s Secret scalar derived from the private key @return Acquired acceleration request for this operation @see SX_ED25519_SIGN() and SX_ASYNC_ED25519_SIGN_END() ",
							" Collect the result of asynchronous computation of ED25519 signature scalar ",
							" SX_ASYNC_ED25519_SIGN_END Macro ",
							" C typedef void (FUNC_SX_ASYNC_ED25519_SIGN_END)(sx_pk_accel req struct sx_ed25519_v sig_s); #define SX_ASYNC_ED25519_SIGN_END ((FUNC_SX_ASYNC_ED25519_SIGN_END)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED25519_SIGN_END))) Get the output operands of the ED25519 signature generation and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters sig_s Second part of the ED25519 signature @see SX_PK_ASYNC_ED25519_SIGN_GO() and SX_ED25519_SIGN() ",
							" Verify an EDDSA signature (ED25519) ",
							" SX_ED25519_VERIFY Macro ",
							" C typedef int (FUNC_SX_ED25519_VERIFY)(struct sx_pk_cnx cnx const struct sx_ed25519_dgst k const struct sx_ed25519_pt a const struct sx_ed25519_v sig_s const struct sx_ed25519_pt r); #define SX_ED25519_VERIFY ((FUNC_SX_ED25519_VERIFY)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ED25519_VERIFY))) It checks if sig_s G - k A matches R sig_s and the encoded point R form the signature The points A and R are passed in their encoded form via 'a' and 'r' ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters a Encoded public key ",
							" Parameters sig_s Second part of the signature ",
							" Parameters r Encoded first part of the signature @return ::SX_OK @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see SX_ASYNC_ED25519_VERIFY_GO() for an asynchronous version ",
							" Asynchronous (non-blocking) verify an ED25519 signature ",
							" SX_ASYNC_ED25519_VERIFY_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_ASYNC_ED25519_VERIFY_GO)(struct sx_pk_cnx cnx const struct sx_ed25519_dgst k const struct sx_ed25519_pt a const struct sx_ed25519_v sig_s const struct sx_ed25519_pt r); #define SX_ASYNC_ED25519_VERIFY_GO ((FUNC_SX_ASYNC_ED25519_VERIFY_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED25519_VERIFY_GO))) Start an ED25519 signature generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_PK_RELEASE_REQ() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters a Encoded public key ",
							" Parameters sig_s Second part of the signature ",
							" Parameters r Encoded first part of the signature @return Acquired acceleration request for this operation @see SX_ED25519_VERIFY() } ",
							" Simpler functions for base ED448 operations @file ",
							" ED448_HEADER_FILE Macro ",
							" C #define ED448_HEADER_FILE / Copyright (c) 2020 Silex Insight sa SPDX-License-Identifier: BSD-3-Clause ",
							" Size in bytes of a reduced value in ED448 operations */ ",
							" Size in bytes of an encoded ED448 point */ ",
							" SX_ED448_PT_SZ Macro ",
							" C #define SX_ED448_PT_SZ 57 ",
							" Size in bytes of a digest in ED448 operations */ ",
							" SX_ED448_DGST_SZ Macro ",
							" C #define SX_ED448_DGST_SZ (57 2) @addtogroup SX_PK_ED448 @{ ",
							" An encoded ED448 point */ struct sx_ed448_pt { ",
							" Bytes array representing encoded point for ED448 **/ char encoded ; }; ",
							" A ED448 scalar value */ struct sx_ed448_v { ",
							" Bytes array representing scalar for ED448 **/ char bytes ; }; ",
							" A hash digest used in the ED448 protocol */ struct sx_ed448_dgst { ",
							" Bytes array of hash digest **/ char bytes ; }; ",
							" EDDSA point multiplication (ED448) ",
							" SX_ED448_PTMULT Macro ",
							" C typedef int (FUNC_SX_ED448_PTMULT)(struct sx_pk_cnx cnx const struct sx_ed448_dgst r struct sx_ed448_pt pt); #define SX_ED448_PTMULT ((FUNC_SX_ED448_PTMULT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ED448_PTMULT))) Compute R = r G where r is a scalar which can be up to twice the size of the other operands G is the generator point for the curve The point R is encoded in pt When computing the public key the scalar 'r' is the secret scalar based on the clamped hash digest of the private key ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters r Secret scalar based on the clamped hash digest of the private key ",
							" Parameters pt Encoded resulting R point @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see SX_ASYNC_ED448_PTMULT_GO() and SX_ASYNC_ED448_PTMULT_END() for an asynchronous version ",
							" Asynchronous EDDSA point multiplication (ED448) ",
							" SX_ASYNC_ED448_PTMULT_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_ASYNC_ED448_PTMULT_GO)(struct sx_pk_cnx cnx const struct sx_ed448_dgst r); #define SX_ASYNC_ED448_PTMULT_GO ((FUNC_SX_ASYNC_ED448_PTMULT_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED448_PTMULT_GO))) Start an EDDSA point multiplication on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_ASYNC_ED448_PTMULT_END() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters r Secret scalar based on the clamped hash digest of the private key @return Acquired acceleration request for this operation @see SX_ASYNC_ED448_PTMULT_END() and SX_ED448_PTMULT() ",
							" Collect the result of asynchronous EDDSA point multiplication (ED448) ",
							" SX_ASYNC_ED448_PTMULT_END Macro ",
							" C typedef void (FUNC_SX_ASYNC_ED448_PTMULT_END)(sx_pk_accel req struct sx_ed448_pt pt); #define SX_ASYNC_ED448_PTMULT_END ((FUNC_SX_ASYNC_ED448_PTMULT_END)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED448_PTMULT_END))) Get the output operands of the EDDSA point multiplication and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters pt Encoded resulting R point @see SX_ASYNC_ED448_PTMULT_GO() and SX_ED448_PTMULT() ",
							" Compute signature scalar s for pure EDDSA (ED448) ",
							" SX_ED448_SIGN Macro ",
							" C typedef int (FUNC_SX_ED448_SIGN)(struct sx_pk_cnx cnx const struct sx_ed448_dgst k const struct sx_ed448_dgst r const struct sx_ed448_v s struct sx_ed448_v sig_s); #define SX_ED448_SIGN ((FUNC_SX_ED448_SIGN)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ED448_SIGN))) This represents the second step in computing an EDDSA signature This step computes sig_s : sig_s = (r + k s) % l ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters r Secret nonce already used in the first signature step ",
							" Parameters s Secret scalar derived from the private key ",
							" Parameters sig_s Second part of the EDDSA signature @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_ed448_sign_go() and SX_ASYNC_ED448_SIGN_END() for an asynchronous version ",
							" Asynchronous second part signature generation for pure EDDSA (ED448) ",
							" SX_PK_ASYNC_ED448_SIGN_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_PK_ASYNC_ED448_SIGN_GO)(struct sx_pk_cnx cnx const struct sx_ed448_dgst k const struct sx_ed448_dgst r const struct sx_ed448_v s); #define SX_PK_ASYNC_ED448_SIGN_GO ((FUNC_SX_PK_ASYNC_ED448_SIGN_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_PK_ASYNC_ED448_SIGN_GO))) Start an ED448 signature generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_ASYNC_ED448_SIGN_END() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters r Secret nonce already used in the first signature step ",
							" Parameters s Secret scalar derived from the private key @return Acquired acceleration request for this operation @see SX_ED448_SIGN() and SX_ASYNC_ED448_SIGN_END() ",
							" Collect the result of asynchronous computation of ED448 signature scalar ",
							" SX_ASYNC_ED448_SIGN_END Macro ",
							" C typedef void (FUNC_SX_ASYNC_ED448_SIGN_END)(sx_pk_accel req struct sx_ed448_v sig_s); #define SX_ASYNC_ED448_SIGN_END ((FUNC_SX_ASYNC_ED448_SIGN_END)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED448_SIGN_END))) Get the output operands of the ED448 signature generation and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters sig_s Second part of the ED448 signature @see SX_PK_ASYNC_ED448_SIGN_GO() and SX_ED448_SIGN() ",
							" Verify an EDDSA signature (ED448) ",
							" SX_ED448_VERIFY Macro ",
							" C typedef int (FUNC_SX_ED448_VERIFY)(struct sx_pk_cnx cnx const struct sx_ed448_dgst k const struct sx_ed448_pt a const struct sx_ed448_v sig_s const struct sx_ed448_pt r); #define SX_ED448_VERIFY ((FUNC_SX_ED448_VERIFY)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ED448_VERIFY))) It checks if sig_s G - k A matches R sig_s and the encoded point R form the signature The points A and R are passed in their encoded form via 'a' and 'r' ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters a Encoded public key ",
							" Parameters sig_s Second part of the signature ",
							" Parameters r Encoded first part of the signature @return ::SX_OK @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_POINT_NOT_ON_CURVE @return ::SX_ERR_INVALID_SIGNATURE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see SX_ASYNC_ED448_VERIFY_GO() for an asynchronous version ",
							" Asynchronous (non-blocking) verify an ED448 signature ",
							" SX_ASYNC_ED448_VERIFY_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_ASYNC_ED448_VERIFY_GO)(struct sx_pk_cnx cnx const struct sx_ed448_dgst k const struct sx_ed448_pt a const struct sx_ed448_v sig_s const struct sx_ed448_pt r); #define SX_ASYNC_ED448_VERIFY_GO ((FUNC_SX_ASYNC_ED448_VERIFY_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_ED448_VERIFY_GO))) Start an ED448 signature generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_PK_RELEASE_REQ() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Hash of the encoded point R the public key and the message It is interpreted as a scalar with a size double of other operands ",
							" Parameters a Encoded public key ",
							" Parameters sig_s Second part of the signature ",
							" Parameters r Encoded first part of the signature @return Acquired acceleration request for this operation @see SX_ED448_VERIFY() } ",
							" \"sxops\" interface to finalise acceleration requests and get the output operands @file ",
							" SXOPS_IMPL_HEADER_FILE Macro ",
							" C #define SXOPS_IMPL_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Make sure the application is compatible with SilexPK API version **/ SX_PK_API_ASSERT_COMPATIBLE(1 0); ",
							" Finish an operation with one result operands Write the single result in the result operand and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters pkhw The acceleration request where an operation with 1 output operands has finished ",
							" Parameters result Result operand of a single output operand operation static inline void sx_async_finish_single(sx_pk_accel pkhw sx_op result) { const char outputs = SX_PK_GET_OUTPUT_OPS(pkhw); const int opsz = SX_PK_GET_OPSIZE(pkhw); SX_PK_MEM2OP(outputs opsz result); SX_PK_RELEASE_REQ(pkhw); } ",
							" Finish an operation with two result operands Write the two results in the result operand and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters pkhw The acceleration request where the operation with 2 output operands has finished ",
							" Parameters r1 First result operand of the operation ",
							" Parameters r2 Second result operand of the operation static inline void sx_async_finish_pair(sx_pk_accel pkhw sx_op r1 sx_op r2) { const char outputs = SX_PK_GET_OUTPUT_OPS(pkhw); const int opsz = SX_PK_GET_OPSIZE(pkhw); SX_PK_MEM2OP(outputs opsz r1); SX_PK_MEM2OP(outputs opsz r2); SX_PK_RELEASE_REQ(pkhw); } ",
							" Finish an operation with four result operands Write the four results in the result operand buffers and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters pkhw The acceleration request where the operation with 4 resulting operands has finished ",
							" Parameters r1 First result operand of the operation ",
							" Parameters r2 Second result operand of the operation ",
							" Parameters r3 Third result operand of the operation ",
							" Parameters r4 Fourth result operand of the operation static inline void sx_async_finish_quad(sx_pk_accel pkhw sx_op r1 sx_op r2 sx_op r3 sx_op r4) { const char outputs = SX_PK_GET_OUTPUT_OPS(pkhw); const int opsz = SX_PK_GET_OPSIZE(pkhw); SX_PK_MEM2OP(outputs opsz r1); SX_PK_MEM2OP(outputs opsz r2); SX_PK_MEM2OP(outputs opsz r3); SX_PK_MEM2OP(outputs opsz r4); SX_PK_RELEASE_REQ(pkhw); } Write results in the result operand buffer and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters pkhw The acceleration request where the operation with 'count' resulting operands has finished ",
							" Parameters results Buffer of result operands of the operation ",
							" Parameters count The number of result operands static inline void sx_async_finish_any(sx_pk_accel pkhw sx_op results int count) { const char outputs = SX_PK_GET_OUTPUT_OPS(pkhw); const int opsz = SX_PK_GET_OPSIZE(pkhw); for (int i=0; i count; i++) SX_PK_MEM2OP(outputs opsz results ); SX_PK_RELEASE_REQ(pkhw); } ",
							" Input slots for operations @file ",
							" INPUTSLOTS_HEADER_FILE Macro ",
							" C #define INPUTSLOTS_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering SPDX-License-Identifier: BSD-3-Clause ",
							" Input slots for ::SX_PK_CMD_ODD_MOD_INV ::SX_PK_CMD_ODD_MOD_REDUCE ::SX_PK_CMD_MOD_SQRT ::SX_PK_CMD_EVEN_MOD_INV ::SX_PK_CMD_ODD_MOD_REDUCE struct sx_pk_inops_mod_single_op_cmd { struct sx_pk_slot n; / Modulus / struct sx_pk_slot b; / Value / }; ",
							" Input slots for ::SX_PK_CMD_MOD_ADD ::SX_PK_CMD_MOD_SUB ::SX_PK_CMD_ODD_MOD_MULT ::SX_PK_CMD_ODD_MOD_DIV struct sx_pk_inops_mod_cmd { struct sx_pk_slot n; / Modulus / struct sx_pk_slot a; / Operand A / struct sx_pk_slot b; / Operand B / }; ",
							" Input slots for ::SX_PK_CMD_MULT */ struct sx_pk_inops_mult { struct sx_pk_slot a; / First scalar value / struct sx_pk_slot b; / Second scalar value / }; ",
							" Input slots for ::SX_PK_CMD_MOD_EXP */ struct sx_pk_inops_mod_exp { struct sx_pk_slot m; / Modulus / struct sx_pk_slot input; / Base / struct sx_pk_slot exp; / Exponent / }; ",
							" Input slots for ::SX_PK_CMD_RSA_MOD_EXP_CM */ struct sx_pk_inops_rsa_mod_exp_cm { struct sx_pk_slot m; / Modulus / struct sx_pk_slot lambda_n; / Lambda_n / struct sx_pk_slot input; / Base / struct sx_pk_slot exp; / Exponent / struct sx_pk_slot blind; / Blinding factor / }; ",
							" Input slots for ::SX_PK_CMD_MOD_EXP_CRT */ struct sx_pk_inops_crt_mod_exp { struct sx_pk_slot p; / Prime number p / struct sx_pk_slot q; / Prime number q / struct sx_pk_slot in; / Input / struct sx_pk_slot dp; / d mod (p-1) with d the private key / struct sx_pk_slot dq; / d mod (q-1) with d the private key / struct sx_pk_slot qinv; / q^(-1) mod p / }; ",
							" Input slots for ::SX_PK_CMD_RSA_KEYGEN */ struct sx_pk_inops_rsa_keygen { struct sx_pk_slot p; / Prime number p / struct sx_pk_slot q; / Prime number q / struct sx_pk_slot e; / Public exponent / }; ",
							" Input slots for ::SX_PK_CMD_RSA_CRT_KEYPARAMS */ struct sx_pk_inops_rsa_crt_keyparams { struct sx_pk_slot p; / Prime number p / struct sx_pk_slot q; / Prime number q / struct sx_pk_slot privkey; / Private key / }; ",
							" Input slots for ::SX_PK_CMD_SRP_USER_KEY_GEN */ struct sx_pk_inops_srp_user_keyparams { struct sx_pk_slot n; / Safe prime number / struct sx_pk_slot g; / Generator of the multiplicative group / struct sx_pk_slot a; / Random value / struct sx_pk_slot b; / k g x + g t with t random salt k value derived by both sides (for example k = H(n g)) / struct sx_pk_slot x; / Hash of (s p) with s a random salt and p the user password / struct sx_pk_slot k; / Hash of (n g) / struct sx_pk_slot u; / Hash of (g^a b) / }; ",
							" Input slots for ::SX_PK_CMD_ECKCDSA_SIGN */ struct sx_pk_inops_eckcdsa_sign { struct sx_pk_slot d; / Private key / struct sx_pk_slot k; / Random value / struct sx_pk_slot r; / First part of signature / struct sx_pk_slot h; / Hash digest / }; ",
							" Input slots for ::SX_PK_CMD_MONTGOMERY_PTMUL */ struct sx_pk_inops_montgomery_mult { struct sx_pk_slot p; / Point P / struct sx_pk_slot k; / Scalar / }; ",
							" Input slots for ::SX_PK_CMD_ECC_PT_ADD */ struct sx_pk_inops_ecp_add { struct sx_pk_slot p1x; / x-coordinate of point P1 / struct sx_pk_slot p1y; / y-coordinate of point P1 / struct sx_pk_slot p2x; / x-coordinate of point P2 / struct sx_pk_slot p2y; / y-coordinate of point P2 / }; ",
							" Input slots for ::SX_PK_CMD_ECC_PTMUL */ struct sx_pk_inops_ecp_mult { struct sx_pk_slot k; / Scalar / struct sx_pk_slot px; / x-coordinate of point P / struct sx_pk_slot py; / y-coordinate of point P / }; ",
							" Input slots for ::SX_PK_CMD_ECC_PT_DOUBLE */ struct sx_pk_inops_ecp_double { struct sx_pk_slot px; / x-coordinate of point P / struct sx_pk_slot py; / y-coordinate of point P / }; ",
							" Input slots for ::SX_PK_CMD_ECC_PTONCURVE */ struct sx_pk_inops_ec_ptoncurve { struct sx_pk_slot px; / x-coordinate of point P / struct sx_pk_slot py; / y-coordinate of point P / }; ",
							" Input slots for ::SX_PK_CMD_ECC_PT_DECOMP */ struct sx_pk_inops_ec_pt_decompression { struct sx_pk_slot x; / x-coordinate of compressed point / }; ",
							" Input slots for ::SX_PK_CMD_ECDSA_VER ::SX_PK_CMD_ECKCDSA_VER ::SX_PK_CMD_SM2_VER struct sx_pk_inops_ecdsa_verify { struct sx_pk_slot qx; / x-coordinate of public key / struct sx_pk_slot qy; / y-coordinate of public key / struct sx_pk_slot r; / First part of signature / struct sx_pk_slot s; / Second part of signature / struct sx_pk_slot h; / Hash digest / }; ",
							" Input slots for ::SX_PK_CMD_ECDSA_GEN ::SX_PK_CMD_SM2_GEN */ struct sx_pk_inops_ecdsa_generate { struct sx_pk_slot d; / Private key / struct sx_pk_slot k; / Random value / struct sx_pk_slot h; / Hash digest / }; ",
							" Input slots for ::SX_PK_CMD_SM2_EXCH */ struct sx_pk_inops_sm2_exchange { struct sx_pk_slot d; / Private key / struct sx_pk_slot k; / Random value / struct sx_pk_slot qx; / x-coordinate of public key / struct sx_pk_slot qy; / y-coordinate of public key / struct sx_pk_slot rbx; / x-coordinate of random value from B / struct sx_pk_slot rby; / y-coordinate of random value from B / struct sx_pk_slot cof; / Cofactor / struct sx_pk_slot rax; / x-coordinate of random value from A / struct sx_pk_slot w; / (log2(n)/2)-1 with n the curve order / }; ",
							" Input slots for ::SX_PK_CMD_ECKCDSA_PUBKEY_GEN */ struct sx_pk_inops_eckcdsa_generate { struct sx_pk_slot d; / Private key / }; ",
							" Input slots for ::SX_PK_CMD_EDDSA_PTMUL */ struct sx_pk_inops_eddsa_ptmult { struct sx_pk_dblslot r; / Scalar / }; ",
							" Input slots for ::SX_PK_CMD_EDDSA_SIGN */ struct sx_pk_inops_eddsa_sign { struct sx_pk_dblslot k; / Scalar with a size double of other operands / struct sx_pk_dblslot r; / Signature part 1 / struct sx_pk_slot s; / Signature part 2 / }; ",
							" Input slots for ::SX_PK_CMD_EDDSA_VER */ struct sx_pk_inops_eddsa_ver { struct sx_pk_dblslot k; / Scalar with a size double of other operands / struct sx_pk_slot ay; / Encoded public key / struct sx_pk_slot sig_s; / Signature part 2 / struct sx_pk_slot ry; / y-coordinate of r / }; ",
							" Input slots for ::SX_PK_CMD_MILLER_RABIN */ struct sx_pk_inops_miller_rabin { struct sx_pk_slot n; / Candidate prime value / struct sx_pk_slot a; / Random value / }; ",
							" Input slots for ::SX_PK_CMD_DSA_SIGN */ struct sx_pk_inops_dsa_sign { struct sx_pk_slot p; / Prime modulus / struct sx_pk_slot q; / Prime divisor of p-1 / struct sx_pk_slot g; / Generator / struct sx_pk_slot k; / Random value / struct sx_pk_slot privkey; / Private key / struct sx_pk_slot h; / Hash digest / }; ",
							" Input slots for ::SX_PK_CMD_DSA_VER */ struct sx_pk_inops_dsa_ver { struct sx_pk_slot p; / Prime modulus / struct sx_pk_slot q; / Prime divisor of p-1 / struct sx_pk_slot g; / Generator / struct sx_pk_slot pubkey; / Public key / struct sx_pk_slot r; / First part of signature / struct sx_pk_slot s; / Second part of signature / struct sx_pk_slot h; / Hash digest / }; ",
							" Input slots for ::SX_PK_CMD_SM9_EXP */ struct sx_pk_inops_sm9_exp { struct sx_pk_slot h; / exponent / struct sx_pk_slot t; / polynomial base / struct sx_pk_slot g ; / g in GT / }; ",
							" Input slots for ::SX_PK_CMD_SM9_PMULG1 */ struct sx_pk_inops_sm9_pmulg1 { struct sx_pk_slot p1x0; / x-coordinate / struct sx_pk_slot p1y0; / y-coordinate / struct sx_pk_slot ke; / scalar / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_SM9_PMULG2 */ struct sx_pk_inops_sm9_pmulg2 { struct sx_pk_slot p2x0; / x-coordinate 0 / struct sx_pk_slot p2x1; / x-coordinate 1 / struct sx_pk_slot p2y0; / y-coordinate 0 / struct sx_pk_slot p2y1; / y-coordinate 1 / struct sx_pk_slot ke; / scalar / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_SM9_PAIR */ struct sx_pk_inops_sm9_pair { struct sx_pk_slot qx0; / Q x-coordinate 0 / struct sx_pk_slot qx1; / Q x-coordinate 1 / struct sx_pk_slot qy0; / Q y-coordinate 0 / struct sx_pk_slot qy1; / Q y-coordinate 1 / struct sx_pk_slot px0; / P x-coordinate / struct sx_pk_slot py0; / P y-coordinate / struct sx_pk_slot f; / frobenius constant / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_SM9_PRIVSIGKEYGEN */ struct sx_pk_inops_sm9_sigpkgen { struct sx_pk_slot p1x0; / x-coordinate / struct sx_pk_slot p1y0; / y-coordinate / struct sx_pk_slot h; / scalar / struct sx_pk_slot ks; / scalar / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_SM9_SIGNATUREGEN */ struct sx_pk_inops_sm9_signaturegen { struct sx_pk_slot dsx0; / x-coordinate / struct sx_pk_slot dsy0; / y-coordinate / struct sx_pk_slot h; / scalar / struct sx_pk_slot r; / scalar / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_SM9_SIGNATUREVERIFY */ struct sx_pk_inops_sm9_signatureverify { struct sx_pk_slot h1; / scalar / struct sx_pk_slot p2x0; / x-coordinate / struct sx_pk_slot p2x1; / x-coordinate / struct sx_pk_slot p2y0; / y-coordinate / struct sx_pk_slot p2y1; / y-coordinate / struct sx_pk_slot ppubsx0; / x-coordinate 0 / struct sx_pk_slot ppubsx1; / x-coordinate 1 / struct sx_pk_slot ppubsy0; / y-coordinate 0 / struct sx_pk_slot ppubsy1; / y-coordinate 1 / struct sx_pk_slot sx0; / x-coordinate / struct sx_pk_slot sy0; / y-coordinate / struct sx_pk_slot h; / scalar / struct sx_pk_slot f; / frobenius constant / struct sx_pk_slot t; / polynomial base / struct sx_pk_slot g ; / input / }; ",
							" Input slots for ::SX_PK_CMD_SM9_PRIVENCRKEYGEN */ struct sx_pk_inops_sm9_privencrkeygen { struct sx_pk_slot p2x0; / x-coordinate 0 / struct sx_pk_slot p2x1; / x-coordinate 1 / struct sx_pk_slot p2y0; / y-coordinate 0 / struct sx_pk_slot p2y1; / y-coordinate 1 / struct sx_pk_slot h; / scalar / struct sx_pk_slot ks; / scalar / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_SM9_SENDKEY */ struct sx_pk_inops_sm9_sendkey { struct sx_pk_slot p1x0; / x-coordinate / struct sx_pk_slot p1y0; / y-coordinate / struct sx_pk_slot ppubex0; / x-coordinate / struct sx_pk_slot ppubey0; / y-coordinate / struct sx_pk_slot h; / scalar / struct sx_pk_slot r; / scalar / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_SM9_REDUCEH */ struct sx_pk_inops_sm9_reduceh { struct sx_pk_slot h; / scalar / struct sx_pk_slot t; / polynomial base / }; ",
							" Input slots for ::SX_PK_CMD_ECJPAKE_GENERATE_ZKP */ struct sx_pk_inops_ecjpake_generate_zkp { struct sx_pk_slot v; / Random input / struct sx_pk_slot x; / Exponent / struct sx_pk_slot h; / Hash digest / }; ",
							" Input slots for ::SX_PK_CMD_ECJPAKE_VERIFY_ZKP */ struct sx_pk_inops_ecjpake_verify_zkp { struct sx_pk_slot xv; / Point V on the curve x-coordinate / struct sx_pk_slot yv; / Point V on the curve y-coordinate / struct sx_pk_slot xx; / Point X on the curve x-coordinate / struct sx_pk_slot yx; / Point X on the curve y-coordinate / struct sx_pk_slot r; / Proof / struct sx_pk_slot h; / Hash digest / struct sx_pk_slot xg2; / Point G on the curve x-coordinate / struct sx_pk_slot yg2; / Point G on the curve y-coordinate / }; ",
							" Input slots for ::SX_PK_CMD_ECJPAKE_3PT_ADD */ struct sx_pk_inops_ecjpake_3pt_add { struct sx_pk_slot x2_1; / Point X2 on the curve x-coordinate / struct sx_pk_slot x2_2; / Point X2 on the curve y-coordinate / struct sx_pk_slot x3_1; / Point X3 on the curve x-coordinate / struct sx_pk_slot x3_2; / Point X3 on the curve y-coordinate / struct sx_pk_slot x1_1; / Point X1 on the curve x-coordinate / struct sx_pk_slot x1_2; / Point X1 on the curve y-coordinate / }; ",
							" Input slots for ::SX_PK_CMD_ECJPAKE_GEN_STEP_2 */ struct sx_pk_inops_ecjpake_gen_step_2 { struct sx_pk_slot x4_1; / Point X4 on the curve x-coordinate / struct sx_pk_slot x4_2; / Point X4 on the curve y-coordinate / struct sx_pk_slot x3_1; / Point X3 on the curve x-coordinate / struct sx_pk_slot x3_2; / Point X3 on the curve y-coordinate / struct sx_pk_slot x2s; / Random value Password / struct sx_pk_slot x1_1; / Point X1 on the curve x-coordinate / struct sx_pk_slot x1_2; / Point X1 on the curve y-coordinate / struct sx_pk_slot s; / Password / }; ",
							" Input slots for ::SX_PK_CMD_ECJPAKE_GEN_SESS_KEY */ struct sx_pk_inops_ecjpake_gen_sess_key { struct sx_pk_slot x4_1; / Point X4 on the curve x-coordinate / struct sx_pk_slot x4_2; / Point X4 on the curve y-coordinate / struct sx_pk_slot b_1; / Point B on the curve x-coordinate / struct sx_pk_slot b_2; / Point B on the curve y-coordinate / struct sx_pk_slot x2; / Random value / struct sx_pk_slot x2s; / Random value Password / }; ",
							" Inputs slots for ::SX_PK_CMD_SRP_SERVER_PUBLIC_KEY_GEN */ struct sx_pk_inops_srp_server_public_key_gen { struct sx_pk_slot n; / Safe prime / struct sx_pk_slot g; / Generator / struct sx_pk_slot k; / Hash digest / struct sx_pk_slot v; / Exponentiated hash digest / struct sx_pk_slot b; / Random / }; ",
							" Inputs slots for ::SX_PK_CMD_SRP_SERVER_SESSION_KEY_GEN */ struct sx_pk_inops_srp_server_session_key_gen { struct sx_pk_slot n; / Safe prime / struct sx_pk_slot a; / Random / struct sx_pk_slot u; / Hash digest / struct sx_pk_slot v; / Exponentiated hash digest / struct sx_pk_slot b; / Random / }; ",
							" Inputs slots for ::SX_PK_CMD_CHECK_PARAM_AB */ struct sx_pk_inops_check_param_ab { struct sx_pk_slot p; / p parameter of curve / struct sx_pk_slot a; / a parameter of curve / struct sx_pk_slot b; / b parameter of curve / }; ",
							" Inputs slots for ::SX_PK_CMD_CHECK_PARAM_N */ struct sx_pk_inops_check_param_n { struct sx_pk_slot p; / p parameter of curve / struct sx_pk_slot n; / n parameter of curve / }; struct sx_pk_inops_check_xy { struct sx_pk_slot p; / p parameter of curve / struct sx_pk_slot x; / x-coordinate / struct sx_pk_slot y; / y-coordinate / }; ",
							" INTERNAL_HEADER_FILE_PK Macro ",
							" C #define INTERNAL_HEADER_FILE_PK ",
							" Memory operation functions @file ",
							" IOMEM_HEADER_FILE Macro ",
							" C #define IOMEM_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Clear device memory ",
							" Parameters dst Memory to clear Will be zeroed after this call ",
							" Parameters sz Number of bytes to clear void ioclrmem(void dst size_t sz); ",
							" Write src to device memory at dst The write to device memory will always use write instructions at naturally aligned addresses ",
							" Parameters dst Destination of write operation Will be modified after this call ",
							" Parameters src Source of write operation ",
							" Parameters sz The number of bytes to write from src to dst void iowrmem(void dst const void src size_t sz); The read from device memory will always use read instructions at naturally aligned addresses ",
							" Parameters dst Destination of read operation Will be modified after this call ",
							" Parameters src Source of read operation ",
							" Parameters sz The number of bytes to read from src to dst void iordmem(void dst const void src size_t sz); ",
							" Simpler functions for base Montgomery elliptic curve operations @file ",
							" MONTGOMERY_HEADER_FILE Macro ",
							" C #define MONTGOMERY_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Size in bytes of a point on X25519 curve */ ",
							" Size in bytes of a point on X448 curve */ ",
							" SX_X448_PT_SZ Macro ",
							" C #define SX_X448_PT_SZ 56 @addtogroup SX_PK_MONT @{ ",
							" An X25519 point */ struct sx_x25519_pt { ",
							" Bytes array representation of a X25519 point **/ char bytes ; }; ",
							" An X448 point */ struct sx_x448_pt { ",
							" Bytes array representation of a X448 point **/ char bytes ; }; ",
							" Montgomery point multiplication (X25519) ",
							" SX_X25519_PTMULT Macro ",
							" C typedef int (FUNC_SX_X25519_PTMULT)(struct sx_pk_cnx cnx const struct sx_x25519_pt k const struct sx_x25519_pt pt struct sx_x25519_pt r); #define SX_X25519_PTMULT ((FUNC_SX_X25519_PTMULT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_X25519_PTMULT))) Compute r = pt k The operands must be decoded and clamped as defined in specifications for X25519 and X448 ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Scalar ",
							" Parameters pt Point on the X25519 curve ",
							" Parameters r Multiplication result of k and pt @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see SX_ASYNC_X25519_PTMULT_GO() and SX_ASYNC_X25519_PTMULT_END() for an asynchronous version ",
							" Asynchronous Montgomery point multiplication (X25519) ",
							" SX_ASYNC_X25519_PTMULT_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_ASYNC_X25519_PTMULT_GO)(struct sx_pk_cnx cnx const struct sx_x25519_pt k const struct sx_x25519_pt pt); #define SX_ASYNC_X25519_PTMULT_GO ((FUNC_SX_ASYNC_X25519_PTMULT_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_X25519_PTMULT_GO))) Start a montgomery point multiplication on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_ASYNC_X25519_PTMULT_END() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Scalar ",
							" Parameters pt Point on the X25519 curve @return Acquired acceleration request for this operation @see SX_ASYNC_X25519_PTMULT_END() and SX_X25519_PTMULT() ",
							" Collect the result of asynchronous Montgomery point multiplication (X25519) ",
							" SX_ASYNC_X25519_PTMULT_END Macro ",
							" C typedef void (FUNC_SX_ASYNC_X25519_PTMULT_END)(sx_pk_accel req struct sx_x25519_pt r); #define SX_ASYNC_X25519_PTMULT_END ((FUNC_SX_ASYNC_X25519_PTMULT_END)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_X25519_PTMULT_END))) Get the output operand of the Montgomery point multiplication and release accelerator @remark The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters r Multiplication result of k and pt @see SX_ASYNC_X25519_PTMULT_GO() and sx_async_x25519_ptmult() ",
							" Montgomery point multiplication (X448) ",
							" SX_X448_PTMULT Macro ",
							" C typedef int (FUNC_SX_X448_PTMULT)(struct sx_pk_cnx cnx const struct sx_x448_pt k const struct sx_x448_pt pt struct sx_x448_pt r); #define SX_X448_PTMULT ((FUNC_SX_X448_PTMULT)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_X448_PTMULT))) Compute r = pt k The operands must be decoded and clamped as defined in specifications for X25519 and X448 ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Scalar ",
							" Parameters pt Point on the X448 curve ",
							" Parameters r Multiplication result of k and pt @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see SX_ASYNC_X448_PTMULT_GO() and SX_ASYNC_X448_PTMULT_END() for an asynchronous version ",
							" Asynchronous Montgomery point multiplication (X448) ",
							" SX_ASYNC_X448_PTMULT_GO Macro ",
							" C typedef struct sx_pk_dreq (FUNC_SX_ASYNC_X448_PTMULT_GO)(struct sx_pk_cnx cnx const struct sx_x448_pt k const struct sx_x448_pt pt); #define SX_ASYNC_X448_PTMULT_GO ((FUNC_SX_ASYNC_X448_PTMULT_GO)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_X448_PTMULT_GO))) Start a montgomery point multiplication on the accelerator and return immediately @remark When the operation finishes on the accelerator call SX_ASYNC_X448_PTMULT_END() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters k Scalar ",
							" Parameters pt Point on the X448 curve @return Acquired acceleration request for this operation @see SX_ASYNC_X448_PTMULT_END() and SX_X448_PTMULT() ",
							" Collect the result of asynchronous Montgomery point multiplication (X448) ",
							" SX_ASYNC_X448_PTMULT_END Macro ",
							" C typedef void (FUNC_SX_ASYNC_X448_PTMULT_END)(sx_pk_accel req struct sx_x448_pt r); #define SX_ASYNC_X448_PTMULT_END ((FUNC_SX_ASYNC_X448_PTMULT_END)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_ASYNC_X448_PTMULT_END))) Get the output operand of the Montgomery point multiplication and release the reserved resources @remark The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters r Multiplication result of k and pt @see SX_ASYNC_X448_PTMULT_GO() and sx_async_x448_ptmult() } ",
							" \"sxops\" interface for RSA and GF(p) cryptographic computations Simpler functions to perform public key crypto operations Included directly in some interfaces (like sxbuf or OpenSSL engine) The functions take input operands (large integers) and output operands which will get the computed results Operands have the \"sx_op\" type The specific interfaces (like sxbuf) define the \"sx_op\" type @file ",
							" RSA_HEADER_FILE Macro ",
							" C #define RSA_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Make sure the application is compatible with SilexPK API version **/ SX_PK_API_ASSERT_COMPATIBLE(1 0); struct sx_pk_cmd_def; ",
							" inline Function ",
							" C static inline @addtogroup SX_PK_SXOPS_MOD @{ ",
							" Asynchronous (non-blocking) Primitive modular operation with 1 operand Start a primitive modular operation with 1 operand on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_finish_single() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters cmd Command definition Should be a primitive modular operation with 1 operands For example: ::SX_PK_CMD_ODD_MOD_INV ::SX_PK_CMD_ODD_MOD_REDUCE ::SX_PK_CMD_EVEN_MOD_INV ::SX_PK_CMD_EVEN_MOD_REDUCE ",
							" Parameters modulo Modulus operand Must be odd if using ::SX_PK_CMD_ODD_MOD_INV or ::SX_PK_CMD_ODD_MOD_REDUCE command and even when using ::SX_PK_CMD_EVEN_MOD_INV or ::SX_PK_CMD_EVEN_MOD_REDUCE command ",
							" Parameters b Operand of modular operation @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_mod_single_op_cmd_go( struct sx_pk_cnx cnx const struct sx_pk_cmd_def cmd const sx_op modulo const sx_op b) { struct sx_pk_dreq pkreq; struct sx_pk_inops_mod_single_op_cmd inputs; pkreq = SX_PK_ACQUIRE_REQ(cnx cmd); if (pkreq status) return pkreq; // convert and transfer operands int sizes = { SX_OP_SIZE(modulo) SX_OP_SIZE(b) }; pkreq status = SX_PK_LIST_GFP_INSLOTS(pkreq req sizes (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; SX_PK_OP2VMEM(modulo inputs n addr); SX_PK_OP2VMEM(b inputs b addr); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Compute single operand modular operation Param Description  result = b mod modulo for ::SX_PK_CMD_ODD_MOD_REDUCE ::SX_PK_CMD_EVEN_MOD_REDUCE  result = 1 / b mod modulo for ::SX_PK_CMD_ODD_MOD_INV ::SX_PK_CMD_EVEN_MOD_INV ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters cmd Command definition Should be a primitive modular operation with 1 operand For example: ::SX_PK_CMD_ODD_MOD_REDUCE ::SX_PK_CMD_ODD_MOD_INV ::SX_PK_CMD_EVEN_MOD_REDUCE ::SX_PK_CMD_EVEN_MOD_INV ",
							" Parameters modulo Modulus operand Must be odd if using ::SX_PK_CMD_ODD_MOD_INV or ::SX_PK_CMD_ODD_MOD_REDUCE command and even when using ::SX_PK_CMD_EVEN_MOD_INV or ::SX_PK_CMD_EVEN_MOD_REDUCE command ",
							" Parameters b Operand ",
							" Parameters result Result operand @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @remark It is up to the user to use the corresponding command w r t the parity of the modulus @see sx_async_mod_single_op_cmd_go() and sx_async_finish_single() for an asynchronous version static inline int sx_mod_single_op_cmd( struct sx_pk_cnx cnx const struct sx_pk_cmd_def cmd const sx_op modulo const sx_op b sx_op result) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_mod_single_op_cmd_go(cnx cmd modulo b); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_finish_single(pkreq req result); return status; } ",
							" Asynchronous (non-blocking) Primitive modular operation with 2 operands Start a primitive modular operation with 2 operands on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_finish_single() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters cmd Command definition Should be a primitive modular operation with 2 operands For example: ::SX_PK_CMD_MOD_ADD ::SX_PK_CMD_MOD_SUB ::SX_PK_CMD_ODD_MOD_MULT ::SX_PK_CMD_ODD_MOD_DIV ",
							" Parameters modulo Modulus operand for the modular operantion ",
							" Parameters a First operand of modular operation ",
							" Parameters b Second operand of modular operation @return Acquired acceleration request for this operation @see sx_mod_primitive_cmd() for a synchronous version static inline struct sx_pk_dreq sx_async_mod_cmd_go( struct sx_pk_cnx cnx const struct sx_pk_cmd_def cmd const sx_op modulo const sx_op a const sx_op b) { struct sx_pk_dreq pkreq; struct sx_pk_inops_mod_cmd inputs; pkreq = SX_PK_ACQUIRE_REQ(cnx cmd); if (pkreq status) return pkreq; // convert and transfer operands int sizes = { SX_OP_SIZE(modulo) SX_OP_SIZE(a) SX_OP_SIZE(b) }; pkreq status = SX_PK_LIST_GFP_INSLOTS(pkreq req sizes (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; SX_PK_OP2VMEM(modulo inputs n addr); SX_PK_OP2VMEM(a inputs a addr); SX_PK_OP2VMEM(b inputs b addr); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Primitive modular operation with 2 operands Param Description  result = a + b mod modulo for ::SX_PK_CMD_MOD_ADD  result = a  result = a b mod modulo for ::SX_PK_CMD_ODD_MOD_MULT with odd modulus  result = a / b mod modulo for ::SX_PK_CMD_ODD_MOD_DIV with odd modulus Perform a modular addition or subtraction or odd modular multiplication or odd modular division ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters cmd Command definition Should be a primitive modular operation with 2 operands See description ",
							" Parameters modulo Modulus operand for the modular operantion ",
							" Parameters a First operand of modular operation ",
							" Parameters b Second operand of modular operation ",
							" Parameters result Result operand of the modular operation @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_mod_cmd_go() and sx_async_finish_single() for an asynchronous version static inline int sx_mod_primitive_cmd( struct sx_pk_cnx cnx const struct sx_pk_cmd_def cmd const sx_op modulo const sx_op a const sx_op b sx_op result) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_mod_cmd_go(cnx cmd modulo a b); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_finish_single(pkreq req result); return status; } ",
							" Asynchronous (non-blocking) mod inversion Start a modular inversion on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_finish_single() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters modulo Modulus operand ",
							" Parameters b Operand to inverse @return Acquired acceleration request for this operation @see sx_async_finish_single() sx_mod_inv() static inline struct sx_pk_dreq sx_async_mod_inv_go( struct sx_pk_cnx cnx const sx_op modulo const sx_op b) { return sx_async_mod_single_op_cmd_go(cnx SX_PK_CMD_ODD_MOD_INV modulo b); } ",
							" Compute modular inversion result = 1/b mod modulo ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters modulo Modulus operand ",
							" Parameters b Operand to inverse ",
							" Parameters result Result operand of the modular inversion @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_mod_inv_go() for an asynchronous verion static inline int sx_mod_inv( struct sx_pk_cnx cnx const sx_op modulo const sx_op b sx_op result) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_mod_inv_go(cnx modulo b); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_finish_single(pkreq req result); return status; } ",
							" Asynchronous (non-blocking) modular exponentiation Start a modular exponentiation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_mod_exp_end() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters input Base operand for modular exponentiation ",
							" Parameters exp Exponent operand ",
							" Parameters m Modulus operand @return Acquired acceleration request for this operation @see sx_mod_exp() for the synchronous version static inline struct sx_pk_dreq sx_async_mod_exp_go( struct sx_pk_cnx cnx const sx_op input const sx_op exp const sx_op m) { return sx_async_mod_cmd_go(cnx SX_PK_CMD_MOD_EXP m input exp); } ",
							" Finish asynchronous (non-blocking) modular exponentiation Get the output operand of the modular exponentiation and release the accelerator @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters result Result operand @see sx_async_mod_exp_go() and sx_mod_exp() static inline void sx_async_mod_exp_end( sx_pk_accel req sx_op result) { sx_async_finish_single(req result); } ",
							" Compute modular exponentiation result = input ^ exp mod m ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters input Base operand ",
							" Parameters exp Exponent operand ",
							" Parameters m Modulus operand ",
							" Parameters result Result operand @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_mod_exp_go() sx_async_mod_exp_end() for an asynchronous version static inline int sx_mod_exp( struct sx_pk_cnx cnx const sx_op input const sx_op exp const sx_op m sx_op result) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_mod_exp_go(cnx input exp m); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_mod_exp_end(pkreq req result); return status; } ",
							" @} */ ",
							" inline Function ",
							" C static inline @addtogroup SX_PK_SXOPS_RSA @{ ",
							" Asynchronous (non-blocking) modular exponentiation with CRT Start a modular exponentiation with CRT on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_crt_mod_exp_end() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters in Input ",
							" Parameters p Prime number p ",
							" Parameters q Prime number q ",
							" Parameters dp d mod (p-1) with d the private key ",
							" Parameters dq d mod (q-1) with d the private key ",
							" Parameters qinv q^(-1) mod p @return Acquired acceleration request for this operation @see sx_async_crt_mod_exp_end() static inline struct sx_pk_dreq sx_async_crt_mod_exp_go( struct sx_pk_cnx cnx const sx_op in const sx_op p const sx_op q const sx_op dp const sx_op dq const sx_op qinv) { struct sx_pk_dreq pkreq; struct sx_pk_inops_crt_mod_exp inputs; pkreq = SX_PK_ACQUIRE_REQ(cnx SX_PK_CMD_MOD_EXP_CRT); if (pkreq status) return pkreq; // convert and transfer operands int sizes = { SX_OP_SIZE(p) SX_OP_SIZE(q) SX_OP_SIZE(in) SX_OP_SIZE(dp) SX_OP_SIZE(dq) SX_OP_SIZE(qinv) }; pkreq status = SX_PK_LIST_GFP_INSLOTS(pkreq req sizes (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; SX_PK_OP2VMEM(in inputs in addr); SX_PK_OP2VMEM(p inputs p addr); SX_PK_OP2VMEM(q inputs q addr); SX_PK_OP2VMEM(dp inputs dp addr); SX_PK_OP2VMEM(dq inputs dq addr); SX_PK_OP2VMEM(qinv inputs qinv addr); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) modular exponentiation with CRT Get the output operand of the modular exponentiation with CRT and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters result @see sx_async_crt_mod_exp_go() static inline void sx_async_crt_mod_exp_end( sx_pk_accel req sx_op result) { sx_async_finish_single(req result); } ",
							" Compute modular exponentiation with CRT Compute (result = in db mod m) with those steps: vp = in dp mod p vq = in ^ dq mod q u = (vp -vq) qinv mod p result = vq + u q ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters in Input ",
							" Parameters p Prime number p ",
							" Parameters q Prime number q ",
							" Parameters dp d mod (p-1) with d the private key ",
							" Parameters dq d mod (q-1) with d the private key ",
							" Parameters qinv q^(-1) mod p ",
							" Parameters result Result of modular exponentiation with CRT @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_crt_mod_exp_go() sx_async_crt_mod_exp_end() for an asynchronous version static inline int sx_crt_mod_exp( struct sx_pk_cnx cnx const sx_op in const sx_op p const sx_op q const sx_op dp const sx_op dq const sx_op qinv sx_op result) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_crt_mod_exp_go(cnx in p q dp dq qinv); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_crt_mod_exp_end(pkreq req result); return status; } ",
							" Asynchronous (non-blocking) RSA private key generation Start an RSA private key generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_rsa_keygen_end() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime value p ",
							" Parameters q Prime value q ",
							" Parameters public_expo Public exponent operand @return Acquired acceleration request for this operation static inline struct sx_pk_dreq sx_async_rsa_keygen_go(struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op public_expo) { struct sx_pk_dreq pkreq; struct sx_pk_inops_rsa_keygen inputs; pkreq = SX_PK_ACQUIRE_REQ(cnx SX_PK_CMD_RSA_KEYGEN); if (pkreq status) return pkreq; // convert and transfer operands int sizes = { SX_OP_SIZE(p) SX_OP_SIZE(q) SX_OP_SIZE(public_expo) }; pkreq status = SX_PK_LIST_GFP_INSLOTS(pkreq req sizes (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; SX_PK_OP2VMEM(p inputs p addr); SX_PK_OP2VMEM(q inputs q addr); SX_PK_OP2VMEM(public_expo inputs e addr); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) RSA private key generation Get the output operands of the RSA private key generation and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters n Multiple of 2 primes p and q ",
							" Parameters lambda_n Least common multiple of p-1 and q-1 ",
							" Parameters privkey Private key static inline void sx_async_rsa_keygen_end(sx_pk_accel req sx_op n sx_op lambda_n sx_op privkey) { const char outputs = SX_PK_GET_OUTPUT_OPS(req); const int opsz = SX_PK_GET_OPSIZE(req); SX_PK_MEM2OP(outputs opsz n); SX_PK_MEM2OP(outputs opsz lambda_n); SX_PK_MEM2OP(outputs opsz privkey); SX_PK_RELEASE_REQ(req); } ",
							" Compute RSA private key and lambda_n from primes p and q The private key is generated with the following steps: 1 n = p q 2 lambda_n = lcm(p-1 q-1) 3 d = e^-1 % lambda_n Where d is the private key (privkey) ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime value p ",
							" Parameters q Prime value q ",
							" Parameters public_expo Public exponent operand ",
							" Parameters n Resulting n operand ",
							" Parameters lambda_n Resulting lambda_n operand ",
							" Parameters privkey Resulting rivate key operand @return ::SX_OK @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_rsa_keygen_go() sx_async_rsa_keygen_end() for an asynchronous version static inline int sx_rsa_keygen(struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op public_expo sx_op n sx_op lambda_n sx_op privkey) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_rsa_keygen_go(cnx p q public_expo); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_rsa_keygen_end(pkreq req n lambda_n privkey); return status; } ",
							" Asynchronous (non-blocking) RSA CRT private key parameters Start a RSA CRT private key generation on the accelerator and return immediately @remark When the operation finishes on the accelerator call sx_async_rsa_crt_keyparams_end() ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime operand p ",
							" Parameters q Prime operand q ",
							" Parameters privkey Private key @return Acquired acceleration request for this operation @see sx_async_rsa_crt_keyparams_end() and sx_async_rsa_crt_keyparams() static inline struct sx_pk_dreq sx_async_rsa_crt_keyparams_go( struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op privkey) { struct sx_pk_dreq pkreq; struct sx_pk_inops_rsa_crt_keyparams inputs; pkreq = SX_PK_ACQUIRE_REQ(cnx SX_PK_CMD_RSA_CRT_KEYPARAMS); if (pkreq status) return pkreq; // convert and transfer operands int sizes = { SX_OP_SIZE(p) SX_OP_SIZE(q) SX_OP_SIZE(privkey) }; pkreq status = SX_PK_LIST_GFP_INSLOTS(pkreq req sizes (struct sx_pk_slot ) inputs); if (pkreq status) return pkreq; SX_PK_OP2VMEM(p inputs p addr); SX_PK_OP2VMEM(q inputs q addr); SX_PK_OP2VMEM(privkey inputs privkey addr); SX_PK_RUN(pkreq req); return pkreq; } ",
							" Finish asynchronous (non-blocking) RSA CRT private key parameters Get the output operands of the RSA CRT private key parameters and release the reserved resources @pre The operation on the accelerator must be finished before calling this function ",
							" Parameters req The previously acquired acceleration request for this operation ",
							" Parameters Param Description dp d mod (p 1) ",
							" Parameters Param Description dq d mod (q 1) ",
							" Parameters qinv q ^ -1 mod p @see sx_async_rsa_crt_keyparams_go() and sx_rsa_crt_keyparams() static inline void sx_async_rsa_crt_keyparams_end(sx_pk_accel req sx_op dp sx_op dq sx_op qinv) { const char outputs = SX_PK_GET_OUTPUT_OPS(req); const int opsz = SX_PK_GET_OPSIZE(req); SX_PK_MEM2OP(outputs opsz dp); SX_PK_MEM2OP(outputs opsz dq); SX_PK_MEM2OP(outputs opsz qinv); SX_PK_RELEASE_REQ(req); } ",
							" Compute RSA CRT private key parameters Computes the following parameters: | Param | Description | |:----- |:----------- | | dp = d mod (p | 1) | | dq = d mod (q | 1) qinv = q ^ -1 mod p where d is the private key and the pair p and q are the secret primes used to create the RSA private key ",
							" Parameters cnx Connection structure obtained through SX_PK_OPEN() at startup ",
							" Parameters p Prime value p ",
							" Parameters q Prime value q ",
							" Parameters privkey Private key operand ",
							" Parameters Param Description dp d mod (p 1) ",
							" Parameters Param Description dq d mod (q 1) ",
							" Parameters qinv q ^ -1 mod p @return ::SX_OK @return ::SX_ERR_NOT_INVERTIBLE @return ::SX_ERR_OUT_OF_RANGE @return ::SX_ERR_INVALID_PARAM @return ::SX_ERR_UNKNOWN_ERROR @return ::SX_ERR_BUSY @return ::SX_ERR_NOT_IMPLEMENTED @return ::SX_ERR_OPERAND_TOO_LARGE @return ::SX_ERR_PLATFORM_ERROR @return ::SX_ERR_EXPIRED @see sx_async_rsa_crt_keyparams_go() sx_async_rsa_crt_keyparams_end() for an asynchronous version static inline int sx_rsa_crt_keyparams(struct sx_pk_cnx cnx const sx_op p const sx_op q const sx_op privkey sx_op dp sx_op dq sx_op qinv) { struct sx_pk_dreq pkreq; int status; pkreq = sx_async_rsa_crt_keyparams_go(cnx p q privkey); if (pkreq status) return pkreq status; status = SX_PK_WAIT(pkreq req); sx_async_rsa_crt_keyparams_end(pkreq req dp dq qinv); return status; } } ",
							" SilexPK status codes @file ",
							" SX_PK_STATUSCODES_HEADER_FILE Macro ",
							" C #define SX_PK_STATUSCODES_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" SX_ERR_IK_MODE Function ",
							" C #define SX_ERR_IK_MODE 16 @addtogroup SX_PK_STATUS @{ ",
							" The function or operation succeeded */ ",
							" The function or operation was given an invalid parameter */ ",
							" SX_ERR_INVALID_PARAM Macro ",
							" C #define SX_ERR_INVALID_PARAM 1 ",
							" Unknown error */ ",
							" The operation is still executing */ ",
							" SX_ERR_BUSY Macro ",
							" C #define SX_ERR_BUSY 3 ",
							" The input operand is not a quadratic residue */ ",
							" The input value for Rabin-Miller test is a composite value */ ",
							" SX_ERR_COMPOSITE_VALUE Macro ",
							" C #define SX_ERR_COMPOSITE_VALUE 5 ",
							" Inversion of non-invertible value */ ",
							" The signature is not valid ",
							" SX_ERR_INVALID_SIGNATURE Macro ",
							" C #define SX_ERR_INVALID_SIGNATURE 7 This error can happen during signature generation and signature verification ",
							" The functionality or operation is not supported */ ",
							" The output operand is a point at infinity */ ",
							" SX_ERR_POINT_AT_INFINITY Macro ",
							" C #define SX_ERR_POINT_AT_INFINITY 9 ",
							" The input value is outside the expected range */ ",
							" The modulus has an unexpected value ",
							" SX_ERR_INVALID_MODULUS Macro ",
							" C #define SX_ERR_INVALID_MODULUS 11 This error happens when the modulus is zero or even when odd modulus is expected ",
							" The input point is not on the defined elliptic curve */ ",
							" The input operand is too large */ ",
							" SX_ERR_OPERAND_TOO_LARGE Macro ",
							" C #define SX_ERR_OPERAND_TOO_LARGE 13 ",
							" A platform specific error */ ",
							" The evaluation period for the product expired */ ",
							" SX_ERR_EXPIRED Macro ",
							" C #define SX_ERR_EXPIRED 15 ",
							" The hardware is still in IK mode ",
							" SX_ERR_IK_MODE Macro ",
							" C #define SX_ERR_IK_MODE 16 This error happens when a normal operation is started and the hardware is still in IK mode Run command ::SX_PK_CMD_IK_EXIT to exit the IK mode and to run normal operations again ",
							" The parameters of the elliptic curve are not valid */ ",
							" Return a brief text string describing the given status code ",
							" char Typedef ",
							" C typedef const char (FUNC_SX_DESCRIBE_STATUSCODE)(int code); ",
							" SX_DESCRIBE_STATUSCODE Macro ",
							" C #define SX_DESCRIBE_STATUSCODE ((FUNC_SX_DESCRIBE_STATUSCODE)((uint32_t )(API_TABLE_BASE_ADDRESS + ATO_SX_DESCRIBE_STATUSCODE))) ",
							" Parameters code Value of status code @return Text string describing the status code ",
							" Basic \"sxops\" operand definition @file ",
							" ADAPTER_TYPES_HEADER Macro ",
							" C #define ADAPTER_TYPES_HEADER / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2018-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Basic operand representation **/ struct sx_buf { ",
							" Size in bytes of operand **/ size_t sz; ",
							" Memory of operand bytes in big endian **/ char bytes; }; ",
							" Simple \"sxops\" implementation based on sx_buf**/ ",
							" Semantic version numbers of the SilexPK API The version numbering used here adheres to the concepts outlined in https://semver org/ @file ",
							" SX_PK_VERSION_HEADER_FILE Macro ",
							" C #define SX_PK_VERSION_HEADER_FILE / Copyright (c) 2018-2020 Silex Insight sa Copyright (c) 2014-2020 Beerten Engineering scs SPDX-License-Identifier: BSD-3-Clause ",
							" Major version number of the SilexPK API ",
							" SX_PK_API_MAJOR Macro ",
							" C #define SX_PK_API_MAJOR 1 Changes made to the API with the same major version number remain backwards compatible Applications should check at compile time that current major version number matches the one they were made for ",
							" Minor version number of the SilexPK API ",
							" SX_PK_API_MINOR Macro ",
							" C #define SX_PK_API_MINOR 4 New features added while maintaining backwards compatibility increment the minor version number Applications should check that the minor version number is equal or larger than the minor version number they were written for ",
							" Check application has compatible version numbers ",
							" SX_PK_API_IS_COMPATIBLE(appmajor Macro ",
							" C #define SX_PK_API_IS_COMPATIBLE(appmajor appminor) Non-zero if the API is compatible and zero if incompatible The application is compatible if the major number does matches the library major number and the application minor number is equal or smaller than the library minor number ",
							" Assert that the application is compatible with the library ",
							" SX_PK_API_ASSERT_COMPATIBLE(appmajor Macro ",
							" C #define SX_PK_API_ASSERT_COMPATIBLE(appmajor appminor) If the application is not compatible this macro will cause a compile time error ",
							" PIC32CX-BZ3 Device Support Component Library Help The PIC32CX-BZ3 Device Support Component Library provides software API's for various subsystems in the PIC32CX-BZ3  These systems include:  RF System - Helps in initialization calibration and other activities for using RF Sub system  PMU System - Helps in setting various power modes available in the PMU System  Information Block - Helps in getting the factory default values of information like device/MAC address ADC value temperature etc  Sleep System - Helps to enter or exit the sleep modes supported by the system  Deep Sleep System - Helps configure and enter deep sleep modes supported by the system   Additionally device component includes the following two services as sources  OSAL(Operating System Abstraction Layer) Extension for FreeRTOS  Application Idle task service   ",
							" Device Support Library Usage  Configuring the library  There is no configuration for this library  Device Support Libraries groups classification   RF System  PMU System  Information Base  Sleep System  Deep Sleep System   Using the library - An Example  When the device is first powered on the system will be calibrated with its factory settings by calling:  SYS_Load_Cal();  Similarly other API’s can be used Refer API information for more details on its description and usage  ",
							" RF System RF System helps in initialization calibration and other activities for using RF Sub system  The major routines of RF System   Configuring RF system clock that will be fed into the MCU clock  Loading system calibration values for RF system  Helps to check whether the RF needs to be calibrated or not  RF Calibration based on timer event  Reading current temperature ADC value   ",
							" wssEnable_t Enum ",
							" C typedef enum { WSS_ENABLE_NONE WSS_ENABLE_BLE WSS_ENABLE_ZB WSS_ENABLE_BLE_ZB }wssEnable_t; ",
							" SYS_ClkGen_Config Function ",
							" C void SYS_ClkGen_Config(void); ",
							" Description This routine will configure the RF system clock that feeds the MCU ",
							" Parameters None ",
							" Returns None ",
							" SYS_Load_Cal Function ",
							" C void SYS_Load_Cal(wssEnable_t wssEnable); ",
							" Description This routine will load the System calibration values for the RF and PMU subsystems The main functions are RF initialization BLE Modem initialization load Calibration data from IB VCO coarse tune (ACLB) and Initialize Arbiter ",
							" Parameters wssEnable_t wssEnable wireless subsystem enable flag 0: None 1: BLE enable 2: ZB enable 3: BLE enable ZB enable ",
							" Returns None ",
							" RF_NeedCal Function ",
							" C bool RF_NeedCal(void); ",
							" Description This routine will decide if RF need to be calibrated current method is a default 60 sec timer to trigger calibration ",
							" Parameters None ",
							" Returns A boolean value: True means RF need to be calibrated False means RF doesn't need to be calibrated ",
							" RF_Timer_Cal Function ",
							" C void RF_Timer_Cal(wssEnable_t wssEnable); ",
							" Description This routine will calibrate the RF from a Timer event condition The main functions are TX_Power_Compensation and RSSI_ED_Compensation which are compensation over temperature Since temperature may change over time user can choose do RF_Timer_Cal over time ",
							" Parameters wssEnable_t wssEnable wireless subsystem enable flag 0: None 1: BLE enable 2: ZB enable 3: BLE enable ZB enable ",
							" Returns None ",
							" RF_SetIdleMode Function ",
							" C void RF_SetIdleMode(void); ",
							" Description This routine will the RF subsystem as idle mode ",
							" Parameters None ",
							" Returns None ",
							" Temperature_Reading Function ",
							" C float Temperature_Reading(void); ",
							" Description This routine will read current temperature ADC value The functionality is provided by RF IP ",
							" Parameters None ",
							" Returns float The ADC value of current temperature ",
							" PMU System The PMU (Power Management Unit) subsystem helps in setting various power modes available in the system  Power Management Unit Subsystem is a complex power controller that requires specific configuration and handling by the software for correct safe operation of the SOC The software routines help in handles the startup and operation of the PMU  ",
							" PMU_Mode_T Enum ",
							" C typedef enum { // Linear mode - This is the default mode when CPU and peripherals are running PMU_MODE_MLDO = 1 // Buck (DC-DC/switching) mode; supports High Power (PWM) - The most efficient mode //when the CPU and peripherals are running In this mode the SoC is powered by the DC-DC converter PMU_MODE_BUCK_PWM // 2 // Buck (DC-DC/switching) mode; supports Low Power (PSK) mode PMU_MODE_BUCK_PSM // 3 } PMU_Mode_T; ",
							" PMU_Get_Mode Function ",
							" C PMU_Mode_T PMU_Get_Mode(void); ",
							" Description This routine will get the power mode of the system ",
							" Parameters None ",
							" Returns PMU_Mode_T - PMU_MODE_MLDO // 1 PMU_MODE_BUCK_PWM // 2 PMU_MODE_BUCK_PSM // 3 ",
							" PMU_Set_Mode Function ",
							" C uint8_t PMU_Set_Mode(PMU_Mode_T mode); ",
							" Description This routine will set the power mode of the system ",
							" Parameters Param Description PMU_Mode_T PMU_MODE_MLDO // 1 PMU_MODE_BUCK_PWM // 2 PMU_MODE_BUCK_PSM // 3 ",
							" Returns uint8_t 0 is success 1 is fail which means no BDADDR IB ",
							" PMU_ConfigCurrentSensor Function ",
							" C bool PMU_ConfigCurrentSensor(bool enable); ",
							" Description This routine will configure the BUCK current sensor It only can be configured when the power mode is set as PMU_MODE_BUCK_PSM Disable current sensor can improve the current consumption of sleep mode ",
							" Parameters bool Enable/Disable BUCK current sensor false: Disable true : Enable ",
							" Returns bool - true is success false is fail due to power mode is not in PMU_MODE_BUCK_PSM ",
							" Info Block Information block helps in getting factory set values from the information base  Information block helps in  loading all settings from the Info Block into the appropriate sub-systems for proper chip operation  getting the Bluetooth Device Address  getting the Zigbee MAC Address  getting factory temperature ADC value  getting Battery voltage 3 0 V ADC value  getting Battery voltage 2 2 V ADC value  getting RSSI compensation offset value  getting antenna gain value   ",
							" IB_GetAdcTiming Function ",
							" C bool IB_GetAdcTiming(uint8_t * p_adcTiming08 uint8_t * p_adcTiming51); ",
							" Description This routine will get ADC timing value from IB The value can be used to set ADC timing this should be the setting for 64Mhz ADC clock ",
							" Parameters Param Description uint8_t p_adcTiming08 the memory to store ADC timing register 08 value ",
							" Parameters Param Description uint8_t p_adcTiming51 the memory to store ADC timing register 51 value ",
							" Returns A boolean value True means vaild ADC timing value in IB ",
							" IB_GetBdAddr Function ",
							" C bool IB_GetBdAddr(uint8_t * p_bdAddr); ",
							" Description This routine will get Bluetooth Device Address from IB If there exists BDADDR IB then it will return the BDADDR stored in IB Otherwise it returns FAILS (1) ",
							" Parameters Param Description uint8_t \"p_Addr\" the pointer to the memory stores BDADDR ",
							" Returns A boolean value True means valid BDADDR IB ",
							" IB_GetMACAddr Function ",
							" C bool IB_GetMACAddr(uint8_t * p_addr); ",
							" Description This routine will get ZB MAC Address from IB If there exists MAC_ADDR IB then it will return the MAC_ADDR stored in IB Otherwise it returns FAILS (1)) ",
							" Parameters Param Description uint8_t \"p_Addr\" the pointer to the memory stores MAC_ADDR ",
							" Returns A boolean value True means valid ZB MAC Address IB ",
							" IB_GetAntennaGain Function ",
							" C bool IB_GetAntennaGain(int8_t * p_antennaGain); ",
							" Description This routine will get antenna gain value from IB The value can be used to calculate radiative power radiative power = conductive power + antenna gain ",
							" Parameters Param Description int8_t p_antennaGain the memory to store antenna gain value ",
							" Returns A boolean value True means vaild antenna gain IB ",
							" IB_GetBatVoltage2v2Sar Function ",
							" C bool IB_GetBatVoltage2v2Sar(int16_t * p_batVoltageSar); ",
							" Description This routine will get Battery voltage 2 2 V ADC value from IB The value can be used for Battery voltage slope and detect battery voltage ",
							" Parameters IB_BatteryCalSar_T p_batVoltageSar - the pointer to the memory stores Battery voltage ADC value ",
							" Returns A boolean value True means valid Battery voltage ADC IB ",
							" IB_GetBatVoltage3v0Sar Function ",
							" C bool IB_GetBatVoltage3v0Sar(int16_t * p_batVoltageSar); ",
							" Description This routine will get Battery voltage 3 0 V ADC value from IB The value can be used for Battery voltage slope and detect battery voltage ",
							" Parameters IB_BatteryCalSar_T p_batVoltageSar - the pointer to the memory stores Battery voltage ADC value ",
							" Returns A boolean value True means valid Battery voltage ADC IB ",
							" IB_GetRssiOffset Function ",
							" C bool IB_GetRssiOffset(int8_t * p_rssiOffset); ",
							" Description This routine will get RSSI compensation offset value from IB The value can be used to compensation RSSI detection ",
							" Parameters Param Description int8_t p_rssiOffset the memory to store RSSI compensation offset value ",
							" Returns A boolean value True means vaild RSSI compensation offset IB ",
							" Deep Sleep System Enter a short description of your topic here (optional)  These API’s allow the system to be configured and placed into its Deep Sleep state  ",
							" DEVICE_ClearDeepSleepReg Function ",
							" C bool DEVICE_ClearDeepSleepReg(void); ",
							" Description The API is used to clear the deep sleep related register If the device is waken from deep sleep mode the related register will be cleared If it's a normal Power-on Reset no register will be cleared ",
							" Parameters None ",
							" Returns A boolean value True means the device is waken from deep sleep mode ",
							" DEVICE_DeepSleepIntervalCal Function ",
							" C uint32_t DEVICE_DeepSleepIntervalCal(uint32_t expectedInt); ",
							" Description The API is used to perform the deep sleep interval calibration to exclude the HW preparation time of advertising ",
							" Parameters Param Description expectedInt The expected deep sleep interval ",
							" Returns The deep sleep interval after calibration ",
							" DEVICE_EnterDeepSleep Function ",
							" C void DEVICE_EnterDeepSleep(bool enableRetRam uint32_t interval); ",
							" Description The API is used to enter deep sleep mode ",
							" Parameters Param Description enableRetRam Enable/Disable retention ram ",
							" Parameters Param Description interval The interval of deep sleep mode (unit: ms) Set as 0 will keep the device in the deep sleep mode until the INT0 (PB9) is triggered ",
							" Parameters None ",
							" Returns None ",
							" DEVICE_EnterExtremeDeepSleep Function ",
							" C void DEVICE_EnterExtremeDeepSleep(bool enableInt0); ",
							" Description The API is used to enter extreme deep sleep mode ",
							" Parameters Param Description enableInt0 Enable/Disable if the device can be woken from extreme deep sleep mode by INT0 ",
							" Parameters None ",
							" Returns None ",
							" DEVICE_GetDeepSleepWakeUpSrc Function ",
							" C void DEVICE_GetDeepSleepWakeUpSrc(DEVICE_DeepSleepWakeSrc_T *wakeUpSrc); ",
							" Description The API is used to get the wake up source of deep sleep mode ",
							" Parameters Param Description wakeUpSrc Pointer to the wake up source See @ref DEVICE_DeepSleepWakeSrc_T ",
							" Returns None ",
							" DEVICE_SetDeepSleepWakeUpSrc Function ",
							" C void DEVICE_SetDeepSleepWakeUpSrc(DEVICE_DeepSleepWakeSrc_T wakeUpSrc); ",
							" Description The API is used to set the wake up source of deep sleep mode ",
							" Parameters Param Description wakeUpSrc Tthe wake up source See @ref DEVICE_DeepSleepWakeSrc_T ",
							" Returns None ",
							" OSAL Extension for FreeRTOS  OSAL (Operating System Abstraction Layer) Extension for FreeRTOS provide extension for OSAL mappings for the FreeRTOS Real-time operating system The following table defines OSAL routines        Fuction Name  Short Description      OSAL_QUEUE_Create  Creates a new queue instance    OSAL_QUEUE_CreateSet  Creates a new queue set instance    OSAL_QUEUE_AddToSet  Adds the queues and semaphores to the set    OSAL_QUEUE_SelectFromSet  Block to wait for something to be available from the queues or semaphore that have been added to the set    OSAL_QUEUE_Send  Post an item into an OSAL Queue    OSAL_QUEUE_SendISR  Post an item into an OSAL Queue from ISR    OSAL_QUEUE_Receive  Receive an item from an OSAL Queue    OSAL_QUEUE_IsFullISR  Query if an OSAL Queue is full       ",
							" OSAL_QUEUE_Create Function ",
							" C OSAL_RESULT OSAL_QUEUE_Create(OSAL_QUEUE_HANDLE_TYPE *queID uint32_t queueLength uint32_t itemSize); ",
							" Description Creates a new queue instance and returns a handle by which the new queue can be referenced ",
							" Parameters Param Description queID A pointer to the queue ID queueLength The maximum number of items that the queue can contain itemSize The number of bytes each item in the queue will require Items are queued by copy not by reference so this is the number of bytes that will be copied for each posted item Each item in the queue must be the same size ",
							" Returns OSAL_RESULT_TRUE - A queue had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_CreateSet Function ",
							" C OSAL_RESULT OSAL_QUEUE_CreateSet(OSAL_QUEUE_SET_HANDLE_TYPE *queID uint32_t queueLength); ",
							" Description Creates a new queue set instance and returns a handle by which the new queue can be referenced ",
							" Parameters Param Description queID A pointer to the queue ID queueLength The maximum number of items that the queue can contain ",
							" Returns OSAL_RESULT_TRUE - A queue set had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_AddToSet Function ",
							" C OSAL_RESULT OSAL_QUEUE_AddToSet(OSAL_QUEUE_SET_MEMBER_HANDLE_TYPE *queSetMember OSAL_QUEUE_SET_HANDLE_TYPE *queSetID); ",
							" Description Add the queues and semaphores to the set Reading from these queues and semaphore can only be performed after a call to xQueueSelectFromSet() has returned the queue or semaphore handle from this point on ",
							" Parameters Param Description queSetMember Member queue or semaphore to be added in the set queSetID A pointer to the queue ID ",
							" Returns OSAL_RESULT_TRUE - A queue had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_SelectFromSet Function ",
							" C OSAL_RESULT OSAL_QUEUE_SelectFromSet(OSAL_QUEUE_SET_MEMBER_HANDLE_TYPE *queSetMember OSAL_QUEUE_SET_HANDLE_TYPE *queSetID uint32_t waitMS); ",
							" Description Block to wait for something to be available from the queues or semaphore that have been added to the set ",
							" Parameters Param Description queSetMember Member queue or semaphore to be added in the set queSetID A pointer to the queue ID waitMS wait time in milliseconds other value OSAL_WAIT_FOREVER ",
							" Returns OSAL_RESULT_TRUE - A queue had been created OSAL_RESULT_FALSE - Queue creation failed ",
							" OSAL_QUEUE_Send Function ",
							" C OSAL_RESULT OSAL_QUEUE_Send(OSAL_QUEUE_HANDLE_TYPE *queID void *itemToQueue uint32_t waitMS); ",
							" Description Post an item into an OSAL Queue The item is queued by copy not by reference This function must not be called from an interrupt service routine See OSAL_QUEUE_SendISR() for an alternative which may be used in an ISR ",
							" Parameters Param Description queID A pointer to the queue ID itemToQueue A pointer to the item that is to be placed on the queue The size of the items the queue will hold was defined when the queue was created so this many bytes will be copied from itemToQueue into the queue storage area waitMS Time limit to wait in milliseconds 0 do not wait OSAL_WAIT_FOREVER return only when semaphore is obtained Other values timeout delay ",
							" Returns OSAL_RESULT_TRUE - Item copied to the queue OSAL_RESULT_FALSE - Item not copied to the queue or timeout occurred ",
							" OSAL_QUEUE_SendISR Function ",
							" C OSAL_RESULT OSAL_QUEUE_SendISR(OSAL_QUEUE_HANDLE_TYPE *queID void *itemToQueue); ",
							" Description Post an item into an OSAL Queue The item is queued by copy not by reference The highest priority task currently blocked on the queue will be released and made ready to run This form of the send function should be used witin an ISR ",
							" Parameters Param Description queID A pointer to the queue ID itemToQueue A pointer to the item that is to be placed on the queue The size of the items the queue will hold was defined when the queue was created so this many bytes will be copied from itemToQueue into the queue storage area waitMS Time limit to wait in milliseconds 0 do not wait OSAL_WAIT_FOREVER return only when semaphore is obtained Other values timeout delay ",
							" Returns OSAL_RESULT_TRUE - Item copied to the queue OSAL_RESULT_FALSE - Item not copied to the queue or timeout occurred ",
							" OSAL_QUEUE_Receive Function ",
							" C OSAL_RESULT OSAL_QUEUE_Receive(OSAL_QUEUE_HANDLE_TYPE *queID void *pBuffer uint32_t waitMS); ",
							" Description Receive an item from an OSAL Queue The item is received by copy so a buffer of adequate size must be provided The number of bytes copied into the buffer was defined when the queue was created Successfully received items are removed from the queue This function must not be used in an interrupt service routine ",
							" Parameters Param Description queID A pointer to the queue ID buffer A pointer to the buffer into which the received item will be copied The size of the items the queue hold was defined when the queue was created so this many bytes will be copied from the queue storage area into the buffer waitMS Time limit to wait in milliseconds 0 do not wait OSAL_WAIT_FOREVER return only when semaphore is obtained Other values timeout delay ",
							" Returns OSAL_RESULT_TRUE - An item was successfully received from the queue OSAL_RESULT_FALSE - An item was not successfully received from the queue or timeout occurred ",
							" OSAL_QUEUE_IsFullISR Function ",
							" C OSAL_RESULT OSAL_QUEUE_IsFullISR(OSAL_QUEUE_HANDLE_TYPE *queID); ",
							" Description Query if an OSAL Queue is full These function should be used only from witin an ISR or within a critical section ",
							" Parameters Param Description queID A pointer to the queue ID ",
							" Returns OSAL_RESULT_TRUE - The queue is Full OSAL_RESULT_FALSE - The queue is not Full ",
							" App Idle Task  App Idle task service provides idle task routines which will be called from FreeRTOS Idle hook function It executes the idle activities The following activities may be carried out  RF Calibration if RF needs calibration  Storing of PDS Items by calling PDS Store Item Handler  Checking whether the Zigbee stack is ready to sleep  Requesting BLE to enter sleep mode     ",
							" app_idle_task Function ",
							" C void app_idle_task( void ); ",
							" Description This function performs the activities like PDS store Sleep and other RF system idle activities which can be performed when the complete system is idle ",
							" Parameters None ",
							" Returns None ",
							" app_idle_updateRtcCnt Function ",
							" C void app_idle_updateRtcCnt(uint32_t cnt); ",
							" Description RTC based tickless idle mode Hook function records RTC counter value in each tick interrupt to ensure the real time RTC counter value be recorded during system is active Then RTC tickless idle mode can use this value to calculate how much time passed during system sleep ",
							" Parameters Param Description cnt RTC counter value ",
							" Returns None ",
							" PIC32CX-BZ3 Persistent Data Server Component Library Help The PIC32CX-BZ3 Persistent Data Server Component Library provides interface for storing and restoring items into the Non volatile memory using wear leveling mechanism  PERSISTENT DATA SERVER (PDS)  The Persistent Data Server (PDS) component implements interfaces and functionality for storing and restoring data in a non-volatile (NV) memory storage  In PDS particular pieces of persistent data are called files and groups of parameters are called directories Following section describes how to define such persistent items and overview of PDS API functions that can be used to store and restore them  User can specify parameters he(she) wants to backup in a non-volatile memory and restore in case of power failure This service is provided by Persistent Data Server (PDS) module The BitCloud (TM) stack also uses the same service for its internal structures  The main feature behind the wear leveling PDS is the mechanism designed to extend the lifetime of the NV storage as well as to protect data from being lost when a reset occurs during writing to the NV This mechanism is based on writing data evenly through the dedicated area so that the storage’s lifetime in not limited by the number of reading and writing operations performed with more frequently used parameters For this purpose the non-volatile storage organized as a cyclic log with new versions of data being written at the end of the log not in place where the previous versions of the same data are stored  ",
							" PDS Library Usage PIC32CX-BZ3 Persistent Data Server(PDS) Library Usage  Configuring the library  There is no configuration of this library  Using the library  Defining Files and Directories  In PDS particular pieces of persistent data are called files (or items) and groups of files are called directories Note that directories are just the way to refer to particular files and a file can belong to several directories at once Files and directories contain the meta-information about the data that allows its maintenance within the NV – file descriptors and directory descriptors  The PDS component defines a number of file units for individual stack parameters and directories to group files for more subtle control The application may define its own items  File and File Descriptor  Each item which user wants to backup in a non-volatile memory and restore in case of power failure is treated as a FILE - actual item value with associated service information FILE DESCRIPTOR Each file could be accessed by it's ID a unique 16-bit value associated with a file File descriptor keeps information about item's size and it's displacement in RAM and inside the NV storage  All file descriptors should be placed in a special segment inside the MCU Flash memory - [PDS_FF] The PDS_FILE_DESCR() macro is used to initialize descriptor and PDS_DECLARE_FILE() macro is used to place descriptor to required segment  A file descriptor consists of the following parts:    memoryId: memory identifier associated with a file  size: the size of file’s data  ramAddr: the pointer to item’s entity in RAM (that is to a variable holding file’s data) if one exists or NULL otherwise  fileMarks: file marks specifying specific characteristics of the file File marks may be set either to following values:  SIZE_MODIFICATION_ALLOWED: indicates that size of the file can be different in new firmware image after over-the-air upgrade Usually is set for files storing table data such as binding table group table and others  ITEM_UNDER_SECURITY_CONTROL: no impact works same as NO_FILE_MARKS  NO_FILE_MARKS: no special characteristics for the file     A file descriptor tied to some data in RAM is defined by using the PDS_DECLARE_FILE macro in the code that may be used by both the stack and the application:   PDS_DECLARE_FILE(memoryId size ramAddr fileMarks)   Directory and Directory Descriptor  PDS is able to operate with separate files or with file lists - DIRECTORIES Directory nesting is allowed Each directory should be provided with DIRECTORY DESCRIPTOR which keeps information about associated items Directories could be accessed by 16-bit ID different from already associated with files  All directory descriptors should be placed in a special segment inside the MCU Flash memory - [PDS_FD] The PDS_DECLARE_DIR() macro is used to place a directory to required segment  Directory descriptors are special entities describing a group of file A directory descriptor is defined in the code (the stack’s or the application’s one) and is placed to the separate flash memory segment  The directory descriptor consists of the following parts:  list: pointer to the list of files IDs associated with the directory This list should be placed in the flash memory (by the use of the PROGMEM_DECLARE macro – see an example below)  filesCount: the amount of files associated with the directory  memoryId: memory identifier associated with the directory   A directory is declared via the PDS_DECLARE_DIR macro in the following way:   PDS_DECLARE_DIR(const PDS_DirDescr_t csGeneralParamsDirDescr) = { list = CsGeneralMemoryIdsTable filesCount = ARRAY_SIZE(CsGeneralMemoryIdsTable) memoryId = BC_GENERAL_PARAMS_MEM_ID }; //Where CsGeneralMemoryIdsTable is the list of objects defined in the following way: PROGMEM_DECLARE(const PDS_MemId_t CsGeneralMemoryIdsTable[]) = { CS_UID_MEM_ID CS_RF_TX_POWER_MEM_ID //other parameters in this list }      Major Functions       Name  Description      PDS_Init  initializes the Persistence Data Server    PDS_InitItems  initializes the Persistence Data Server Items    PDS_Restore  Restores data from non-volatile storage    PDS_Store  Stores data in non-volatile memory in background not blocking other processes    PDS_DeleteAll  deletes data from non-volatile storage    PDS_AddItemExcpetionFromDeleteAll  extempts the item from the Delete All command    PDS_Delete  removes specified file records from NV Storage    PDS_IsAbleToRestore  Checks if the specified PDS file or directory can be restored from non-volatile memory    PDS_RegisterWriteCompleteCallback  registers the callback for the Item Write completion    PDS_RegisterUpdateMemoryCallback  registers the callback for the Item update memory    PDS_StoreItemTaskHandler  task that handles the store items into NV memory    PDS_GetPendingItemsCount  gets the number of items pending in the PDS write queue    PDS_GetItemDescr  gets the item descriptor for the given item ID       ",
							" PDS_AddItemExcpetionFromDeleteAll Function ",
							" C bool PDS_AddItemExcpetionFromDeleteAll (PDS_MemId_t itemID); ",
							" Description This routine extempts the item from the Delete All command Makes the item double persistent ",
							" Parameters Param Description PDS_MemId_t Item ID to be exempted ",
							" Returns bool - True ",
							" PDS_DataServerState_t Enum ",
							" C typedef enum { PDS_SUCCESS // Command completed successfully } PDS_DataServerState_t; ",
							" PDS_DECLARE_ITEM(item Macro ",
							" C #define PDS_DECLARE_ITEM(item size pointer func flag) To declare an item/file in the PDS item : Item ID (Unique Indentifier number)for that particular Item/File size: size of the item (Maximum allowed size for an Item is 2K (2048 Bytes) pointer: RAM address of the Item func: filler function can be set to NULL (will be called during the store operation) Shall be kept to min size flag: NO_ITEM_FLAGS / SIZE_MODIFICATION_ALLOWED / ITEM_UNDER_SECURITY_CONTROL ",
							" PDS_Delete Function ",
							" C PDS_DataServerState_t PDS_Delete(PDS_MemId_t memoryId); ",
							" Description This routine removes specified file records from NV Storage ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be removed from NV memory ",
							" Returns PDS state as an operation result ",
							" PDS_DeleteAll Function ",
							" C PDS_DataServerState_t PDS_DeleteAll(bool includingPersistentItems); ",
							" Description This routine deletes data from non-volatile storage except the Persistent items depending on the parameter passed ",
							" Parameters Param Description includingPersistentItems deletes Persistent items if TRUE deletes all other items except Persistent items if FALSE ",
							" Returns PDS_DataServerState_t - status of PDS DeleteAll ",
							" PDS_DirDescr_t Struct ",
							" C typedef struct { // PDS Memory identifier record list PDS_MemIdRec_t list; // Number of files in the directory uint16_t filesCount; // Memory identifier PDS_MemId_t memoryId; } PDS_DirDescr_t; ",
							" PDS_DIRECTORY_ID_MASK Function ",
							" C #define PDS_DIRECTORY_ID_MASK 0x0C00U // (Bit 11 and Bit 10) Use this Directory mask on declaring directory item id's along with module specific offsets PDS_DECLARE_DIR ",
							" PDS_DIRECTORY_ID_MASK Macro ",
							" C #define PDS_DIRECTORY_ID_MASK 0x0C00U // (Bit 11 and Bit 10) ",
							" PDS_GetItemDescr Function ",
							" C bool PDS_GetItemDescr(PDS_MemId_t memoryId ",
							" Description This routine gets the item descriptor for the given item ID ",
							" Parameters Param Description memoryId item id itemDescrToGet pointer to item descriptor to be loaded ",
							" Returns true if descriptor is found out for the given item ID false - otherwise ",
							" PDS_GetPendingItemsCount Function ",
							" C uint8_t PDS_GetPendingItemsCount (void); ",
							" Description This routine returns no of items pending in the PDS write queue ",
							" Parameters None ",
							" Returns uint8_t value No of items waiting in the queue zero if no items are pending ",
							" PDS_Init Function ",
							" C void PDS_Init(PDS_MemId_t maxItems PDS_MemId_t maxDirectories); ",
							" Description This routine initializes Persistent Data Server ",
							" Parameters Param Description maxItems Total number of individual PDS items used in the entire system maxDirectories Total number of PDS directories used in the entire system ",
							" Returns None ",
							" PDS_InitItems Function ",
							" C void PDS_InitItems(uint16_t memIdStart uint16_t memIdEnd); ",
							" Description This routine initializes PDS items Initializes an item with default data if it doesn't exist yet or reads it when it does exist ",
							" Parameters Param Description memIdStart The start memory identifier memIdEnd The end memory identifier ",
							" Returns true if all expected files have been restored false - otherwise ",
							" PDS_IsAbleToRestore Function ",
							" C bool PDS_IsAbleToRestore(PDS_MemId_t memoryId); ",
							" Description This routine checks if the specified PDS file or directory can be restored from non-volatile memory ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be checked ",
							" Returns true if the specified memory can be restored; false - otherwise ",
							" PDS_IsAbleToStore Function ",
							" C bool PDS_IsAbleToStore(PDS_MemId_t memoryId); ",
							" Description This routine checks if the specified PDS file or directory can be stored in non-volatile memory ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be checked ",
							" Returns true if the specified memory can be stored; false - otherwise ",
							" PDS_MAX_FILE_SIZE Macro ",
							" C #define PDS_MAX_FILE_SIZE (2 1024) //bytes ",
							" PDS_MemId_t Typedef ",
							" C typedef const PDS_MemId_t PDS_MemIdRec_t; ",
							" PDS_MODULE_APP_OFFSET Function ",
							" C #define PDS_MODULE_APP_OFFSET (1 12) The following offsets CAN be used(OR'ed) to define the range and also to differentiate the module specific IDs so the same item ID will not be used across the stacks/modules The IDs ranges are required to maintain the backward compatibility during an SW upgrade with newly added item(s) in any module Note: These offset were not used anywhere inside PDS implementation(Library) This is purely to enable the application to use specific IDs across modules ",
							" PDS_MODULE_APP_OFFSET Macro ",
							" C #define PDS_MODULE_APP_OFFSET (1 12) ",
							" PDS_MODULE_BT_OFFSET Macro ",
							" C #define PDS_MODULE_BT_OFFSET (1 13) ",
							" PDS_MODULE_RES_OFFSET Macro ",
							" C #define PDS_MODULE_RES_OFFSET (1 15) ",
							" PDS_MODULE_ZB_OFFSET Macro ",
							" C #define PDS_MODULE_ZB_OFFSET (1 14) ",
							" PDS_Operation_Offset_t Struct ",
							" C typedef struct { // Item identifier PDS_MemId_t id; // Item offset uint16_t offset; // size of item uint16_t size; // corresponding ram address for the item uint8_t ramAddr; }PDS_Operation_Offset_t; ",
							" PDS_RegisterUpdateMemoryCallback Function ",
							" C void PDS_RegisterUpdateMemoryCallback (bool (*callbackFn)(PDS_UpdateMemory_t *)); ",
							" Description This routine register the callback for the Item update memory Updates BC parameters after restoring taking into account possible size ",
							" Parameters Param Description PDS_UpdateMemory_t PDS_UpdateMemory_t callbackFn pointer to callback functions ",
							" Returns None ",
							" PDS_RegisterWriteCompleteCallback Function ",
							" C void PDS_RegisterWriteCompleteCallback (void (*callbackFn)(PDS_MemId_t)); ",
							" Description This routine registers the callback for the Item Write completion ",
							" Parameters Param Description callbackFn callback which gets called after write complete ",
							" Returns None ",
							" PDS_Restore Function ",
							" C bool PDS_Restore(PDS_MemId_t memoryId); ",
							" Description This routine restores data from non-volatile storage PDS files not included in the current build configuration will be ignored Restoring process will be performed only if all files expected for actual configuration are presented in NV storage ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be restored from non-volatile memory ",
							" Returns true if all expected files have been restored false - otherwise ",
							" PDS_Store Function ",
							" C bool PDS_Store(PDS_MemId_t memoryId); ",
							" Description This routine stores data in non-volatile memory in background not blocking other processes Make sure the item/file size is less than MAX_FILE_SIZE ",
							" Parameters Param Description memoryId an identifier of PDS file or directory to be stored from non-volatile memory ",
							" Returns True if storing process has begun false - otherwise ",
							" PDS_StoreItemTaskHandler Function ",
							" C void PDS_StoreItemTaskHandler(void); ",
							" Description This routine is the PDS store item handler Actual flash write operation of a particular Item ID Can be called when system is Idle or when necessary ",
							" Parameters Param Description PDS_UpdateMemory_t PDS_UpdateMemory_t callbackFn pointer to callback functions ",
							" Returns None ",
							" SIZE_MODIFICATION_ALLOWED Macro ",
							" C #define SIZE_MODIFICATION_ALLOWED 0x01U ",
							" PIC32CX-BZ3 Boot Services Help  The PIC32CX-BZ3 Boot Services is a utility which helps in creating firmware image for programming PIC32CXBZ3 device This utility (Header OTA tabs) can be used to append metadata header and OTA headers to an application image  Boot services utility  DFP for the PIC32CXBZ3 comes with default device_support py file that enables Header and OTA tabs within the properties window of an MPLAB X project  Please find the description below on the labels        Label Name  Description      Flash Type  Select between embedded flash and boot flash    MD_SEQ_NUM  Firmware sequence number    AUTH_MTHD  Authentication Method The supported authentication methods are None ECDSAp384-SHA384 and ECDSAp256-SHA256    FW_IMG_REV  Revision of the firmware It is in the format of x x x x where x is value in range 0-255    Private Key File  Key used for signing the firmware using ECDSA It is PKCS#8 format This label is only enabled when authentication mode other than none is chosen     The complete image including firmware and meta header is signed by the below process  Boot services help in embedding OTA header information as part of the signed firmware binary image which can be done with OTA tab Output File Type as BLE OTA File Output File Type as Zigbee OTA File   Please find the below table which includes the description of the label’s/parameter’s used        Label Name  Description      Output File Name  Output File Name for the OTA package in binary format    Output File Encryption  Option to choose whether to Encrypt the OTA package or not Unencrypted /encrypted    AES Key  This option is enabled only if Output File Encryption is set to encrypted 128bit AES key to encrypt the OTA package with AES-CBC-128    Init Vector  This option is enabled only if Output File Encryption is set to encrypted 128bit Initial Vector to encrypt the OTA package with AES-CBC-128    Output File Type  Output file types are among BLE Zigbee or Combo OTA operation    Flash Image ID  This option is enabled only if Output File file is set to BLE OTA File or Combo OTA File It is the 32bit Identification Number for App layer to confirm the new Flash Image is acceptable    Manufacture Code  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 16-bit manufacturer identifier used to match supported devices Defaults to 0xFFFF (match all)    Image Type  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 16-bit image type Defaults to 0xFFFF (match all)    File Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 32-bit integer representing the file version Can be in the recommended format (8-bit app release 8-bit app build 8 bit stack release 8-bit stack build) simple increasing version or an unsupported version format If in an unsupported version format the OTA Cluster will not be able to compare file versions Defaults to 0x0000    Stack Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 16-bit identifier of the zigbee stack version Defaults to 0x02 for zigbee Pro    Header String  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the 32-byte string used by each manufacturer as they see fit but recommended to be human readable    Security Credential Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 8-bit identifier of the Security Credential Version Defaults to not included    Upgrade File Destination  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 64-bit extended address of the device to which this image is specific Defaults to not include image is available to all devices    Minimum Hardware Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 0/16-bit integer representing the earliest hardware platform this image can be used on    Maximum Hardware Version  This option is enabled only if Output File file is set to Zigbee OTA File or Combo OTA File It is the optional 16-bit integer representing the latest hardware platform this image can be used on     Boot services generates linker script with the below memory layout which lets the stack to store the image in Slot 1 during stack OTA process    ",
							" PIC32CX-BZ3 Standalone Bootloader Component Help  PIC32CX-BZ3 bootloader is a standalone harmony component Using it one can generate bootloader which is a program that typically is loaded in to the boot flash memory and gets executed every time the device powers up or resets Due to the size of the internal flash PIC32CX-BZ3 bootloader supports external flash The external flash that is supported in this component is SST26 (available on WBZ351 curiosity board)  Bootloader can be used to upgrade firmware on a target device without the need for an external programmer or debugger It does not fully operate on the device but can perform various functions prior to starting the main application  Functionality of Bootloader  Loads firmware images to embedded flash/external flash over the serial connection using a tool or python script known as Device Firmware Upgrade (DFU)  Provides application protection for firmware (Secured device)  Upgrades application firmware to newer revision  Controls which application can run based on Sequence number and other metadata information embedded in the OTA image   Memory Information and Layout of PIC32CXBZ3 device (WBZ351 Curiosity Board)           Memory Area  Purpose      Boot Flash Size is 0x0080_0000 to 0x0080_3FFF (16KB)  The memory where bootloader code runs    Embeded Flash Slot 0 base address - 0x01000000  The memory where the application firmware runs and the memory where the bootloader copies the new application firmware    Embedded Flash Slot 1 base address - 0x01040000  The memory where the received image(Either through DFU or any other way) gets stored and the memory where bootloader looks for the new image to copy into the Slot 0    External Flash Slot 0 (SST26)  Start Address (relative):0x00000; Size 512KB    External Flash Slot 1(SST26)  Start Address (relative): 0x80000; Size 512KB       Boot Flash  In PIC32CXBZ3 16KB boot flash memory is separated from the main execution memory This boot flash is used for bootloader code  Metadata Header  Format of image meta-data header is described in the Secure Boot ROM Help page - PIC32CX-BZ3 Secure Boot ROM Help   Working of Bootloader  when the application receives new image from a server or via a tool it will/should store in the Slot 1 location with meta data header firmware or in the external flash and it should trigger software reset so that bootloader code runs  Bootloader checks for valid image in the external flash and the internal flash by reading the meta data header and firmware and authenticating the same with the selected authentication method If valid image is found and successfully authenticated then  Erases Slot 0  Copies the new image (DFU or OTA) image to Slot 0  Verifies the Copy  After that it checks for valid image in Slot 0 by validating it it jumps to the application if valid image is found  Bootloader usage with DFU  Bootloader programmed to the MCU (in DFU mode) receives an application image from the host over serial interface and writes it to the external flash or internal flash slot 1 After loading new image on external flash or internal flash slot 1 if reset is triggered then bootloader erases the slot 0 copies the image to slot 0 verifies the copy Then bootloader jumps to application which is the new application image  Bootloader stores information about the image in Meta Data Header This is basically size of 0x200 bytes and gets stored at the start of slot Bootloader reads this meta data header and does the authentication procedure based on the information in meta data header  Flow Diagram of Bootloader  The detailed flow diagram of bootloader with the optional DFU block can be found below   ",
							" Configuration Options  Default configuration options window for bootloader is shown below   Enable Console option  Information on bootloader activities will printed into console using SERCOM UART By Default this option is enabled (In the current version disble option is not provided) Make sure to connect the UART dependency in the bootloader with the SERCOM UART  ECC Public Key  By default ECC Public key is 0xc2 0x81 0x8f 0xbb 0x28 0x61 0x47 0x8b 0xa2 0x53 0x37 0x79 0xd4 0x63 0x18 0x7c 0x8b 0x41 0x59 0xa9 0x5f 0x0b 0x6b 0x94 0x4e 0xb9 0x57 0xa1 0x03 0xfe 0x20 0xbf 0x2b 0xb8 0x14 0x2a 0x64 0xb5 0xae 0x4a 0x83 0x80 0xdd 0xe6 0xee 0x29 0x89 0xdd 0xa0 0x9a 0xc7 0xda 0x82 0xeb 0x56 0x62 0x90 0x5d 0x66 0xc5 0xbc 0x30 0x3c 0x84  User should be able to change this key by changing the text box  Supported Authentication Methods  Three methods of authentication is supported in the bootloader  None  ECDSA-p256  ECDSA-p384   By Default all these three modes are enabled If customer want to use a specific authentication alone for security aspect they can choose that alone  Enable Bootloader UART DFU option  By defualt UART DFU (Device Firmware Upgrade) functionality will be enabled in the bootloader DFU can be used to upgrade firmware on a target device through serially (UART) Make sure to connect the UART dependency in the bootloader with the SERCOM UART  UART DFU Modes -  GPIO Trigger DFU Mode   DFU : GPIO Trigger DFU Mode   GPIO Trigger DFU Mode  In this mode DFU functionality is enabled when you hold the GPIO button and press reset button to put the bootloader into the DFU mode  Use GPIO Port and Pin option to change the port and pin based on the board With PIC32CXBZ2 Curiosity board GPIO PB4 is used as user button The above default settings are based on this User can change if different board is used   ",
							" DFU Functionality - Serial image bootloader  DFU the device firmware upgrade in bootloader is used to load new image which is received from host over serial interface and writes into the internal flash or external flash The host may be python script or pc tool  There are two possible ways the device bootloader can be put into DFU mode  GPIO trigger DFU Mode  By holding GPIO pin/button and resetting the board helps to enter DFU mode   ",
							" Bootloader API Usage  The following macros typedef functions defintions help for generic functions of bootloader  ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" AUTH_STATUS Enum ",
							" C typedef enum { AUTH_STATUS_BUSY = 0x530839fa AUTH_STATUS_FAILED = 0xe97d40ce AUTH_STATUS_SUCCESS = 0x0ac60ce4 } AUTH_STATUS; ",
							" Description Identifies the possible authentication statuses ",
							" DFU API Usage  The following macros typedef functions defintions help to understand DFU functionality of bootloader  ",
							" Crc32Add Function ",
							" C void Crc32Add(uint8_t* pBuff uint32_t bSize); ",
							" Description This routine adds the given data into CRC32 caculation and calculates CRC ",
							" Parameters Param Description uint8_t pBuff pointer to the data to add uint32_t bSize size of the data to add ",
							" Returns None ",
							" Crc32Init Function ",
							" C void Crc32Init(uint16_t seed); ",
							" Description This routine initializes the CRC32 operation ",
							" Parameters Param Description uint16_t seed seed for CRC calculation ",
							" Returns None ",
							" Crc32Result Function ",
							" C uint32_t Crc32Result(void); ",
							" Description This routine gets/returns the calculated CRC ",
							" Parameters None ",
							" Returns uint32_t - Calculated CRC ",
							" dfu Function ",
							" C void dfu(const IMG_MEM_TOPOLOGY ** tops uint8_t count); ",
							" Description This routine will initiate the device firmware upgrade where it waits for commands and response for commands received from serial ",
							" Parameters Param Description IMG_MEM_TOPOLOGY tops valid toplogies list uint8_t count number of valid topologies ",
							" Returns None ",
							" Microchip Information ",
							" The Microchip Website  Microchip provides online support via our website at This website is used to make files and information easily available to customers Some of the content available includes:   Product Support – Data sheets and errata application notes and sample programs design resources user’s guides and hardware support documents latest software releases and archived software  General Technical Support – Frequently Asked Questions (FAQs) technical support requests online discussion groups Microchip design partner program member listing  Business of Microchip – Product selector and ordering guides latest Microchip press releases listing of seminars and events listings of Microchip sales offices distributors and factory representatives   ",
							" Product Change Notification Service  Microchip’s product change notification service helps keep customers current on Microchip products Subscribers will receive email notification whenever there are changes updates revisions or errata related to a specified product family or development tool of interest  To register go to and follow the registration instructions  ",
							" Customer Support  Users of Microchip products can receive assistance through several channels:   Distributor or Representative  Local Sales Office  Embedded Solutions Engineer (ESE)  Technical Support   Customers should contact their distributor representative or ESE for support Local sales offices are also available to help customers A listing of sales offices and locations is included in this document  Technical support is available through the website at:  ",
							" Microchip Devices Code Protection Feature  Note the following details of the code protection feature on Microchip products:   Microchip products meet the specifications contained in their particular Microchip Data Sheet  Microchip believes that its family of products is secure when used in the intended manner within operating specifications and under normal conditions  Microchip values and aggressively protects its intellectual property rights Attempts to breach the code protection features of Microchip product is strictly prohibited and may violate the Digital Millennium Copyright Act  Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its code Code protection does not mean that we are guaranteeing the product is “unbreakable” Code protection is constantly evolving Microchip is committed to continuously improving the code protection features of our products   ",
							" Legal Notice  This publication and the information herein may be used only with Microchip products including to design test and integrate Microchip products with your application Use of this information in any other manner violates these terms Information regarding device applications is provided only for your convenience and may be superseded by updates It is your responsibility to ensure that your application meets with your specifications Contact your local Microchip sales office for additional support or obtain additional support at   THIS INFORMATION IS PROVIDED BY MICROCHIP \"AS IS\" MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED WRITTEN OR ORAL STATUTORY OR OTHERWISE RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE OR WARRANTIES RELATED TO ITS CONDITION QUALITY OR PERFORMANCE  IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT SPECIAL PUNITIVE INCIDENTAL OR CONSEQUENTIAL LOSS DAMAGE COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE INFORMATION OR ITS USE HOWEVER CAUSED EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE TO THE FULLEST EXTENT ALLOWED BY LAW MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR ITS USE WILL NOT EXCEED THE AMOUNT OF FEES IF ANY THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THE INFORMATION  Use of Microchip devices in life support and/or safety applications is entirely at the buyer's risk and the buyer agrees to defend indemnify and hold harmless Microchip from any and all damages claims suits or expenses resulting from such use No licenses are conveyed implicitly or otherwise under any Microchip intellectual property rights unless otherwise stated  ",
							" Trademarks  The Microchip name and logo the Microchip logo Adaptec AVR AVR logo AVR Freaks BesTime BitCloud CryptoMemory CryptoRF dsPIC flexPWR HELDO IGLOO JukeBlox KeeLoq Kleer LANCheck LinkMD maXStylus maXTouch MediaLB megaAVR Microsemi Microsemi logo MOST MOST logo MPLAB OptoLyzer PIC picoPower PICSTART PIC32 logo PolarFire Prochip Designer QTouch SAM-BA SenGenuity SpyNIC SST SST Logo SuperFlash Symmetricom SyncServer Tachyon TimeSource tinyAVR UNI/O Vectron and XMEGA are registered trademarks of Microchip Technology Incorporated in the U S A and other countries  AgileSwitch APT ClockWorks The Embedded Control Solutions Company EtherSynch Flashtec Hyper Speed Control HyperLight Load Libero motorBench mTouch Powermite 3 Precision Edge ProASIC ProASIC Plus ProASIC Plus logo Quiet- Wire SmartFusion SyncWorld Temux TimeCesium TimeHub TimePictra TimeProvider TrueTime and ZL are registered trademarks of Microchip Technology Incorporated in the U S A  Adjacent Key Suppression AKS Analog-for-the-Digital Age Any Capacitor AnyIn AnyOut Augmented Switching BlueSky BodyCom Clockstudio CodeGuard CryptoAuthentication CryptoAutomotive CryptoCompanion CryptoController dsPICDEM dsPICDEM net Dynamic Average Matching DAM ECAN Espresso T1S EtherGREEN GridTime IdealBridge In-Circuit Serial Programming ICSP INICnet Intelligent Paralleling IntelliMOS Inter-Chip Connectivity JitterBlocker Knob-on-Display KoD maxCrypto maxView memBrain Mindi MiWi MPASM MPF MPLAB Certified logo MPLIB MPLINK MultiTRAK NetDetach Omniscient Code Generation PICDEM PICDEM net PICkit PICtail PowerSmart PureSilicon QMatrix REAL ICE Ripple Blocker RTAX RTG4 SAM-ICE Serial Quad I/O simpleMAP SimpliPHY SmartBuffer SmartHLS SMART-I S storClad SQI SuperSwitcher SuperSwitcher II Switchtec SynchroPHY Total Endurance Trusted Time TSHARC USBCheck VariSense VectorBlox VeriPHY ViewSpan WiperLock XpressConnect and ZENA are trademarks of Microchip Technology Incorporated in the U S A and other countries  SQTP is a service mark of Microchip Technology Incorporated in the U S A  The Adaptec logo Frequency on Demand Silicon Storage Technology and Symmcom are registered trademarks of Microchip Technology Inc in other countries  GestIC is a registered trademark of Microchip Technology Germany II GmbH Co KG a subsidiary of Microchip Technology Inc in other countries  All other trademarks mentioned herein are property of their respective companies  © Microchip Technology Incorporated and its subsidiaries All Rights Reserved  ISBN:  ",
							" Quality Management System   For information regarding Microchip’s Quality Management Systems please visit    ",
							" Worldwide Sales and Service          AMERICAS  ASIA/PACIFIC  ASIA/PACIFIC  EUROPE       Corporate Office  2355 West Chandler Blvd  Chandler AZ 85224-6199  Tel: 480-792-7200  Fax: 480-792-7277  Technical Support:   Web Address:   Atlanta  Duluth GA  Tel: 678-957-9614  Fax: 678-957-1455  Austin TX  Tel: 512-257-3370  Boston  Westborough MA  Tel: 774-760-0087  Fax: 774-760-0088  Chicago  Itasca IL  Tel: 630-285-0071  Fax: 630-285-0075  Dallas  Addison TX  Tel: 972-818-7423  Fax: 972-818-2924  Detroit  Novi MI  Tel: 248-848-4000  Houston TX  Tel: 281-894-5983  Indianapolis  Noblesville IN  Tel: 317-773-8323  Fax: 317-773-5453  Tel: 317-536-2380  Los Angeles  Mission Viejo CA  Tel: 949-462-9523  Fax: 949-462-9608  Tel: 951-273-7800  Raleigh NC  Tel: 919-844-7510  New York NY  Tel: 631-435-6000  San Jose CA  Tel: 408-735-9110  Tel: 408-436-4270  Canada - Toronto  Tel: 905-695-1980  Fax: 905-695-2078    Australia - Sydney  Tel: 61-2-9868-6733  China - Beijing  Tel: 86-10-8569-7000  China - Chengdu  Tel: 86-28-8665-5511  China - Chongqing  Tel: 86-23-8980-9588  China - Dongguan  Tel: 86-769-8702-9880  China - Guangzhou  Tel: 86-20-8755-8029  China - Hangzhou  Tel: 86-571-8792-8115  China - Hong Kong SAR  Tel: 852-2943-5100  China - Nanjing  Tel: 86-25-8473-2460  China - Qingdao  Tel: 86-532-8502-7355  China - Shanghai  Tel: 86-21-3326-8000  China - Shenyang  Tel: 86-24-2334-2829  China - Shenzhen  Tel: 86-755-8864-2200  China - Suzhou  Tel: 86-186-6233-1526  China - Wuhan  Tel: 86-27-5980-5300  China - Xian  Tel: 86-29-8833-7252  China - Xiamen  Tel: 86-592-2388138  China - Zhuhai  Tel: 86-756-3210040    India - Bangalore  Tel: 91-80-3090-4444  India - New Delhi  Tel: 91-11-4160-8631  India - Pune  Tel: 91-20-4121-0141  Japan - Osaka  Tel: 81-6-6152-7160  Japan - Tokyo  Tel: 81-3-6880- 3770  Korea - Daegu  Tel: 82-53-744-4301  Korea - Seoul  Tel: 82-2-554-7200  Malaysia - Kuala Lumpur  Tel: 60-3-7651-7906  Malaysia - Penang  Tel: 60-4-227-8870  Philippines - Manila  Tel: 63-2-634-9065  Singapore  Tel: 65-6334-8870  Taiwan - Hsin Chu  Tel: 886-3-577-8366  Taiwan - Kaohsiung  Tel: 886-7-213-7830  Taiwan - Taipei  Tel: 886-2-2508-8600  Thailand - Bangkok  Tel: 66-2-694-1351  Vietnam - Ho Chi Minh  Tel: 84-28-5448-2100    Austria - Wels  Tel: 43-7242-2244-39  Fax: 43-7242-2244-393  Denmark - Copenhagen  Tel: 45-4485-5910  Fax: 45-4485-2829  Finland - Espoo  Tel: 358-9-4520-820  France - Paris  Tel: 33-1-69-53-63-20  Fax: 33-1-69-30-90-79  Germany - Garching  Tel: 49-8931-9700  Germany - Haan  Tel: 49-2129-3766400  Germany - Heilbronn  Tel: 49-7131-72400  Germany - Karlsruhe  Tel: 49-721-625370  Germany - Munich  Tel: 49-89-627-144-0  Fax: 49-89-627-144-44  Germany - Rosenheim  Tel: 49-8031-354-560  Israel - Ra’anana  Tel: 972-9-744-7705  Italy - Milan  Tel: 39-0331-742611  Fax: 39-0331-466781  Italy - Padova  Tel: 39-049-7625286  Netherlands - Drunen  Tel: 31-416-690399  Fax: 31-416-690340  Norway - Trondheim  Tel: 47-72884388  Poland - Warsaw  Tel: 48-22-3325737  Romania - Bucharest  Tel: 40-21-407-87-50  Spain - Madrid  Tel: 34-91-708-08-90  Fax: 34-91-708-08-91  Sweden - Gothenberg  Tel: 46-31-704-60-40  Sweden - Stockholm  Tel: 46-8-5090-4654  UK - Wokingham  Tel: 44-118-921-5800  Fax: 44-118-921-5820       "];

